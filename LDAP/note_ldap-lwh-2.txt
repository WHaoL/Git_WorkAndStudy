
----------------------------------------openLDAP同步原理及配置------------------------------------------
1.openLDAP同步原理
    openLDAP同步复制(简称syncrepl)机制是消费方的一个复制引擎。
        syncrepl引擎作为slapd的一个线程驻留在消费者那里；
        它建立一个消费者复制，方法是连接复制提供者进行初始化DIT，并进行定期内容拉取 及时根据内容变更来更新目录树信息。
    syncrepl 使用LDAP内容同步协议作为服务器之间同步数据所使用的协议
        有5种同步机制
        拉模式 pull-mode
            refreshOnly同步模式下
                提供者处理定期的拉请求消息
            消费者定期拉取提供者服务器的内容
        推模式 push-mode
            refreshAndPersist同步模式下
                提供者维护了 对 持久性消费者的跟踪，内容修改时发送更新
            消费者监听提供者实时发送的更新信息
    syncrepl是可扩展的

    slurpd同步机制已经废除，2.4版本后采用syncrepl机制
----------------------------------------------------------------------------------
看《Linux+UNIX+OpenLDAP实战指南.郭大勇.2016.pdf》《OpenLDAP-2.4-AdminGuide-ZH_EN.pdf》阅读RFC 
    梳理一遍概念：https://www.cnblogs.com/kevingrace/p/5773974.html 
        https://blog.csdn.net/oyym_mv/article/details/94404663
----------------------------------------------------------------------------------
暂时不做：配置docker，运行起来openLDAO的主从；
        #我们使用docker-centos7作为容器环境
        #以特权模式启动 并挂在本机的配置文件目录到docker的/home/
        docker run -d -it --rm --name=ldap  --privileged -p 80:80 -p 389:389 -p 636:636 -v /home/gos/workspace/Git_WorkAndStudy/LDAP/my_OpenLDAP_Config/:/home/ centos:7 /usr/sbin/init
        #进入容器
        docker exec -it ldap bash 
        #安装docker
        yum install -y yum-utils
        yum-config-manager \
            --add-repo \
            https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
        yum makecache fast
        yum install docker-ce docker-ce-cli containerd.io
        systemctl start docker      
        #GitHub上维护的openLDAP的docker： https://github.com/osixia/docker-openldap
        docker run -p 389:389 -p 636:636 -p 389:389 -p 80:80 --name my-openldap-container --detach osixia/openldap:1.5.0
----------------------------------------------------------------------------------
LDAP-RFC 
    http://www.faqs.org/rfcs/rfc4510.html
      LDAP: The Protocol [RFC4511]
      LDAP: Directory Information Models [RFC4512]
      LDAP: Authentication Methods and Security Mechanisms [RFC4513]
      LDAP: String Representation of Distinguished Names [RFC4514]
      LDAP: String Representation of Search Filters [RFC4515]
      LDAP: Uniform Resource Locator [RFC4516]
      LDAP: Syntaxes and Matching Rules [RFC4517]
      LDAP: Internationalized String Preparation [RFC4518]
      LDAP: Schema for User Applications [RFC4519]


https://www.openldap.org/doc/ OpenLDAP 2.4 Administrator's Guide  OpenLDAP官方2.4版本的手册
----------------------------------------------------------------------------------
    每个entry
        含有一堆属性(attributes)和一个DN(a globally-unique Distinguished Name)
        DN用来引用entry
        每个属性 包含了一个type和一个或多个value;value取决于type
        DN由自身的RDN(cn或者uid)和祖先的DN共同组成
            The full DN format is described in RFC4514, "LDAP: String Representation of Distinguished Names."
    
    slapd(8)是个独立的守护进程，可以看作是轻量级的X.500目录服务器。

    LDAPv3在1990年代后期开发，以取代LDAPv2。

    ------------chapter 04-官网推荐的配置和安装步骤--------------------------------------------------------------
    
    gunzip -c openldap-VERSION.tgz | tar xf -
    cd openldap-VERSION

    安装 OpenSSL，GnuTLS，or MozNSS      to provide Transport Layer Security services.
    安装 Cyrus SASL                     to provide Simple Authentication and Security Layer services. 
    安装 Kerberos                        为了提供强大的身份验证机制 

    OpenLDAP 的 slapd(8)MDB 主数据库后端使用 OpenLDAP 源附带的 LMDB 软件
    OpenLDAP 的 slapd(8)BDB 和 HDB 使用的数据库后端需要 Oracle Corporation 的 Berkeley DB

    openLDAP 支持各种品种的线程

    slapd(8)支持 TCP Wrappers(IP 级别访问控制过滤器)，对于包含非公共信息的服务器，建议使用 TCP Wrappers 或其他 IP 级别的访问过滤器(例如 IP 级别的防火墙提供的过滤器)。

    ./configure --help
    ./configure [options] [variable=value ...]

    #启用 TCP Wrappers(默认没有启用)
    ./configure --enable-wrappers

    ./configure --enable-wrappers     \
    CPPFLAGS="-I/usr/local/include"   \
    LDFLAGS="-L/usr/local/lib -Wl,-rpath,/usr/local/lib"

    #构建依赖
    make depend

    #编译
    make

    #测试
    make test

    #默认安装目录是 /usr/local ， 也可以在运行配置脚本时通过--prefix指定
    #安装   通常，安装需要超级用户权限
    su root -c 'make install'

    #你将在 /usr/local/etc/openldap 或者 /etc/openldap 找到slpad(8)的配置文件
    
    ------------chapter 05-配置 slapd--------------------------------------------------------------

    OpenLDAP2.3及更高版本 开始使用：运行时动态配置引擎 slapd-config(5)，
        配置数据存储在LDIF数据库中，通常在/usr/local/etc/openldap/slapd.d/ 或者/etc/openldap/slapd.d/ 目录中；
        允许即时更改slapd的所有配置选项，通常无需重新启动服务器即可使更改生效
    
    通过slapd.conf配置slap(8)将在chapter06介绍
        如何使slapd自动从slapd.conf(5)转换为 slapd-config(5)的信息
    
    注意：尽管 lapd-config(5)系统将其配置存储为(基于文本的)LDIF 文件，但是您绝对不要直接编辑任何LDIF文件。
        配置更改应通过LDAP操作执行，例如 ldapadd(1)，ldapdelete(1)或 ldapmodify(1)


    slapd 配置存储为具有预定义schema(模式)和 DIT 的特殊 LDAP 目录。
        有一些特定的objectClasses用于承载全局配置选项，模式定义，后端和数据库定义以及各种其他项目。
        slapd-config 配置树具有非常具体的结构。
            树的根名为 cn=config 并包含全局配置设置。
            其他设置包含在单独的子条目中
        Dynamically loaded modules
        Schema definitions
        Backend-specific configuration
        Database-specific configuration
    
    图 5.1 中显示了一个示例 配置树(configuration tree.)
                        -----------------------
                        |cn=config            |
                        |Global config options|
                        -----------------------
                                    |
                ------------------------------------------
                |                   |                    |
        ------------------   ---------------   ---------------------
        |cn=module{0}    |   |cn=schema    |   |olcDatabase={1}bdb |
        |A set of modules|   |System schema|   |A back-bdb instance|
        ------------------   ---------------   ---------------------
                                    |
                            ------------------
                            |                |
                    -------------   ---------------
                    |cn={0}core |   |cn={1}cosine |
                    |Core schema|   |COSINE schema|

    LDIF文件的通常规则适用于配置信息：
        以'#'字符开头的注释行将被忽略。
        如果一行以单个空格开头，则将其视为前一行的延续(即使前一行是注释)，并且会删除单个前导空格。
        条目由空白行分隔。

    LDIF 配置的总体布局如下：
        ----------------------------------
        # global configuration settings
        dn: cn=config
        objectClass: olcGlobal
        cn: config
        <global config settings>

        # schema definitions
        dn: cn=schema,cn=config
        objectClass: olcSchemaConfig
        cn: schema
        <system schema>

        dn: cn={X}core,cn=schema,cn=config
        objectClass: olcSchemaConfig
        cn: {X}core
        <core schema>

        # additional user-specified schema
        ...

        # backend definitions
        dn: olcBackend=<typeA>,cn=config
        objectClass: olcBackendConfig
        olcBackend: <typeA>
        <backend-specific settings>

        # database definitions
        dn: olcDatabase={X}<typeA>,cn=config
        objectClass: olcDatabaseConfig
        olcDatabase: {X}<typeA>
        <database-specific settings>

        # subsequent definitions and settings
        ...

        ----------------------------------
    
    LDAP数据库本质上是无序的。
        数字索引用于在配置数据库中强制执行一致的排序，以便保留所有排序依存关系。
        在大多数情况下，不必提供索引。它会根据条目的创建顺序自动生成。
    
    slapd 配置中使用的大多数属性和 objectClasses 的名称中都带有前缀“olc”(OpenLDAP 配置)
        使用关键字作为属性名称，并附加“olc”前缀
    
    配置指令可以带有参数
        参数中若有空格，则用""把参数括起来
        <> 应该用实际参数替换
    
    示例配置文件，
        在/usr/local/etc/openldap 或/etc/openldap 目录中。
        /usr/local/etc/openldap/schema/ 或/etc/openldap/schema/ 目录中还提供了许多包含模式定义的文件(属性类型和对象类)。

    --------------------下面将从 cn=config 条目中的全局指令开始，详细介绍常用的配置指令-------------------------
    --------------------cn=config 
    cn=config
        此条目中包含的指令通常适用于整个服务器。
        它们大多数是面向系统或面向连接的，与数据库无关。
        此条目必须具有 
            objectClass: olcGlobal

    olcIdleTimeout: <integer>
        对于空闲的客户端连接，指定几秒后强制关闭
        默认值为 0，将禁用此功能。

    olcLogLevel: <level>
        指定 调试语句 和 操作统计信息 应进行 syslog 的级别(当前记录到 syslogd(8)LOG_LOCAL4 设备)。
        必须配置 OpenLDAP --enable-debug(默认设置)才能正常工作(两个统计级别除外，它们始终处于启用状态)。
            注意：slapd 必须已经使用--enable-debug 进行编译
        日志级别可以指定为整数或关键字。
        可以使用多个日志级别，并且这些级别是可叠加的。
        要显示 哪种级别对应哪种调试，调用 slapd 的时候加上-d?
            slapd -d?
        
        <level>的可能值为：
                Table 5.1: Debugging Levels
            Level	Keyword	        Description
            -1	    any	            enable all debugging
            0	 	                no debugging
            1	    (0x1 trace)	    trace function calls
            2	    (0x2 packets)	debug packet handling
            4	    (0x4 args)	    heavy trace debugging
            8	    (0x8 conns)	    connection management
            16	    (0x10 BER)	    print out packets sent and received
            32	    (0x20 filter)	search filter processing
            64	    (0x40 config)	configuration processing
            128	    (0x80 ACL)	    access control list processing
            256	    (0x100 stats)	stats log connections/operations/results
            512	    (0x200 stats2)	stats log entries sent
            1024	(0x400 shell)	print communication with shell backends
            2048	(0x800 parse)	print entry parsing debugging
            16384	(0x4000 sync)	syncrepl consumer processing
            32768	(0x8000 none)	only messages that get logged whatever log level is set
        
        所需的日志级别 可以以 十进制 十六进制输入，组合时使用或运算。例如 下面的这些都是等价的
                olcLogLevel 129
                olcLogLevel 0x81
                olcLogLevel 128 1
                olcLogLevel 0x80 0x1
                olcLogLevel acl trace            
        示例：
            olcLogLevel -1           #记录大量调试信息
            olcLogLevel conns filter #只 记录连接和搜索过滤器处理
            olcLogLevel none         #仅记录任何设置的日志级别的消息，无论级别如何；但是没有日志放生时不等同于0
            olcLogLevel stats        #默认情况下 配置 基本统计日志；如果从未定义过olcLogLevel，则不会发生任何日志记录(相当于 0 级)
    
    olcReferral: <URI>
        当 slapd 找不到本地数据库来处理请求时，指定要传回的引用
        如  olcReferral: ldap://root.openldap.org

    以上几个配置指令的 一个简单使用示例 Sample Entries(示例条目)如下：
        -------------
        dn: cn=config
        objectClass: olcGlobal
        cn: config
        olcIdleTimeout: 30
        olcLogLevel: Stats
        olcReferral: ldap://root.openldap.org
        -------------


    --------------------cn=module
    cn=module
        如果在配置slapd的时候 启用了对 动态加载模块 的支持,则cn=module条目 可用于指定要加载的模块集
        必须包含  objectClass: olcModuleList
    olcModuleLoad: <filename>
        指定要加载的 动态可加载模块的名称。
        文件名 可以是绝对路径名或者简单文件名
            写绝对路径名,就可以不写olcModulePath: <pathspec>
            写文件名,就需要写olcModulePath: <pathspec>
        将在 olcModulePath: <pathspec>指令 指定的目录中去 搜索 非绝对名称
    olcModulePath: <pathspec>
        指定目录列表,用以搜索可加载模块;
        通常，路径以冒号分隔.但也取决于操作系统.
    Sample Entries(示例条目)如下：
        -------------
        dn: cn=module{0},cn=config
        objectClass: olcModuleList
        cn: module{0}
        olcModuleLoad: /usr/local/lib/smbk5pwd.la

        dn: cn=module{1},cn=config
        objectClass: olcModuleList
        cn: module{1}
        olcModulePath: /usr/local/lib:/usr/local/lib/slapd
        olcModuleLoad: accesslog.la
        olcModuleLoad: pcache.la
        -------------
        我的目录是
            /usr/lib64/openldap/smbk5pwd.la
            /usr/lib64/:/usr/lib64/openldap/

    --------------------cn=schema
    cn=schema
        条目cn=schema包含所有以 slapd 形式硬编码的模式定义
            此条目中的值由slapd生成，所以无需在配置文件中提供任何schema value
            但是仍然需要定义该条目,以作为用户定义的架构的基础，以便在其下添加。
        必须包含 objectClass: olcSchemaConfig
    
    olcAttributeTypes: <RFC4512 Attribute Type Description>
        该指令定义属性类型
        请参见 第13章 Schema Specification 
    
    olcObjectClasses: <RFC4512 Object Class Description>
        该指令定义了一个对象类
        请参见 第13章 Schema Specification 
    
    Sample Entries(示例条目)如下：
        -------------
        dn: cn=schema,cn=config
        objectClass: olcSchemaConfig
        cn: schema

        dn: cn=test,cn=schema,cn=config
        objectClass: olcSchemaConfig
        cn: test
        olcAttributeTypes: ( 1.1.1
          NAME 'testAttr'
          EQUALITY integerMatch
          SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 )
        olcAttributeTypes: ( 1.1.2 NAME 'testTwo' EQUALITY caseIgnoreMatch
         SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.44 )
        olcObjectClasses: ( 1.1.3 NAME 'testObject'
         MAY ( testAttr $ testTwo ) AUXILIARY )
        -------------


    --------------------olcBackend
    后端参数指令(Backend-specific Directives)
        适用于相同类型的所有数据库实例，并且取决于指令，数据库指令可能会覆盖后端指令。
        必须包含 objectClass: olcBackendConfig
    olcBackend: <type> 
        该指令标志着后端声明的开始。 
        <type>应该为下表之一
                表 5.2：数据库后端
                Table 5.2: Database Backends
            Types	        Description
            bdb	        Berkeley DB transactional backend (deprecated)
            config	    Slapd configuration backend
            dnssrv	    DNS SRV backend
            hdb	        Hierarchical variant of bdb backend (deprecated)
            ldap	    Lightweight Directory Access Protocol (Proxy) backend
            ldif	    Lightweight Data Interchange Format backend
            mdb	        Memory-Mapped DB backend
            meta	    Meta Directory backend
            monitor	    Monitor backend
            passwd	    Provides read-only access to passwd(5)
            perl	    Perl Programmable backend
            shell	    Shell (extern program) backend
            sql	SQL     Programmable backend
        示例:
            olcBackend: bdb
        注意:
            没有为该条目定义其他指令。
            特定的后端类型可以为它们的特定用途定义其他属性，但是到目前为止，还没有定义。 
            因此，这些指令通常不会出现在任何实际配置中。
    Sample Entry(示例条目)如下：
        -------------
        dn: olcBackend=bdb,cn=config
        objectClass: olcBackendConfig
        olcBackend: bdb
        -------------


    --------------------数据库参数指令(Database-specific Directives)
    数据库参数指令(Database-specific Directives)
        每种类型的数据库都支持本节中的指令。
        数据库条目必须包含 objectClass: olcDatabaseConfig 
    
    olcDatabase: [{<index>}]<type>
        该指令命名一个特定的数据库实例。
        数字{<index>}用来区分相同类型的多个数据库。通常可以省略索引，而 slapd 会自动生成它。
        <type>是表5.2中列出的受支持的数据库后端类型之一或前端类型。
            (The frontend)前端是一个特殊的数据库，用于保存 应该被应用于所有其他数据库的数据库级选项。
                后续的数据库定义也可能会覆盖某些前端设置。
            (The config database)配置数据库也很特殊.
            即使未显式配置 config 和 frontend 数据库，也总是隐式创建它们，并且它们在创建其他任何数据库之前都被创建。
        示例:
            olcDatabase: bdb    #这标志着一个新的 BDB 数据库实例的开始
            olcDatabase: mdb    #这标志着一个新的 MDB 数据库实例的开始
    
    olcAccess: to <what> [ by <who> [<accesslevel>] [<control>] ]+
        该指令允许
            一个或多个请求者(由<who>指定)
            对一组条目和/或属性(由<what>指定)的
            访问权限(由<accesslevel>指定)。
        有关基本用法，请参见本指南的 第8章 Access Control
        注意：
            如果未指定 olcAccess 指令，则默认访问控制策略是 to * by * read，允许所有用户(经过身份验证的用户和匿名用户)进行读取访问。
        注意：
            前端中定义的访问控制将附加到所有其他数据库的控制中。
    
    olcReadonly { TRUE | FALSE }
        该指令将数据库置于“只读”模式。任何修改数据库的尝试都将返回“不愿执行”错误。
        如果在consumer上设置，则仍然会发生由 syncrepl 发送的修改
        默认:olcReadonly: FALSE
    
    olcRootDN: <DN>
        指定管理员DN; 
            此DN对数据库的操作将不受限制
            此DN可以引用 SASL 身份
        基于Entry的示例:   olcRootDN: cn=Manager,dc=example,dc=com
        基于SASL的示例:    olcRootDN: uid=root,cn=example.com,cn=digest-md5,cn=auth

    olcRootPW: <password>
        为olcRootDN: <DN>的DN指定密码
            示例:  olcRootPW: 123456
        可以使用slappasswd(8)生成密码的哈希  slappasswd -s 123456
            示例:  olcRootPW: {SSHA}ePepK+E+QnYuDaUP1Fymdau9deDd0Hoe

    olcSizeLimit: <integer>
        该指令指定 从搜索操作返回的最大条目数
        默认:  olcSizeLimit: 500

    olcSuffix: <dn suffix>
        该指令指定 传递到此后端数据库执行查询的 DN 后缀。
            可以指定多个后缀行，通常每个数据库定义至少需要一个后缀行。
            (某些后端类型，例如“frontend”和“monitor”使用硬编码后缀，该后缀可能不会在配置中被覆盖。)
        示例：olcSuffix: dc=example,dc=com
            DN 以“dc=example，dc=com”结尾的查询将传递到此后端。
        注意：
            当选择要传递查询的后端时，slapd会按照配置的顺序查看每个数据库定义中的后缀值。
                如果一个数据库后缀是另一个数据库的前缀，则它必须出现在配置之后。
    
    olcSyncrepl
            olcSyncrepl: rid=<replica ID>
                provider=ldap[s]://<hostname>[:port]
                [type=refreshOnly|refreshAndPersist]
                [interval=dd:hh:mm:ss]
                [retry=[<retry interval> <# of retries>]+]
                searchbase=<base DN>
                [filter=<filter str>]
                [scope=sub|one|base]
                [attrs=<attr list>]
                [attrsonly]
                [sizelimit=<limit>]
                [timelimit=<limit>]
                [schemachecking=on|off]
                [bindmethod=simple|sasl]
                [binddn=<DN>]
                [saslmech=<mech>]
                [authcid=<identity>]
                [authzid=<identity>]
                [credentials=<passwd>]
                [realm=<realm>]
                [secprops=<properties>]
                [starttls=yes|critical]
                [tls_cert=<file>]
                [tls_key=<file>]
                [tls_cacert=<file>]
                [tls_cacertdir=<path>]
                [tls_reqcert=never|allow|try|demand]
                [tls_cipher_suite=<ciphers>]
                [tls_crlcheck=none|peer|all]
                [logbase=<base DN>]
                [logfilter=<filter str>]
                [syncdata=default|accesslog|changelog]
        该指令
            将当前slapd(8)建立为 复制consumer站点  通过运行syncrepl复制引擎，从而将当前数据库指定为 内容提供者 的consumer。
            consumer数据库 和 provider的最新内容保持同步
        rid 
            用于标识复制使用者(cosumer)服务器中的当前 syncrepl 指令
            <replica ID>
                唯一标识当前 syncrepl 指令所描述的 syncrepl 规范
                为非负数且长度不超过三位十进制数
        provider
            provider的 LDAP URI
                指定 包含provider content的 provider站点作为LDAP URI
                这个参数指定了  可以找到provider slap instance 的 scheme host以及可选的port
                <hostname> 可以是域名或者IP 
                [:port]    端口是可选的,如果未提供<port>，则使用标准LDAP端口号(389 或 636)
                例如 ldap://provider.example.com:389 或 ldaps://192.168.1.1:636      
            请注意，syncrepl 使用 consumer启动的协议，因此其规范位于consumer上。
        
        使用 搜索规范 作为结果集 来定义 syncrepl使用者的内容
            使用者slapd 将根据搜索规范 向 提供者slapd 发送搜索请求
            搜索规范包含 searchbase, scope, filter, attrs, attrsonly, sizelimit, timelimit 
                searchbase没有默认值，必须始终指定。
                scope默认为 sub，
                filter默认为(objectclass=*)，
                attrs 默认为“*，+”以复制所有用户和操作属性，
                attrsonly 默认情况下未设置。
                sizelimit 和 timelimit 都默认为“unlimited”，并且只能指定正整数或“unlimited”。

        type
            LDAP内容同步协议有两种类型：refreshOnly 和 refreshAndPersist
            refreshOnly 
                在每个同步操作完成后的间隔时间内，周期性地重新调度下一个同步搜索操作。
                间隔由间隔参数指定,默认是1天
            refreshAndPersist
                同步搜索在提供者slapd实例中保持不变
                对提供者的进一步更新将对消费者产生“searchResultEntry”作为对持久同步搜索的搜索响应。
        
        retry=[<retry interval> <# of retries>]
            如果复制发生错误,则consumer将根据retry参数尝试重新连接
            <重试间隔><重试次数>
                例如，retry="60 10 300 3" 
                    使消费者在前 10 次中每 60 秒重试一次，然后在接下来的 3 次中每 300 秒重试一次，然后再停止重试。
            在<重试次数>中的+表示无限次重试直到成功。

        [schemachecking=on|off]
            打开后,将在LDAP Sync使用者(consumer)站点上强制执行模式(schema)检查
            如果将其关闭，则将在不检查schema一致性的情况下存储条目。
            默认为关闭。
        
        [binddn=<DN>]
            给出了要绑定的 DN
            该DN 对提供者数据库中的复制内容具有读权限

        [bindmethod=simple|sasl]
            是simple还是sasl,取决于连接到 提供者slapd实例 时 是基于密码的简单(simple)身份验证还是使用SASL身份验证

        simple身份验证
            除非有足够的数据完整性和机密性保护(例如 TLS 或 IPsec)，否则不应使用简单身份验证。
            简单身份验证 需要指定
                binddn=<DN>
                credentials=<passwd>
        SASL身份验证
            通常建议使用 SASL 身份验证
            需要使用 saslmech=<mech> 来指定一种机制.
                根据机制可以分别使用身份验证和/或凭据 指定身份验证身份和/或凭据
                authzid=<identity>用于指定授权身份
        
        [realm=<realm>]         指定一个特定的机制进行身份验证  ???!!!
        [secprops=<properties>] 指定Cyrus SASL安全属性
        [starttls=yes|critical] 
            starttls 指定在认证提供商之前使用 StartTLS 扩展操作来建立 TLS 会话。
                当参数是critical时 如果 StartTLS 请求失败，会话将被中止; 否则，syncrepl 会话将继续运行而没有 TLS.
            [tls_reqcert=never|allow|try|demand] 设置默认为"demand"
            其他 TLS 设置默认与主要的 slapdTLS 设置相同。

        [logbase=<base DN>]
        [logfilter=<filter str>]
        [syncdata=default|accesslog|changelog]
            consumer可以查询数据修改日志，而不是复制整个条目
            对于将要使用的日志,必须适当设置 [logbase=<base DN>]和[logfilter=<filter str>] 参数
            如果日志符合slapo-accesslog,则必须将 [syncdata=default|accesslog|changelog] 设置为accesslog
            如果日志符合 过时的changelog,则必须将 [syncdata=default|accesslog|changelog] 设置为changelog
            如果忽略了 [syncdata=default|accesslog|changelog] 参数或将其设置为“默认”，则将忽略日志参数


        使用 bdb，hdb 和 mdb 后端支持 syncrepl 复制机制

    



    
    [olcTimeLimit: <integer>]
        该指令指定了 slapd 响应搜索请求所花费的最大秒数(实时)。如果请求在此时间内未完成，则将返回: 指示超出时间限制的结果。
        默认：
            olcTimeLimit: 3600
    
    olcUpdateref: <URL>
        仅适用于副本(或 shadow) slapd(8)实例.
        用于指定 要返回给客户端的URL , 客户端将在副本上提交更新请求
        如果多次指定，则提供每个 URL
        Example:
            olcUpdateref:   ldap://provider.example.net
    
    Sample Entries(示例条目)如下：
        -------------
        dn: olcDatabase=frontend,cn=config
        objectClass: olcDatabaseConfig
        objectClass: olcFrontendConfig
        olcDatabase: frontend
        olcReadOnly: FALSE
        dn: olcDatabase=config,cn=config
        objectClass: olcDatabaseConfig
        olcDatabase: config
        olcRootDN: cn=Manager,dc=example,dc=com
        -------------




    --------------------BDB 和 HDB 数据库指令(BDB and HDB Database Directives)
    BDB 和 HDB 数据库指令
        此类别中的指令适用于 BDB 和 HDB 数据库。
            除了上面定义的通用数据库指令外，它们还用于olcDatabase 条目中。
            有关 BDB/HDB 配置指令的完整参考，请参见 slapd-bdb(5)。
        除了objectClass: olcDatabaseConfig之外，BDB 和 HDB 数据库条目还必须分别具有 
            objectClass: olcBdbConfig 和
            objectClass: olcHdbConfig 
    olcDbDirectory: <directory>
        指定 包含数据库和相关索引的 BDB文件所在的目录
        Default:
            olcDbDirectory: /usr/local/var/openldap-data
    olcDbCachesize: <integer>
        指定由 BDB后端数据库实例 维护的内存中缓存条目 的大小。
        Default:
            olcDbCachesize: 1000
    olcDbCheckpoint: <kbyte> <min>
        指定 对BDB事务日志  进行检查点的频率
            检查点操作 会将数据库缓冲刷到磁盘，并在日志中写入检查点记录。
        检查点将会被触发 的情况：
            1.上一个检查点已经写入   <kbyte>数据   或者
            2.上一个检查点已经过去过 <min>分钟
        这两个参数默认都为零，在这种情况下，它们将被忽略。
        当<min>为非零值时，内部任务将每隔<min>分钟运行一次 以执行检查点。
        Example:
            olcDbCheckpoint: 1024 10
    olcDbConfig: <DB_CONFIG setting>
        此属性指定 要放置在 数据库目录的DB_CONFIG文件中的 配置指令。
        在服务器启动时，
            如果尚不存在DB_CONFIG文件，则将创建 DB_CONFIG 文件并将该属性中的设置写入其中。
            如果DB_CONFIG文件存在，则将读取其内容并将其显示在此属性中。
        该属性是多值的，以容纳多个配置指令。
        没有提供默认值，但是必须！在此处使用适当的设置以获得最佳的服务器性能。
            对此属性所做的任何更改都将写入 DB_CONFIG 文件中，并将导致数据库环境被重置，因此更改可以立即生效。
            如果数据库环境缓存很大，并且最近未进行检查点检查，则此重置操作可能会花费很长时间。
                建议：：在使用 LDAP Modify 更改此属性之前，建议使用 Berkeley DBdb_checkpoint 实用工具手动执行单个检查点。
        Example:
            olcDbConfig: set_cachesize 0 10485760 0
            olcDbConfig: set_lg_bsize 2097512
            olcDbConfig: set_lg_dir /var/tmp/bdb-log
            olcDbConfig: set_flags DB_LOG_AUTOREMOVE
            在此示例中：
                BDB缓存 设置为 10MB，
                BDB事务日志缓冲区的大小 设置为 2MB，
                并且事务日志文件将存储在/var/tmp/bdb-log 目录中。
                还设置了一个标志，告诉 BDB 一旦其内容已被(检查点)检查过并且不再需要它们，则删除事务日志文件
                    没有此设置，事务日志文件将继续累积，直到其他一些清除过程将其删除为止
        理想情况下，
            BDB缓存 必须至少与数据库的工作集一样大，
            日志缓冲区的大小 应足够大以容纳大多数事务而不会溢出，
            并且日志目录必须独立于主数据库文件的物理磁盘(不在同一个物理磁盘上)。
            并且数据库目录和日志目录都应该与用于常规系统活动(例如root，boot或swap filesystems)的磁盘分开。  
    olcDbNosync: { TRUE | FALSE }
         此选项导致 磁盘数据库内容在更改后不会立即与内存更改同步。
         将此选项设置为 TRUE可能会提高性能，但会牺牲数据完整性。
         该指令与使用下面指令的效果相同
            olcDbConfig: set_flags DB_TXN_NOSYNC     
    olcDbIDLcacheSize: <integer>
        在index slots中指定 内存中索引缓存的大小。
        默认值为零。
        较大的值将加快索引条目的频繁搜索。
            最佳大小取决于数据库的数据和搜索特征，
            但是使用三倍于条目缓存大小(entry cache size)的数字是一个很好的开始。
        Example:
            olcDbIDLcacheSize: 3000
    olcDbIndex: {<attrlist> | default} [pres,eq,approx,sub,none]
        该指令指定 要为给定属性维护的 索引
        如果仅给出<attrlist>，则将保留默认索引。
        索引关键字对应于 可以在 LDAP搜索过滤器 中使用的常见匹配类型。
        Example:
            olcDbIndex: default pres,eq
            olcDbIndex: uid
            olcDbIndex: cn,sn pres,eq,sub
            olcDbIndex: objectClass eq
                在此示例中：
                    第一行设置默认索引集， 以 保持/维护 pres(present 存在)和eq(equality 相等)
                    第二行导致为 uid属性类型 保留/维护 默认的(pres，eq)索引集。
                    第三行导致为 cn和sn属性类型 维护pres，eq和sub(substring 子字符串) 索引
                    第四行导致为 objectClass属性类型 维护eq索引
        没有不等式匹配的索引关键字。
            通常，这些匹配不使用索引。
            但是，某些属性确实支持 基于相等性索引的 不等式匹配的 索引。
        可以将sub(substring index 子字符串索引)更明确地指定为 subinitial，subany 或 subfinal，与子字符串匹配过滤器(substring match filter)的三个可能的组件相对应。
            subinitial(子初始索引)  仅索引出现在属性值开头的子字符串。
            subfinal(子最终索引)    仅索引出现在属性值末尾的子字符串，
            subany(子任何索引)      索引出现在值中任何地方的子字符串。
        注意：
            默认情况下，为属性设置索引也会影响该属性的每个子类型。
            例如，在name属性上设置eq索引会导致 cn，sn 和从name属性继承的所有其他属性 被索引(具有name的同种索引)。
        注意：
            默认情况下，不维护任何索引。
            通常建议在 objectClass 上至少保留一个eq索引(equality index)。
                olcDbindex: objectClass eq
        应根据 数据库上最常用的搜索 配置其他索引.
            不应该为某个属性配置presence indexing，  除非该属性在数据库中很少出现,并且在目录的正常使用过程中对该属性的 presence searches 非常频繁。
            大多数应用程序不使用presence searches，因此通常presence indexing不是很有用。
        如果在 slapd 运行时更改此设置，则将运行内部任务以生成更改的索引数据。
            在索引器执行工作时，所有服务器操作都可以照常继续。
            如果在索引任务完成之前 slapd 已停止，则必须使用 slapindex 工具手动完成索引编制。
    olcDbLinearIndex: { TRUE | FALSE }
        如果设置为：TRUE，
            1. slapindex 将一次索引一个属性。
            2. 将使用整个数据库中的多次遍历分别处理每个索引属性
                当 BDB缓存 小(数据库大小 超过 BDB缓存大小)时，此选项将提高 slapindex 性能。
                当 BDB缓存 足够大时，不需要设置此选项，因为这会降低性能。
            使用此选项，slapadd 不会建立索引，并且必须使用 slapindex。
        默认设置为：FALSE，
            1. 在这种情况下，一个条目的所有索引属性将同时被处理。
            2. slapadd 会执行完全索引，因此不需要单独的 slapindex 运行。
    olcDbMode: { <octal> | <symbolic> }
        该指令指定 新创建的数据库索引文件 应具有的 文件保护模式。
            格式可以是 0600 或-rw------
        Default:
            olcDbMode: 0600            
    olcDbSearchStack: <integer>
        指定 用于 搜索过滤器评估(search filter evaluation) 的堆栈深度。
            搜索过滤器在堆栈上进行评估，以适应嵌套的 AND/OR子句。
            为每个服务器线程分配一个单独的堆栈。
            堆栈的深度决定了 无需任何额外的内存分配即可 评估过滤器的复杂程度。
            嵌套 比搜索堆栈深度 更深的过滤器 将导致为 该特定搜索操作 分配一个单独的堆栈。
                这些单独的分配可能会对服务器性能产生重大负面影响，
                但是指定过多的堆栈也将消耗大量内存。
        每次搜索 
            在32位计算机上每级使用512K字节，
            在64位计算机上每级使用1024K字节。
                单个堆栈的 512KB 大小是由编译时常量设置的，
                如果需要，可以更改此常量。必须重新编译代码才能使更改生效。
        默认堆栈深度为 16，因此在 32 位和 64 位计算机上，每个线程分别使用 8MB 或 16MB
        Default:
            olcDbSearchStack: 16
    olcDbShmKey: <integer>
        指定 共享内存BDB环境(shared memory BDB environment) 的密钥。
            如果指定了非零值，它将被用作标识 将容纳环境的 共享内存区域的键。
        默认情况下,
            BDB环境 使用 内存映射文件(memory mapped files)。
        Example:
            olcDbShmKey: 42

    
    Sample Entry(示例条目)如下：
        -------------
        dn: olcDatabase=hdb,cn=config
        objectClass: olcDatabaseConfig
        objectClass: olcHdbConfig
        olcDatabase: hdb
        olcSuffix: dc=example,dc=com
        olcDbDirectory: /usr/local/var/openldap-data
        olcDbCacheSize: 1000
        olcDbCheckpoint: 1024 10
        olcDbConfig: set_cachesize 0 10485760 0
        olcDbConfig: set_lg_bsize 2097152
        olcDbConfig: set_lg_dir /var/tmp/bdb-log
        olcDbConfig: set_flags DB_LOG_AUTOREMOVE
        olcDbIDLcacheSize: 3000
        olcDbIndex: objectClass eq
        -------------





    --------------------5.3 配置示例(Configuration Example)
    说明：
        以下是示例配置，并在其中插入解释性文字。
        它定义了两个数据库来处理 X.500 树的不同部分；
        都是 BDB 数据库实例。
        显示的行号仅供参考，不包含在实际文件中。
        
    首先，全局配置部分：
        -------------
        1. # example config file - global configuration entry
        2. dn: cn=config
        3. objectClass: olcGlobal
        4. cn: config
        5. olcReferral: ldap://root.openldap.org
        6.
        -------------
                第 1 行是注释。
                第 2-4 行将其标识为全局配置条目。
                第 5 行上的 olcReferral：指令表示，
                    对于以下定义的数据库之一而言  
                    非本地的查询将被引用到 主机root.openldap.org的标准端口(389)上运行的LDAP服务 上。
                第 6 行是空白行，指示该条目的结尾。
        -------------
        7. # internal schema
        8. dn: cn=schema,cn=config
        9. objectClass: olcSchemaConfig
        10. cn: schema
        11.
        -------------
                第 7 行是注释。
                第 8-10 行将其标识为模式子树的根。
                该条目中的实际模式定义被硬编码到slapd 中，因此此处未指定其他属性。
                第 11 行是空白行，指示该条目的结尾。
        -------------
        12. # include the core schema
        13. include: file:///usr/local/etc/openldap/schema/core.ldif
        14.
        -------------
                第 12 行是注释。
                第 13 行是一个LDIF包含指令，
                    访问核心的模式，模式定义为LDIF文件格式。
                第 14 行是空白行。
    接下来是数据库定义。
        第一个数据库是特殊的frontend(前段)数据库，其设置全局应用于所有其他数据库。
        -------------
        15. # global database parameters
        16. dn: olcDatabase=frontend,cn=config
        17. objectClass: olcDatabaseConfig
        18. olcDatabase: frontend
        19. olcAccess: to * by * read
        20.
        -------------
                第 15 行是注释。
                第 16-18 行将这个条目标识为全局数据库条目。
                第 19 行是全局访问控制。
                    它适用于所有条目(在任何适用的 数据库特定的 访问控制之后)。
                第 20 行是空白行。
    下一个条目定义配置后端。
        -------------
        21. # set a rootpw for the config database so we can bind.
        22. # deny access to everyone else.
        23. dn: olcDatabase=config,cn=config
        24. objectClass: olcDatabaseConfig
        25. olcDatabase: config
        26. olcRootPW: {SSHA}XKYnrjvGT3wZFQrDD5040US592LxsdLy
        27. olcAccess: to * by * none
        28.
        -------------
                第 21-22 行是注释。
                第 23-25 行将此条目标识为config database(配置数据库)条目。
                第 26 行定义了此数据库的超级用户密码。(DN 默认为“cn=config”。)
                第 27 行拒绝对该数据库的所有访问，因此只有超级用户才能访问它。
                    (这已经是 config数据库上的默认访问权限。
                    这里仅列出来进行说明，并重申，
                    除非显式配置了作为超级用户进行身份验证的方法，
                    否则将无法访问config 数据库。)
                第 28 行是空白行。
    下一个条目定义一个 BDB 后端，
        该后端将处理 对 树的“dc=example，dc=com”部分 中的内容的查询。
        将为几个属性维护索引，并保护 userPassword属性 免受未经授权的访问。
        -------------
        29.    # BDB definition for example.com
        30.    dn: olcDatabase=bdb,cn=config
        31.    objectClass: olcDatabaseConfig
        32.    objectClass: olcBdbConfig
        33.    olcDatabase: bdb
        34.    olcSuffix: dc=example,dc=com
        35.    olcDbDirectory: /usr/local/var/openldap-data
        36.    olcRootDN: cn=Manager,dc=example,dc=com
        37.    olcRootPW: secret
        38.    olcDbIndex: uid pres,eq
        39.    olcDbIndex: cn,sn pres,eq,approx,sub
        40.    olcDbIndex: objectClass eq
        41.    olcAccess: to attrs=userPassword
        42.      by self write
        43.      by anonymous auth
        44.      by dn.base="cn=Admin,dc=example,dc=com" write
        45.      by * none
        46.    olcAccess: to *
        47.      by self write
        48.      by dn.base="cn=Admin,dc=example,dc=com" write
        49.      by * read
        50.
        -------------
                第 29 行是注释。
                第 30-33 行将该条目标识为 BDB数据库 配置条目。
                第 34 行指定了要传递给该数据库进行查询的 DN后缀。
                第 35 行指定数据库文件所在的目录。
                第 36 和 37 行标识数据库超级用户和相关密码。该条目不受访问控制，大小，时间限制的限制。
                第 38 行到第 40 行表示要为各种属性维护的索引。
                第 41 至 49 行指定了对该数据库中条目的访问控制。
                    对于所有适用的条目，
                            userPassword属性可由条目本身和“admin”条目 改写。
                                它可以用于身份验证/授权目的，否则不可读(即不允许匿名用户读)。
                            其他属性
                                该条目和“admin”条目均可以写入所有其他属性，
                                所有其他用户(已认证或未认证)都可以读取所有其他属性。
                第 50 行是空白行，指示该条目的结尾。
    下一个条目定义另一个 BDB 数据库。
        该查询处理涉及dc=example，dc=net子树，
            但由 与第一个数据库相同的实体 管理。
        注意：如果没有第60行的话，由于第 19 行的全局访问规则，将允许所有读访问。
        -------------
        51.    # BDB definition for example.net
        52.    dn: olcDatabase=bdb,cn=config
        53.    objectClass: olcDatabaseConfig
        54.    objectClass: olcBdbConfig
        55.    olcDatabase: bdb
        56.    olcSuffix: dc=example,dc=net
        57.    olcDbDirectory: /usr/local/var/openldap-data-net
        58.    olcRootDN: cn=Manager,dc=example,dc=com
        59.    olcDbIndex: objectClass eq
        60.    olcAccess: to * by users read
        -------------





    --------------------5.4 将老的slapd.conf配置文件转换为cn=config格式(Converting old style slapd.conf(5) file to cn=config format)
    前提：
        配置好config backend的rootDN和rootPW，因为默认是无法访问的
    
    如果你还未准备好拥有一个database config section，那么在slapd.conf文件的末尾添加如下内容
        database config
        rootpw VerySecret

    注意：由于 config后端 可将任意代码加载到slapd进程中，
            因此 警惕谁可以访问它 非常重要。
        由于简单密码容易受到密码猜测攻击的而变得脆弱，
            因此最好省略rootpw，
            仅配置 rootDN ，并使用 SASL 进行身份验证。
        
        #转换
        slaptest -f /usr/local/etc/openldap/slapd.conf -F /usr/local/etc/openldap/slapd.d
        #验证
        ldapsearch -x -D cn=config -w VerySecret -b cn=config
        然后您可以丢弃旧的 slapd.conf文件

        注意：从slapd.conf文件转换为slapd.d格式时，包含的所有文件也将集成到生成的配置数据库中。



    --------------------chapter 6 slapd.conf配置文件(了解 ，算是对前一章所学的回顾)
    slapd.conf文件已经被废弃
        除非你的站点 仅仅只需要一个后端 并且你的站点没有更新(无法运行最新的slapd-config系统)
        通常存在于 /usr/local/etc/openldap目录下 ，可以通过slapd的命令行指定文件路径
    slapd.conf文件  
        包含三种类型的配置信息：全局，特定于后端，特定于数据库
            首先指定全局信息，然后指定特定于后端类型的信息，然后指定特定于数据库实例的信息
            全局指令可以被后端指令/数据库指令覆盖 ， 后端指令可以被数据库指令覆盖
        空行和注释(以'#'开头)被忽略；
        若某行以空格开头，则此行是前一行的延续。
    slapd.conf文件的一般格式如下：
        -------------
        # global configuration directives
        <global config directives>

        # backend definition
        backend <typeA>
        <backend-specific directives>

        # first database definition & config directives
        database <typeA>
        <database-specific directives>

        # second database definition & config directives
        database <typeB>
        <database-specific directives>

        # second database definition & config directives
        database <typeA>
        <database-specific directives>

        # subsequent backend & database definitions & config directives
        ...
        -------------
                配置指令可以携带参数，以空格隔开
                    如果参数包含空格，则应该将参数用双引号括起来
                    如果参数包含双引号和反斜杠，则应该在字符前加上反斜杠
                发行版
                    携带了一个示例配置文件在/usr/local/etc/openldap 目录中
                    提供了很多包含模式定义的文件在/usr/local/etc/openldap/schema 目录中
    详细介绍常用的配置文件指令，完整列表参看第5章
        本节将配置文件指令分为全局，特定于后端和特定于数据的，描述每个指令及其默认值(如果有)，并给出其用法示例。
        全局指令
            本节中的指令适用于所有后端和数据库，除非在后端或数据库定义中明确覆盖了这些指令，应由实际文本替换 <>
            access to <what> [ by <who> [<accesslevel>] [<control>] ]+
                该指令允许一个或多个请求者(由<who>指定)对一组条目和/或属性(由<what>指定)的访问权限(由<accesslevel>指定)。
                和 olcAccess: to <what> [ by <who> [<accesslevel>] [<control>] ]+ 功能相同，不再赘述
                详见第8章access control
            attributetype <RFC4512 Attribute Type Description>
                该指令定义属性类型
                和olcAttributeTypes: <RFC4512 Attribute Type Description>功能相同，不再赘述
            idletimeout <integer>
                强制关闭空闲的客户端连接之前要等待的秒数，默认情况下，为 0 将禁用此功能。
                和olcIdleTimeout: <integer>功能相同，不再赘述
            include <filename>
                该指令指定 slapd 在继续当前文件的下一行之前，应从给定文件中读取其他配置信息。
                    包含的文件应遵循正常的 slapd 配置文件格式。
                    注意：使用此指令时要小心-嵌套 include 指令的数量没有限制，并且不会执行循环检测。
            loglevel <level>
                指定 调试语句 和 操作统计信息 应进行 syslog 的级别(当前记录到 syslogd(8)LOG_LOCAL4 设备)。
                和olcLogLevel: <level>功能相同，不再赘述
            objectclass <RFC4512 Object Class Description>
                该指令定义了一个对象类
                和olcObjectClasses: <RFC4512 Object Class Description>功能相同，不再赘述
            referral <URI>
                当 slapd 找不到本地数据库来处理请求时，指定要传回的引用
                如  olcReferral: ldap://root.openldap.org
                和olcReferral: <URI>功能相同，不再赘述
            sizelimit <integer>
                该指令指定 从搜索操作返回的最大条目数
                和olcSizeLimit: <integer>功能相同，不再赘述
            timelimit <integer>
                和[olcTimeLimit: <integer>]功能相同，不再赘述
                该指令指定了 slapd 响应搜索请求所花费的最大秒数(实时)。如果请求在此时间内未完成，则将返回: 指示超出时间限制的结果。
        一般后端指令
            本节中的指令仅适用于定义它们的后端。
                每种类型的后端都支持它们
                后端指令适用于相同类型的所有数据库实例，并且数据库指令可能会覆盖后端指令
            backend <type>
                该指令标志着后端声明的开始。 
                <type>应该为后端类型之一
                和olcBackend: <type> 功能相同，不再赘述 
        一般数据库指令
            本节中的指令仅适用于定义它们的数据库。
                每种类型的数据库都支持它们。
            database <type>
                该指令标志着数据库实例声明的开始
                和olcDatabase: [{<index>}]<type>功能相同，不再赘述
            limits <selector> <limit> [<limit> [...]]
                根据操作的发起者或基本 DN 指定时间和大小限制。
            readonly { on | off }
                该指令将数据库置于“只读”模式。任何修改数据库的尝试都将返回“不愿执行”错误。
                如果在consumer上设置，则仍然会发生由 syncrepl 发送的修改
                和olcReadonly { TRUE | FALSE }功能相同，不再赘述
            rootdn <DN>
                指定管理员DN; 此DN对数据库的操作将不受限制
                和olcRootDN: <DN>功能相同，不再赘述
            rootpw <password>
                为olcRootDN: <DN>的DN指定密码
                和olcRootPW: <password>功能相同，不再赘述
            suffix <dn suffix>
                该指令指定 传递到此后端数据库执行查询的 DN 后缀。
                和olcSuffix: <dn suffix>功能相同，不再赘述
            syncrepl
                该指令
                    将当前slapd(8)建立为 复制consumer站点  通过运行syncrepl复制引擎，从而将当前数据库指定为 内容提供者 的consumer。
                    consumer数据库 和 provider的最新内容保持同步
                和olcSyncrepl功能相同，不再赘述
            updateref <URL>
                仅适用于副本(或 shadow) slapd(8)实例.
                用于指定 要返回给客户端的URL , 客户端将在副本上提交更新请求
                和olcUpdateref: <URL>功能相同，不再赘述
        BDB 和 HDB 数据库指令
            directory <directory>
                指定 包含数据库和相关索引的 BDB文件所在的目录
                和olcDbDirectory: <directory>功能相同，不再赘述
    slapd.conf配置文件示例
        首先，全局配置部分：
        -------------
        1.    # example config file - global configuration section
        2.    include /usr/local/etc/schema/core.schema
        3.    referral ldap://root.openldap.org
        4.    access to * by * read
        -------------
                第 1 行是注释。
                第 2 行包含另一个包含核心模式定义的配置文件。
                第 3 行上的“referral”意味着，以下定义的数据库之一 不在本地的查询 则转到root.openldap.org 的标准端口(389)上运行的 LDAP 服务中。
                第 4 行是全局访问控制。它适用于所有条目(在任何适用的数据库特定的访问控制之后)。
        下一部分定义了一个 BDB 后端，该后端将处理对树的“dc=example，dc=com”部分中内容的查询。
            该数据库将被复制到两个副本 slapd 中，一个在 truelies，另一个在judgmentday。
            将为几个属性维护索引，并保护 userPassword 属性免受未经授权的访问。            
        -------------
        5.    # BDB definition for the example.com
        6.    database bdb
        7.    suffix "dc=example,dc=com"
        8.    directory /usr/local/var/openldap-data
        9.    rootdn "cn=Manager,dc=example,dc=com"
        10.    rootpw secret
        11.    # indexed attribute definitions
        12.    index uid pres,eq
        13.    index cn,sn pres,eq,approx,sub
        14.    index objectClass eq
        15.    # database access control definitions
        16.    access to attrs=userPassword
        17.        by self write
        18.        by anonymous auth
        19.        by dn.base="cn=Admin,dc=example,dc=com" write
        20.        by * none
        21.    access to *
        22.        by self write
        23.        by dn.base="cn=Admin,dc=example,dc=com" write
        24.        by * read
        -------------
                第 5 行是注释。
                第 6 行上的 database 关键字标记了数据库定义的开始。
                第 7 行指定了将查询传递到此数据库的 DN 后缀。
                第 8 行指定数据库文件所在的目录。
                第 9 和 10 行标识数据库超级用户和相关密码。该条目不受访问控制或大小或时间限制的限制。
                第 12 到 14 行表示各种属性要维护的索引。
                第 16 至 24 行指定对此数据库中条目的访问控制。
                    对于所有适用的条目，
                        userPassword 属性
                            可由条目本身和“admin”条目写入。用于身份验证/授权目的，验证不通过则不可读。
                        其他属性
                            该条目和“admin”条目均可以写入所有其他属性，所有用户(已认证或未认证)都可以读取所有其他属性。
        下一部分定义了另一个 BDB 数据库。
            该查询处理涉及 dc=example,dc=net子树的查询，但由与第一个数据库相同的实体管理。
            请注意，如果没有第 39 行，则由于第4 行有全局访问规则，因此将允许读访问。
        -------------
        33.    # BDB definition for example.net
        34.    database bdb
        35.    suffix "dc=example,dc=net"
        36.    directory /usr/local/var/openldap-data-net
        37.    rootdn "cn=Manager,dc=example,dc=com"
        38.    index objectClass eq
        39.    access to * by users read
        -------------



    --------------------chapter 7 运行 slapd配置文件(Running slapd)
    slapd(8)作为一个独立服务运行。
        这使服务器可以利用缓存的优势，管理基础数据库的并发问题，并节省系统资源。
    slapd(8)支持许多命令行选项，如手册页中所述。本节详细介绍了一些常用选项。
        -f <filename>
            为slapd 指定备用配置文件
            默认为/usr/local/etc/openldap/slapd.conf
        -F <slapd-config-directory>
            指定 slapd配置目录
            默认为/usr/local/etc/openldap/slapd.d/
                    如果同时指定了-f 和-F，则将读取配置文件 并将其转换为配置目录格式 并写入指定的目录。
                    如果未指定任何选项，则 slapd 将在尝试使用默认配置文件之前尝试读取默认配置目录。
                    如果存在有效的配置目录，则默认配置文件将被忽略。
        -h <URLs>
            此选项指定替代的侦听器配置。
                默认值为 ldap:///，这意味着默认 LDAP389端口 的所有接口上使用 基于TCP的LDAP。
                您可以指定特定的host-pair对或其他协议方案(例如 ldaps://或ldapi://)。
                        URL         Protocol        Transport
                        ldap:///    LDAP            TCP port 389
                        ldaps:///   LDAP over SSL   TCP port 636
                        ldapi:///   LDAP            IPC (Unix-domain socket)
                例如，-h "ldaps:// ldap://127.0.0.1:666" 将创建两个侦听器：
                    一个侦听器用于ldaps://默认的636端口上所有接口上的(非标准)ldaps://方案，
                    另一个是在666端口上的localhost(环回)接口上用于标准 ldap://方案。
                    可以使用主机名或 IPv4 或 IPv6 地址来指定主机。端口值必须是数字。
                对于基于IPC的LDAP，可以在URL中编码 Unix 域套接字的路径名。
                    请注意，目录分隔符必须像其他任何专用于URL的字符一样，都经过 URL 编码。
                    因此套接字/usr/local/var/ldapi必须被编码为 ldapi://%2Fusr%2Flocal%2Fvar%2Fldapi
                        请注意：
                            ldapi:///传输并未得到广泛实现：非 OpenLDAP 客户端可能无法使用它。
        -n <service-name>
            此选项指定用于日志记录和其他目的的服务名称。
                默认服务名称为 slapd
        -l <syslog-local-user>
            指定 syslog(8)工具的本地用户。
                值可以是 LOCAL0，LOCAL1，LOCAL2，...和 LOCAL7。
                默认值为 LOCAL4。
                并非所有系统都支持此选项。
        -u user -g group
            分别指定 用户和组 以其身份运行。
                用户可以是 用户名或uid。
                组可以是 组名或gid。
        -r directory
            指定运行时目录。
                在打开侦听器之后，但在读取任何配置文件或初始化任何后端之前，slapd 会将 chroot(2)切换到该目录。
        -d <level> | ?
            项将 slapd 调试级别设置为<level>
                级别为"?"时字符，将打印各种调试级别，并退出slapd
                    在上面的  olcLogLevel: <level>  下 有个调试级别表
                注意：
                    调试级别可叠加
                注意：
                    slapd 必须已经使用--enable-debug 进行编译
    启动 slapd
        slapd 的运行方式如下：/usr/local/libexec/slapd [<option>]*
                我的slapd目录
                    [root@localhost openldap]# find / -name "slapd"
                    /etc/sysconfig/slapd
                    /usr/sbin/slapd
            其中/usr/local/libexec 由 configure 确定，而<option>是上述选项之一
            除非您指定了调试级别(包括级别 0)，否则 slapd 会自动从其控制终端ffork and detach，并在后台运行。
    停止 slapd 
        为了安全地杀死 Slapd(8)，你应该
            kill -INT `cat /usr/local/var/slapd.pid`  
                    我的目录是
                        [root@localhost openldap]# find / -name "slapd.pid"
                        /run/openldap/slapd.pid
                其中/usr/local/var 由配置决定
                用更粗暴的方法杀死 slapd 可能会导致信息丢失或数据库损坏。




    --------------------chapter 8. 访问控制(Access Control)
    随着越来越多的 具有不同敏感度的数据 填充目录，控制 对目录各种各样的访问权限 变得越来越重要。
        例如，目录可能包含 您需要通过合同或法律保护的机密性质的数据。
        或者，如果使用目录控制对其他服务的访问，
            则 对该目录的不适当访问可能会为您的站点安全性创建攻击途径，从而严重破坏您的资产。
        可通过两种方法配置对目录的访问，
            一种使用 slapd 配置文件，
            另一种使用 slapd-config(5)格式(配置 slapd)。
        默认的访问控制策略是允许所有客户端读取。
            无论定义了什么访问控制策略，rootdn拥有对所有内容的全部权限(即：身份验证，搜索，比较，读取和写入)。
                因此，列出rootdn的权限是没有用的(并导致性能下降)
                
    以下各节将更深入地描述访问控制列表，并给出一些示例和建议。有关完整的详细信息，请参见 slapd.access(5)
    8.2. 通过静态配置做访问控制
        对条目和属性的访问由 访问配置文件指令(access configuration file directive) 控制。通用的访问语句形式为：
                -----------------------------------
                <access directive> ::= access to <what>
                    [by <who> [<access>] [<control>] ]+
                <what> ::= * |
                    [dn[.<basic-style>]=<regex> | dn.<scope-style>=<DN>]
                    [filter=<ldapfilter>] [attrs=<attrlist>]
                <basic-style> ::= regex | exact
                <scope-style> ::= base | one | subtree | children
                <attrlist> ::= <attr> [val[.<basic-style>]=<regex>] | <attr> , <attrlist>
                <attr> ::= <attrname> | entry | children
                <who> ::= * | [anonymous | users | self
                        | dn[.<basic-style>]=<regex> | dn.<scope-style>=<DN>]
                    [dnattr=<attrname>]
                    [group[/<objectclass>[/<attrname>][.<basic-style>]]=<regex>]
                    [peername[.<basic-style>]=<regex>]
                    [sockname[.<basic-style>]=<regex>]
                    [domain[.<basic-style>]=<regex>]
                    [sockurl[.<basic-style>]=<regex>]
                    [set=<setspec>]
                    [aci=<attrname>]
                <access> ::= [self]{<level>|<priv>}
                <level> ::= none | disclose | auth | compare | search | read | write | manage
                <priv> ::= {=|+|-}{m|w|r|s|c|x|d|0}+
                <control> ::= [stop | continue | break]
                -----------------------------------
                        <what>部分选择   要应用访问权限的 条目和/或属性，
                        <who>部分指定    给哪些实体 授予访问权限，
                        <access>部分指定 授予访问权限。
                        支持多个<who> <access> <control>三元组，从而允许 向许多实体授予 对同一组条目和属性的 不同访问权限。
                        此处未描述所有这些访问控制选项；有关更多详细信息，请参见 slapd.access(5)手册页。
        8.2.1 访问权限控制哪些内容(What to control access to)
            <what>部分确定 把访问控制应用到哪些 条目和属性上。
                通常以两种方式选择条目：
                    通过DN 和通过filter(过滤器)。
                可以同时使用DN和filter
            -----------------------------------
                以下限定符按 DN 选择条目：
                    -----------------------------------
                    to *
                    to dn[.<basic-style>]=<regex>
                    to dn.<scope-style>=<DN>
                    -----------------------------------
                            第一种形式用于   选择 所有 条目。
                            第二种形式用于   通过 正则表达式与条目的DN进行匹配 来选择 条目。
                            第三种形式用于   选择 DN请求范围内的 条目。
                                范围可以是 base，one，subtree 或 children。
                                base     仅匹配 具有DN的条目(仅仅DN一个)，
                                one        匹配 其父代是 DN 的条目(这个DN的第一代儿子)，
                                subtree    匹配 子树中(树的根是DN)的所有条目(DN + 这个DN的所有儿子和后代)，
                                children   匹配 DN 下的所有条目(这个DN的所有儿子和后代，但不匹配DN自己)。
                                    例如
                                    -----------------------------------
                                    0: o=suffix
                                    1: cn=Manager,o=suffix
                                    2: ou=people,o=suffix
                                    3: uid=kdz,ou=people,o=suffix
                                    4: cn=addresses,uid=kdz,ou=people,o=suffix
                                    5: uid=hyc,ou=people,o=suffix
                                    -----------------------------------
                                    则
                                    -----------------------------------
                                    dn.base="ou=people,o=suffix" match 2;
                                    dn.one="ou=people,o=suffix" match 3, and 5;
                                    dn.subtree="ou=people,o=suffix" match 2, 3, 4, and 5; 
                                    dn.children="ou=people,o=suffix" match 3, 4, and 5.
                                    -----------------------------------
                使用filter(过滤器)选择条目
                    to filter=<ldap filter>
                        <ldap filter>是字符串，例如： to filter=(objectClass=person)
                在<what>字句中可以同时使用DN和filter 来选择条目
                    to dn.one="ou=people,o=suffix" filter=(objectClass=person)
            -----------------------------------
                attrs=<attribute list>
                    包含 逗号分隔的 属性名称列表 来选择条目中的属性
                attrs=<attribute> val[.<style>]=<regex>
                    使用 单个属性名称以及值选择器 来选择属性的特定值
                有两个特殊的伪属性项和子项。
                    要读取(并返回)目标条目，必须具有对目标条目属性的读取权限。
                    要执行搜索，必须对搜索库的条目属性具有搜索权限。
                    要添加或删除条目，必须对条目的条目属性具有写权限，并且必须对条目的父级子属性具有写权限。
                    要重命名条目，必须对条目的条目属性具有写权限，并且对旧父和新父的子属性都具有写权限。
                    本节末尾的完整示例应有助于解决问题。
                有一个特殊的条目选择器"*"
                    用于选择任何条目。
                    未提供<what>时使用 等效于"dn=.*"
        8.2.2. 赋予谁访问权限(Who to grant access to)
            <who> 标识 被授予访问权限的 一个或多个实体。
                注意：访问权限被授予“实体”而不是“条目”。
                -----------------------------------
                        able 6.3: Access Entity Specifiers(表 6.3: 访问权限实体说明符)
                Specifier	                Entities                
                *	                        All, including anonymous and authenticated users    所有用户，包括匿名用户和认证用户
                anonymous	                Anonymous (non-authenticated) users                 匿名(未认证)用户
                users	                    Authenticated users                                 通过身份验证的用户
                self	                    User associated with target entry                   与目标条目关联的用户
                dn[.<basic-style>]=<regex>	Users matching a regular expression                 匹配正则表达式的用户
                dn.<scope-style>=<DN>	    Users within scope of a DN                          一个DN范围内的用户
                -----------------------------------
                    此处DN和<what>字句中的DN 行为非常相似
                    还支持其他控制因素。
                        例如：
                            <who>可以被DN-valued属性中列出的条目所限制:
                                dnattr=<dn-valued attribute name>
                                dnattr用于对 条目的属性中列出了DN的条目 授予访问权限   ？？？？？？？？？？？？？没看懂！！！
                                    例如： 向 被列为组条目的所有者的任何人授予对组条目的访问权限
                    有些因素可能并不适合所有环境(或任何环境)     
                        例如，
                            域因子(domain factor)依赖于 IP 到域名的查找。
                            由于这些很容易被欺骗，因此应避免使用域因子。           
        8.2.3. 赋予哪些访问权限(The access to grant)
            <access>
                -----------------------------------
                    Table 6.4: Access Levels(表 6.4: 访问级别)
                Level           Privileges Description
                none =         0 no access
                disclose =     d needed for information disclosure on error
                auth =        dx needed to authenticate (bind)
                compare =    cdx needed to compare
                search =    scdx needed to apply search filters
                read =     rscdx needed to read search results
                write =   wrscdx needed to modify/rename
                manage = mwrscdx needed to manage
                -----------------------------------
                        每个级别都意味着所有较低级别的访问权限会被同时赋予。
                            例如，授予某人对某项的 写访问权限 也将授予他们读，搜索，比较，身份验证和公开访问权限。
                            但是，可以使用权限说明符来授予特定权限。
        8.2.4. 访问控制评估(Access Control Evaluation)
            --------先比较<what>
            在评估是否应授予 某些请求者 访问条目和/或属性的权限时，
                slapd将 条目和/或属性 与 配置文件中给出的<what> selectors进行比较。
            
            对于每个条目，首先应用 保存该条目的数据库中提供的访问控制(如果没有保存在任何数据库中，则应用全局访问控制)，
            然后应用全局访问指令。
                概述：对于每个条目 先应用数据库中存储的该条目的访问控制，然后应用全局的访问控制
                
            但是，在处理访问列表时，由于全局访问列表被有效地附加到每个数据库列表中，
            因此如果结果列表为非空列表，则访问列表隐式的以 access to * by * none 指令结尾。
            
            如果没有适用于后端的访问指令，则使用默认读取。
            
            (在此优先级内)按访问指令在配置文件中出现的顺序 对其进行检查。
                Slapd停在与 条目和/或属性 匹配的第一个<what> selector上。
                相应的访问指令是 一个slapd 将用来评估访问的指令。
            
            --------然后比较<who>
            接下来，slapd 按照请求出现的顺序比较 请求访问 上面选择的访问指令 的<who> selectors的实体。
            它停在 与请求者匹配的第一个<who> selector上。
                这确定了请求访问的实体 对条目和/或属性的 访问权。

            --------最后比较<who>
            最后，slapd 将所选<access>条款中授予的访问权限与客户端请求的访问权限进行比较。
                如果允许更大或相等的访问权限，则授予访问权限。
                否则，访问将被拒绝
                
            --------指令的顺序非常重要
            访问指令的评估顺序使其在配置文件中的位置很重要。
                如果就其选择的条目而言，
                    一个访问指令比另一个访问指令更具体，则它应该"首先"出现在配置文件中。
                同样，
                    如果一个<who>选择器比另一个选择器更具体，则应在访问指令中排在第一位。
                下面给出的访问控制示例应有助于使这一点变得清楚。

        8.2.5. 访问控制示例(Access Control Examples)
            
            -----------------------------------
            access to * by * read
            -----------------------------------
                    此访问指令 向所有人授予读取访问权限。
            
            -----------------------------------
            access to *
                by self write
                by anonymous auth
                by * read
            -----------------------------------
                    该指令 
                        允许用户修改其条目，
                        允许匿名者针对这些条目进行身份验证，
                        并允许所有其他人读取这些条目(其实只有验证并通过的user能read，因为禁止了匿名访问)。
                    请注意，只有第一个符合条件的<who>条款适用。
                        因此，匿名用户被授予身份验证，而不是读取权限。
                    最后一个子句也可以是“by users read”。
            
            -----------------------------------
            access to *
                by ssf=128 self write
                by ssf=64 anonymous auth
                by ssf=64 users read
            -----------------------------------
                    根据适当的保护级别来限制操作。示例显示了如何使用安全强度因子(SSF)。
                        如果已建立强度为 128 或更高的安全保护，则此指令允许用户修改自己的条目；
                        允许匿名用户进行身份验证访问；
                        在已建立 64 或更高的安全保护时，则可以进行读取访问。
                        如果客户端没有建立足够的安全保护，则将应用隐式的 by * none 条款。
            
            下面的示例显示了如何使用 样式说明符 在两个"顺序很重要!!!"的访问指令中 按DN选择条目
            -----------------------------------
            access to dn.children="dc=example,dc=com"
                by * search
            access to dn.children="dc=com"
                by * read
            -----------------------------------
                    dc=example,dc=com子树下的条目 被赋予"搜索"权限
                    dc=com子树下的条目 被授予"读取"权限； 
                        但dc=example,dc=com子树下的条目没有读取权限
                    dc=com，没有被赋予权限，因为这两个指令均与DN不匹配
                注意：
                    如果这些访问控制指令的顺序颠倒了，
                    那么将永远不会执行位于后面的指令语句，因为dc=example,dc=com下的条目也都在dc=com下
                注意：
                    如果 无法访问指令匹配项 或 <who>子句无法访问，则拒绝访问
                    也就是说，对指令的每次访问均以 by * none 子句结尾。
                    
            在处理访问列表时，由于全局访问列表已有效地加到每个数据库列表中，
                因此如果结果列表为非空列表，则访问列表将以隐式的 access to* by * none 结尾。
            
            如果没有适用于后端的访问指令，则使用默认读取。


            下一个示例再次显示了排序的重要性，无论是访问指令还是 by <who>子句。
                它还显示了如何使用 属性选择器 来授予对 特定属性和各种<who>选择器 的访问权限。
            -----------------------------------
                access to dn.subtree="dc=example,dc=com" attrs=homePhone
                    by self write
                    by dn.children="dc=example,dc=com" search
                    by peername.regex=IP=10\..+ read
                access to dn.subtree="dc=example,dc=com"
                    by self write
                    by dn.children="dc=example,dc=com" search
                    by anonymous auth
            -----------------------------------
                    本示例适用于“dc=example,dc=com”子树中的所有条目的所有属性，除了homePhone属性。

                        条目可以写入自身，
                        example.com 条目下的条目可以进行搜索，
                        除了身份验证/授权(始终以匿名方式进行)之外，其他任何人都没有访问权限(暗含 by * none)。

                        homePhone属性可由该条目写入，
                        可由 example.com 下的条目搜索，
                        可由网络 10 连接的客户端可读，否则不可读(隐含 by * none)。
                    
                    所有其他访问都被 access to * by * none 的隐式访问所拒绝。


            有时允许特定的 DN 在属性中添加或删除自身很有用。
                例如，如果您想创建一个组并允许人们从 member 属性中添加和删除他们自己的 DN，
                则可以使用如下访问指令来完成此操作：
            -----------------------------------
            access to attrs=member,entry
                by dnattr=member selfwrite   ？？？？？？？？？？？？？没看懂！！！
            -----------------------------------
                    dnattr <who> selector 表示该访问权限 适用于成员属性中列出的条目。
                    selfwrite access selector表示此类成员只能从属性中添加或删除自己的 DN，而不能从其他值中添加或删除它们。
                    需要添加条目属性，因为需要访问条目才能访问任何条目的属性。

            -----------------------------------

    8.3. 通过动态配置做访问控制(Access Control via Dynamic Configuration)
        对 slapd 条目和属性的访问由 olcAccess属性控制，
            该属性的值是访问指令的序列。
            olcAccess 配置的一般形式为：
            -----------------------------------
            olcAccess: <access directive>
            <access directive> ::= to <what>
                [by <who> [<access>] [<control>] ]+
            <what> ::= * |
                [dn[.<basic-style>]=<regex> | dn.<scope-style>=<DN>]
                [filter=<ldapfilter>] [attrs=<attrlist>]
            <basic-style> ::= regex | exact
            <scope-style> ::= base | one | subtree | children
            <attrlist> ::= <attr> [val[.<basic-style>]=<regex>] | <attr> , <attrlist>
            <attr> ::= <attrname> | entry | children
            <who> ::= * | [anonymous | users | self
                    | dn[.<basic-style>]=<regex> | dn.<scope-style>=<DN>]
                [dnattr=<attrname>]
                [group[/<objectclass>[/<attrname>][.<basic-style>]]=<regex>]
                [peername[.<basic-style>]=<regex>]
                [sockname[.<basic-style>]=<regex>]
                [domain[.<basic-style>]=<regex>]
                [sockurl[.<basic-style>]=<regex>]
                [set=<setspec>]
                [aci=<attrname>]
            <access> ::= [self]{<level>|<priv>}
            <level> ::= none | disclose | auth | compare | search | read | write | manage
            <priv> ::= {=|+|-}{m|w|r|s|c|x|d|0}+
            <control> ::= [stop | continue | break]
            -----------------------------------
                    <what>部分选择   要应用访问权限的 条目和/或属性，
                    <who>部分指定    给哪些实体 授予访问权限，
                    <access>部分指定 授予访问权限。
                    支持多个<who> <access> <control>三元组，从而允许 向许多实体授予 对同一组条目和属性的 不同访问权限。
                    此处未描述所有这些访问控制选项；有关更多详细信息，请参见 slapd.access(5)手册页。
        8.3.1 访问权限控制哪些内容(What to control access to)
            <what>部分确定 把访问控制应用到哪些 条目和属性上。
                通常以两种方式选择条目：
                    通过DN 和通过filter(过滤器)。
                可以同时使用DN和filter
            -----------------------------------
                以下限定符按 DN 选择条目：
                    -----------------------------------
                    to *
                    to dn[.<basic-style>]=<regex>
                    to dn.<scope-style>=<DN>
                    -----------------------------------
                            第一种形式用于   选择 所有 条目。
                            第二种形式用于   通过 正则表达式与条目的DN进行匹配 来选择 条目。
                            第三种形式用于   选择 DN请求范围内的 条目。
                                范围可以是 base，one，subtree 或 children。
                                base     仅匹配 具有DN的条目(仅仅DN一个)，
                                one        匹配 其父代是 DN 的条目(这个DN的第一代儿子)，
                                subtree    匹配 子树中(树的根是DN)的所有条目(DN + 这个DN的所有儿子和后代)，
                                children   匹配 DN 下的所有条目(这个DN的所有儿子和后代，但不匹配DN自己)。
                                    例如
                                    -----------------------------------
                                    0: o=suffix
                                    1: cn=Manager,o=suffix
                                    2: ou=people,o=suffix
                                    3: uid=kdz,ou=people,o=suffix
                                    4: cn=addresses,uid=kdz,ou=people,o=suffix
                                    5: uid=hyc,ou=people,o=suffix
                                    -----------------------------------
                                    则
                                    -----------------------------------
                                    dn.base="ou=people,o=suffix" match 2;
                                    dn.one="ou=people,o=suffix" match 3, and 5;
                                    dn.subtree="ou=people,o=suffix" match 2, 3, 4, and 5; 
                                    dn.children="ou=people,o=suffix" match 3, 4, and 5.
                                    -----------------------------------
                使用filter(过滤器)选择条目
                    to filter=<ldap filter>
                        <ldap filter>是字符串，例如： to filter=(objectClass=person)
                在<what>字句中可以同时使用DN和filter 来选择条目
                    to dn.one="ou=people,o=suffix" filter=(objectClass=person)
            -----------------------------------
                attrs=<attribute list>
                    包含 逗号分隔的 属性名称列表 来选择条目中的属性
                attrs=<attribute> val[.<style>]=<regex>
                    使用 单个属性名称以及值选择器 来选择属性的特定值
                有两个特殊的伪属性项和子项。
                    要读取(并返回)目标条目，必须具有对目标条目属性的读取权限。
                    要执行搜索，必须对搜索库的条目属性具有搜索权限。
                    要添加或删除条目，必须对条目的条目属性具有写权限，并且必须对条目的父级子属性具有写权限。
                    要重命名条目，必须对条目的条目属性具有写权限，并且对旧父和新父的子属性都具有写权限。
                    本节末尾的完整示例应有助于解决问题。
                有一个特殊的条目选择器"*"
                    用于选择任何条目。
                    未提供<what>时使用 等效于"dn=.*"
        8.3.2. 赋予谁访问权限(Who to grant access to)
            <who> 标识 被授予访问权限的 一个或多个实体。
                注意：访问权限被授予“实体”而不是“条目”。
                -----------------------------------
                        able 6.3: Access Entity Specifiers(表 6.3: 访问权限实体说明符)
                Specifier	                Entities                
                *	                        All, including anonymous and authenticated users    所有用户，包括匿名用户和认证用户
                anonymous	                Anonymous (non-authenticated) users                 匿名(未认证)用户
                users	                    Authenticated users                                 通过身份验证的用户
                self	                    User associated with target entry                   与目标条目关联的用户
                dn[.<basic-style>]=<regex>	Users matching a regular expression                 匹配正则表达式的用户
                dn.<scope-style>=<DN>	    Users within scope of a DN                          一个DN范围内的用户
                -----------------------------------
                    此处DN和<what>字句中的DN 行为非常相似
                    还支持其他控制因素。
                        例如：
                            <who>可以被DN-valued属性中列出的条目所限制:
                                dnattr=<dn-valued attribute name>
                                dnattr用于对 条目的属性中列出了DN的条目 授予访问权限   ？？？？？？？？？？？？？没看懂！！！
                                    例如： 向 被列为组条目的所有者的任何人授予对组条目的访问权限
                    有些因素可能并不适合所有环境(或任何环境)     
                        例如，
                            域因子(domain factor)依赖于 IP 到域名的查找。
                            由于这些很容易被欺骗，因此应避免使用域因子。 
        8.3.3. 赋予哪些访问权限(The access to grant)
            <access>
                -----------------------------------
                    Table 6.4: Access Levels(表 6.4: 访问级别)
                Level           Privileges Description
                none =         0 no access
                disclose =     d needed for information disclosure on error
                auth =        dx needed to authenticate (bind)
                compare =    cdx needed to compare
                search =    scdx needed to apply search filters
                read =     rscdx needed to read search results
                write =   wrscdx needed to modify/rename
                manage = mwrscdx needed to manage
                -----------------------------------
                        每个级别都意味着所有较低级别的访问权限会被同时赋予。
                            例如，授予某人对某项的 写访问权限 也将授予他们读，搜索，比较，身份验证和公开访问权限。
                            但是，可以使用权限说明符来授予特定权限。
        8.3.4. 访问控制评估(Access Control Evaluation)
            
            在评估是否应授予 某些请求者 访问条目和/或属性的权限时，
                slapd将 条目和/或属性 与 配置文件中给出的<what> selectors进行比较。
            
            对于每个条目，首先应用 保存该条目的数据库中提供的访问控制(如果没有保存在任何数据库中，则应用全局访问控制)，
            然后应用全局访问指令(在前端数据库定义中保存)    
                概述：对于每个条目 先应用数据库中存储的该条目的访问控制，然后应用全局的访问控制
                
            但是，在处理访问列表时，由于全局访问列表被有效地附加到每个数据库列表中，
            因此如果结果列表为非空列表，则访问列表隐式的以 access to * by * none 指令结尾。
            
            如果没有适用于后端的访问指令，则使用默认读取。
            
            (在此优先级内)按访问指令在配置文件中出现的顺序 对其进行检查。
                Slapd停在与 条目和/或属性 匹配的第一个<what> selector上。
                相应的访问指令是 一个slapd 将用来评估访问的指令。
            
            --------然后比较<who>
            接下来，slapd 按照请求出现的顺序比较 请求访问 上面选择的访问指令 的<who> selectors的实体。
            它停在 与请求者匹配的第一个<who> selector上。
                这确定了请求访问的实体 对条目和/或属性的 访问权。

            --------最后比较<who>
            最后，slapd 将所选<access>条款中授予的访问权限与客户端请求的访问权限进行比较。
                如果允许更大或相等的访问权限，则授予访问权限。
                否则，访问将被拒绝
                
            --------指令的顺序非常重要
            访问指令的评估顺序使其在配置文件中的位置很重要。
                如果就其选择的条目而言，
                    一个访问指令比另一个访问指令更具体，则它应该"首先"出现在配置文件中。
                同样，
                    如果一个<who>选择器比另一个选择器更具体，则应在访问指令中排在第一位。
                下面给出的访问控制示例应有助于使这一点变得清楚。

        8.3.5. 访问控制示例(Access Control Examples)
            
            -----------------------------------
            access to * by * read
            -----------------------------------
                    此访问指令 向所有人授予读取访问权限。
            
            -----------------------------------
            access to *
                by self write
                by anonymous auth
                by * read
            -----------------------------------
                    该指令 
                        允许用户修改其条目，
                        允许匿名者针对这些条目进行身份验证，
                        并允许所有其他人读取这些条目(其实只有验证并通过的user能read，因为禁止了匿名访问)。
                    请注意，只有第一个符合条件的<who>条款适用。
                        因此，匿名用户被授予身份验证，而不是读取权限。
                    最后一个子句也可以是“by users read”。
            
            -----------------------------------
            access to *
                by ssf=128 self write
                by ssf=64 anonymous auth
                by ssf=64 users read
            -----------------------------------
                    根据适当的保护级别来限制操作。示例显示了如何使用安全强度因子(SSF)。
                        如果已建立强度为 128 或更高的安全保护，则此指令允许用户修改自己的条目；
                        允许匿名用户进行身份验证访问；
                        在已建立 64 或更高的安全保护时，则可以进行读取访问。
                        如果客户端没有建立足够的安全保护，则将应用隐式的 by * none 条款。
            
            下面的示例显示了如何使用 样式说明符 在两个"顺序很重要!!!"的访问指令中 按DN选择条目
            -----------------------------------
            access to dn.children="dc=example,dc=com"
                by * search
            access to dn.children="dc=com"
                by * read
            -----------------------------------
                    dc=example,dc=com子树下的条目 被赋予"搜索"权限
                    dc=com子树下的条目 被授予"读取"权限； 
                        但dc=example,dc=com子树下的条目没有读取权限
                    dc=com，没有被赋予权限，因为这两个指令均与DN不匹配
                注意：
                    如果这些访问控制指令的顺序颠倒了，
                    那么将永远不会执行位于后面的指令语句，因为dc=example,dc=com下的条目也都在dc=com下
                注意：
                    如果 没有olcAccess: 去匹配指令 或 没有<who>子句，则拒绝访问
                    也就是说，对指令的每次访问均以 by * none 子句结尾。
                    
            在处理访问列表时，由于全局访问列表已有效地加到每个数据库列表中，
                因此如果结果列表为非空列表，则访问列表将以隐式的 access to* by * none 结尾。
            
            如果没有适用于后端的访问指令，则使用默认读取。

            下一个示例再次显示了排序的重要性，无论是访问指令还是 by <who>子句。
                它还显示了如何使用 属性选择器 来授予对 特定属性和各种<who>选择器 的访问权限。
            -----------------------------------
                access to dn.subtree="dc=example,dc=com" attrs=homePhone
                    by self write
                    by dn.children="dc=example,dc=com" search
                    by peername.regex=IP=10\..+ read
                access to dn.subtree="dc=example,dc=com"
                    by self write
                    by dn.children="dc=example,dc=com" search
                    by anonymous auth
            -----------------------------------
                    本示例适用于“dc=example,dc=com”子树中的所有条目的所有属性，除了homePhone属性。

                        条目可以写入自身，
                        example.com 条目下的条目可以进行搜索，
                        除了身份验证/授权(始终以匿名方式进行)之外，其他任何人都没有访问权限(暗含 by * none)。

                        homePhone属性可由该条目写入，
                        可由 example.com 下的条目搜索，
                        可由网络 10 连接的客户端可读，否则不可读(隐含 by * none)。
                    
                    所有其他访问都被 access to * by * none 的隐式访问所拒绝。


            有时允许特定的 DN 在属性中添加或删除自身很有用。
                例如，如果您想创建一个组并允许人们从 member 属性中添加和删除他们自己的 DN，
                则可以使用如下访问指令来完成此操作：
            -----------------------------------
            access to attrs=member,entry
                by dnattr=member selfwrite   ？？？？？？？？？？？？？没看懂！！！
            -----------------------------------
                    dnattr <who> selector 表示该访问权限 适用于成员属性中列出的条目。
                    selfwrite access selector表示此类成员只能从属性中添加或删除自己的 DN，而不能从其他值中添加或删除它们。
                    需要添加条目属性，因为需要访问条目才能访问任何条目的属性。


        8.3.6. 访问控制顺序(Access Control Ordering)
            olcAccess 指令的顺序对于正确评估至关重要,
            但是 LDAP 属性通常不保留其值的顺序,因此 OpenLDAP 使用自定义的扩展架构来维护这些值的固定顺序
                该排序是在每个值之前添加一个数字索引“{X}”，类似于对配置条目进行排序。
                这些索引标签由 slapd 自动维护，并且在最初定义值时无需指定。
                例如
                -----------------------------------
                olcAccess: to attrs=member,entry
                by dnattr=member selfwrite
                olcAccess: to dn.children="dc=example,dc=com"
                by * search
                olcAccess: to dn.children="dc=com"
                by * read
                -----------------------------------
                当您使用 slapcat 或 ldapsearch 读回它们时，它们将包含
                -----------------------------------
                olcAccess: {0}to attrs=member,entry
                by dnattr=member selfwrite
                olcAccess: {1}to dn.children="dc=example,dc=com"
                by * search
                olcAccess: {2}to dn.children="dc=com"
                by * read
                -----------------------------------
            当使用 ldapmodify 编辑访问规则时，数字索引可用于指定要更改的特定值。
                可以使用此索引代替实际访问值(或在实际访问值之外)。
                当管理多个访问规则时，使用此数字索引非常有帮助。
                例如，
                    如果我们需要更改上面的第二条规则以授予写访问权限而不是搜索权限，则可以尝试以下 LDIF：
                    -----------------------------------
                    changetype: modify
                    delete: olcAccess
                    olcAccess: to dn.children="dc=example,dc=com" by * search
                    -
                    add: olcAccess
                    olcAccess: to dn.children="dc=example,dc=com" by * write
                    -
                    -----------------------------------
                    但是此示例无法保证现有值保持其原始顺序，因此很可能会导致安全配置损坏。
                应使用数字索引！！！：
                    -----------------------------------
                    changetype: modify
                    delete: olcAccess
                    olcAccess: {1}
                    -
                    add: olcAccess
                    olcAccess: {1}to dn.children="dc=example,dc=com" by * write
                    -
                    -----------------------------------
                    此示例
                        删除 olcAccess 属性值＃1 中的任何规则(无论其值如何)，
                        并添加一个值＃1 的新值。结果将是
                    -----------------------------------
                    olcAccess: {0}to attrs=member,entry
                    by dnattr=member selfwrite
                    olcAccess: {1}to dn.children="dc=example,dc=com"
                    by * write
                    olcAccess: {2}to dn.children="dc=com"
                    by * read
                    -----------------------------------


    8.4. 访问控制常见示例(Access Control Common Examples)
        8.4.1. 基本 ACLs(Basic ACLs)
            -----------------------------------
            access to attrs=userPassword
            by self =xw
            by anonymous auth
            by * none
            access to *
            by self write
            by users read
            by * none
            -----------------------------------
                第一个 ACL 
                    允许用户更新(但不读取)密码，
                    匿名用户针对此属性进行身份验证，
                    以及(隐式)拒绝其他用户的所有访问。
                第二个 ACL 
                    允许用户完全访问其条目，
                    经过身份验证的用户可以读取任何内容，
                    并且(隐式)拒绝其他用户(在这种情况下为匿名用户)的所有访问。
       
        8.4.2. 匹配匿名和身份验证用户(Matching Anonymous and Authenticated users)
            
            匿名用户的 DN 为空。
                虽然可以使用 dn.exact=""或 dn.regex="^$"，但 slapd(8)提供了一个匿名的简写形式，应改为使用:
            -----------------------------------  
            access to *
                by anonymous none
                by * read             
            -----------------------------------  
                所有匿名(未认证)用户 没有任何权限，
                其他人有 读权限。             
            
            通过了身份验证的用户具有 DN。
                尽管 dn.regex=".+"将与任何经过身份验证的用户匹配，但 OpenLDAP 为用户提供了捷径，应该使用它：
            -----------------------------------    
                access to *
                    by users read
                    by * none
            -----------------------------------     
                此 ACL 
                    已认证用户 读权限，
                    其他用户(即匿名用户) 没有任何权限。          
            
        8.4.3. 控制 rootdn 访问(Controlling rootdn access)            

            您可以在 slapd.conf 或 slapd.d/ 中指定 rootdn ，而无需指定 rootpw。
                然后，您必须添加具有相同 dn 的实际目录条目，
                例如：
            -----------------------------------    
            dn: cn=Manager,o=MyOrganization
            cn: Manager
            sn: Manager
            objectClass: person
            objectClass: top
            userPassword: {SSHA}someSSHAdata           
            -----------------------------------   
            然后以 rootdn 身份绑定到该 DN，
                而这又需要对该条目的 DN 和 userPassword进行身份验证，
                可以通过 ACL 对其进行限制。
                例如：            
            -----------------------------------   
            access to dn.base="cn=Manager,o=MyOrganization"
                by peername.regex=127\.0\.0\.1 auth
                by peername.regex=192\.168\.0\..* auth
                by users none
                by * none            
            -----------------------------------  
                此ACL 
                    仅允许来自 本主机和192.168.0.0/24的 rootdn 进行绑定


        8.4.4. 通过分组来管理权限(Managing access with Groups)            
            
            有几种方法可以做到这一点。这里说明了一种方法。
            请考虑以下 DIT 布局：
            -----------------------------------  
            +-dc=example,dc=com
            +---cn=administrators,dc=example,dc=com
            +---cn=fred blogs,dc=example,dc=com             
            -----------------------------------    
            组中的对象(采用 LDIF 格式)：           
            -----------------------------------   
            dn: cn=administrators,dc=example,dc=com
            cn: administrators of this region
            objectclass: groupOfNames (important for the group acl feature)
            member: cn=fred blogs,dc=example,dc=com
            member: cn=somebody else,dc=example,dc=com            
            -----------------------------------   
            然后，
                可以通过在 slapd.conf的权限指令中添加适当的 组条款 来授予对此组成员的访问权限。
                例如，            
            -----------------------------------   
            access to dn.children="dc=example,dc=com"
                by self write
                by group.exact="cn=Administrators,dc=example,dc=com" write
                by * auth            
            -----------------------------------        

            可以像dn使用正则表达式(如dn.regex)去匹配dn，同样可以使用expand去匹配组名(group.expand)
                例如：
            -----------------------------------        
            access to dn.regex="(.+,)?ou=People,(dc=[^,]+,dc=[^,]+)$"
                attrs=children,entry,uid
            by group.expand="cn=Managers,$2" write
            by users read
            by * auth       
            -----------------------------------  
            上图假设在 groupOfNames对象类的 member属性类型 中找到组成员。
                如果您需要使用其他组对象和/或其他属性类型，请使用以下 slapd.conf语法：      
                    access to <what>
                        by group/<objectclass>/<attributename>=<DN> <access>    
                    例如：   
            -----------------------------------    
            access to *
                by
                    group/organizationalRole/roleOccupant="cn=Administrator,dc=example,dc=com" write           
            -----------------------------------      
            在这种情况下，
                我们有一个 ObjectClass organizationalRole，
                其中包含 roleOccupant 属性中的管理员DN。
                例如：                                                      ？？？？？？？？？？？？？没看懂！！！
            -----------------------------------  
            dn: cn=Administrator,dc=example,dc=com
            cn: Administrator
            objectclass: organizationalRole
            roleOccupant: cn=Jane Doe,dc=example,dc=com             
            ----------------------------------- 
            注意：
                指定的成员属性类型必须是 DN 或 NameAndOptionalUID 语法，
                并且指定的对象类应允许该属性类型。




        8.4.5. 授予对属性子集的访问权限(Granting access to a subset of attributes)     
            
            在ACL中指定 属性名称列表 来对一组属性授予权限
                还需要，授予条目自身的访问权限。
                还要注意，子级如何控制添加，删除和重命名条目的能力。
            -----------------------------------     
            # mail: self may write, authenticated users may read
            access to attrs=mail
            by self write
            by users read
            by * none

            # cn, sn: self my write, all may read
            access to attrs=cn,sn
            by self write
            by * read

            # immediate children: only self can add/delete entries under this entry
            access to attrs=children
            by self write

            # entry itself: self may write, all may read
            access to attrs=entry
            by self write
            by * read

            # other attributes: self may write, others have no access
            access to *
            by self write
            by * none          
            -----------------------------------    
                还可以指定 ObjectClass 名称，这将影响该 objectClass 所需和/或允许的所有属性。
                如何指定：
                    attrlist中以 @作为前缀 和 以！作为前缀 的名称被直接视为 objectClass 名称。
                    但是在这种情况下，访问规则会影响该 objectClass 不需要或不允许的属性。           


        8.4.6. 允许用户写入其下的所有条目(Allowing a user write to all entries below theirs)     

            -----------------------------------       
            access to dn.regex="(.+,)?(uid=[^,]+,o=Company)$"
                by dn.exact,expand="$2" write                       ？？？？？？？？？？？？？没看懂！！！
                by anonymous auth        
            -----------------------------------   
                用户可 对自己和自己的孩子 都有写权限   


        8.4.7. 允许创建条目(Allowing entry creation)     
                 

            -----------------------------------    
            o=<basedn>
                ou=domains
                    associatedDomain=<somedomain>
                        ou=users
                            uid=<someuserid>
                            uid=<someotheruserid>
                        ou=addressbooks
                            uid=<someuserid>
                                cn=<someone>
                                cn=<someoneelse>      
            -----------------------------------  
            对于另一个域<someotherdomain>：             
            -----------------------------------  
            o=<basedn>
                ou=domains
                    associatedDomain=<someotherdomain>
                        ou=users
                            uid=<someuserid>
                            uid=<someotheruserid>
                        ou=addressbooks
                            uid=<someotheruserid>
                                cn=<someone>
                                cn=<someoneelse>             
            -----------------------------------    
            如果 用户uid=<someuserid> 仅为其自己的内容创建一个条目，则可以编写如下的 ACL：           
            -----------------------------------    
            # this rule lets users of "associatedDomain=<matcheddomain>"
            # write under "ou=addressbook,associatedDomain=<matcheddomain>,ou=domains,o=<basedn>",
            # i.e. a user can write ANY entry below its domain's address book;
            # this permission is necessary, but not sufficient, the next
            # will restrict this permission further


            access to dn.regex="^ou=addressbook,associatedDomain=([^,]+),ou=domains,o=<basedn>$" attrs=children
                    by dn.regex="^uid=([^,]+),ou=users,associatedDomain=$1,ou=domains,o=<basedn>$$" write
                    by * none


            # Note that above the "by" clause needs a "regex" style to make sure
            # it expands to a DN that starts with a "uid=<someuserid>" pattern
            # while substituting the associatedDomain submatch from the "what" clause.


            # This rule lets a user with "uid=<matcheduid>" of "<associatedDomain=matcheddomain>"
            # write (i.e. add, modify, delete) the entry whose DN is exactly
            # "uid=<matcheduid>,ou=addressbook,associatedDomain=<matcheddomain>,ou=domains,o=<basedn>"
            # and ANY entry as subtree of it


            access to dn.regex="^(.+,)?uid=([^,]+),ou=addressbook,associatedDomain=([^,]+),ou=domains,o=<basedn>$"
                    by dn.exact,expand="uid=$2,ou=users,associatedDomain=$3,ou=domains,o=<basedn>" write
                    by * none


            # Note that above the "by" clause uses the "exact" style with the "expand"
            # modifier because now the whole pattern can be rebuilt by means of the
            # submatches from the "what" clause, so a "regex" compilation and evaluation
            # is no longer required.    
            -----------------------------------    

        8.4.8. 访问控制中使用正则表达式的经验(Tips for using regular expressions in Access Control)     
            
            当打算使用正则表达式匹配时，请始终使用 dn.regex=<pattern>
                dn=<pattern>默认为dn.exact<pattern>
                
                要匹配至少一个字符： 请使用(.+)而不是(.*) ，因为(.*)也匹配空字符串。
                
                不要使用正则表达式进行匹配，因为 不安全且昂贵 例子：dn.regex=".*dc=example,dc=com"
                    不安全，
                        因为任何包含 dc=example,dc=com 的字符串都将匹配，而我们需要的是那些以dc=example,dc=com结尾的字符串；
                            使用 .*dc=example，dc=com$ 代替。
                    还不安全，
                        由于.*dc 那么以dc结尾的任何字符串，例如mydc 也将匹配。
                        如果您确实需要一个仅允许dc=example，dc=com 或其任何子树的正则表达式，
                            请使用^(.+,)?dc=example,dc=com$，
                            这意味着：左侧的任何内容 dc=...(如果有的话)必须以逗号结尾；
                    价格昂贵，
                        因为如果您不需要子匹配项，则可以使用范围界定，例如：dn.subtree="dc=example,dc=com"
                
                在匹配模式中包含 dc=example,dc=com
                    dn.children="dc=example,dc=com"
                从匹配模式中排除 dc=example,dc=com，或者只允许一个子级别的匹配。
                    dn.onelevel="dc=example,dc=com"
                注意：
                    1.始终在正则表达式中使用^和$
                    2.始终使用([^,]+)来表示一个 RDN
                    3.不要将rootdn添加到by子句中。因为对于以rootdn身份执行的操作，甚至不处理 ACL
                    4.使用速记, user匹配经过身份验证的用户，anonymous匹配匿名用户。
                    5.如果您需要的是范围界定和/或子字符串替换，请不要在<by>子句中使用 dn.regex；
                        使用作用域样式(例如exact, onelevel, children or subtree)，
                        并且样式修饰符扩展以引起子字符串扩展。For instance, 例如，
                            -----------------------------------    
                            access to dn.regex=".+,dc=([^,]+),dc=([^,]+)$"
                                by dn.regex="^[^,],ou=Admin,dc=$1,dc=$2$$" write
                            -----------------------------------    
                            尽管正确，但可以安全有效地替换为
                            -----------------------------------    
                            access to dn.regex=".+,(dc=[^,]+,dc=[^,]+)$"
                                by dn.onelevel,expand="ou=Admin,$1" write
                            -----------------------------------    
                                    其中<what>子句中的正则表达式更紧凑，
                                    而<by>子句中的正则表达式被 具有子字符串扩展功能的 onelevel 代替。


        8.4.9. 根据安全强度因子(ssf)授予和拒绝访问(Granting and Denying access based on security strength factors (ssf))     

            可以基于安全强度因子(SSF)限制访问
            -----------------------------------  
            access to dn="cn=example,cn=edu"
                by * ssf=256 read  
            -----------------------------------    

            0(0)表示无保护，
            1 表示仅完整性保护，
            56 DES 或其他弱密码，
            112 三重 DES 和其他强密码，
            128 RC4，
            Blowfish 和其他现代强密码。

            其他可能性：
                transport_ssf=<n>
                tls_ssf=<n>
                sasl_ssf=<n>
            
            推荐 256


        8.4.10. 当事情没有按预期进行时(When things aren't working as expected)     
            例如：
            -----------------------------------  
            access to *
                by anonymous auth
            
            access to *
                by self write
            
            access to *
                by users read  
            -----------------------------------   
                您可能会认为这将允许任何用户登录，读取所有内容并在登录后更改自己的数据。
                但是在此示例中，只有登录有效，而 ldapsearch 不返回任何数据。
                原因是：
                    SLAPD会逐行通过其访问配置，并在访问规则的一部分中找到匹配项后立即停止。 
            应该写为：
            -----------------------------------   
            access to *
                by anonymous auth
                by self write
                by users read 
            -----------------------------------   
            通用规则是：“首先使用特殊访问规则，最后使用普通访问规则” 


        
    8.5. 集合-根据关系授予权限(Sets - Granting rights based on relationships)
        集合最好通过示例来说明。
        以下各节将提供一些 ACL 示例集，以助理解。

        8.5.1. 组中的组(Groups of Groups)     
            
            OpenLDAP ACL 不会在组内扩展组(不支持在组中嵌套另一个组)，
                一个组包含了另一个组作为它的成员，那么被包含的组无法拥有成员。
            例如：
            -----------------------------------    
            dn: cn=sudoadm,ou=group,dc=example,dc=com
            cn: sudoadm
            objectClass: groupOfNames
            member: uid=john,ou=people,dc=example,dc=com
            member: cn=accountadm,ou=group,dc=example,dc=com

            dn: cn=accountadm,ou=group,dc=example,dc=com
            cn: accountadm
            objectClass: groupOfNames
            member: uid=mary,ou=people,dc=example,dc=com
            -----------------------------------    
                如果我们在上述条目中使用 标准组ACL，并且允许 sudoadm组的成员在某个地方写，
                则不会包括 mary：
            -----------------------------------    
             access to dn.subtree="ou=sudoers,dc=example,dc=com"
                by group.exact="cn=sudoadm,ou=group,dc=example,dc=com" write
                by * read
            -----------------------------------    


            但是，通过集合(sets)，
                我们可以使得ACL递归，支持在组中嵌套组；
                因此，对于组中的每一成员，都可以进一步扩展了。
            ----------------------------------- 
             access to dn.subtree="ou=sudoers,dc=example,dc=com"
                by set="[cn=sudoadm,ou=group,dc=example,dc=com]/member* & user" write
                by * read   
            ----------------------------------- 
                此ACL设置表示：
                    使用 cn=sudoadm 这个 DN，检查其成员属性(其中的*表示递归)，然后将结果与经过身份验证的用户的 DN 相交。
                    如果结果为非空，则ACL视其为匹配项，并授予写访问权限。
                        首先我们得到 uid=john 这个 DN。该条目没有member属性，因此扩展在此处停止。
                        现在我们进入 cn=accountadm。这确实有一个member属性，即 uid=mary。但是 uid=mary 条目没有成员，因此我们再次在这里停止。
                        最终比较是： {"uid=john,ou=people,dc=example,dc=com","uid=mary,ou=people,dc=example,dc=com"} & user
                        因此，此set(集)将在 sudoadm 组中包括 mary，并且将允许她进行写访问。
            
            
            
        8.5.2. 没有DN语法的Group ACLs(Group ACLs without DN syntax)     
            
            传统的Group ACLs 还有上面的有关递归组的例子，都要求将 member指定为DN，而不是用户名(usernames)
            但是，通过使用sets(集合)，我们可以在Group ACLs中，使用简单名(uid 或 username)
            示例：
            -----------------------------------
            dn: cn=sudoadm,ou=group,dc=example,dc=com
            cn: sudoadm
            objectClass: posixGroup
            gidNumber: 1000
            memberUid: john    
            -----------------------------------    
                使用memeberUid定义组成员
                对于这种类型的组，我们不能使用Group ACLs，我们应该使用set ACL 进行权限的赋予
            -----------------------------------  
            access to dn.subtree="ou=sudoers,dc=example,dc=com"
                by set="[cn=sudoadm,ou=group,dc=example,dc=com]/memberUid & user/uid"
            write
                by * read  
            -----------------------------------   
                说明：
                    使用一个简单的交集(和8.5.1类似)
                        将通过身份验证的uid和组中的memberUid属性进行比较，
                        如果匹配，则交集非空，ACL将会赋予这个user写权限。 
                    这种情况下，
                        如果是mary，则不会赋予她写权限，因为她的uid没有在组的memberUid中列出。
            
            
        8.5.3. Following references     
            现在将展示一个非常强大的示例：说明我们如何使用sets(集合)
                当OpenLDAP管理员理解了本示例的含义后，he will smile！！！！

            以一个用户条目开始
            -----------------------------------    
            dn: uid=john,ou=people,dc=example,dc=com
            uid: john
            objectClass: inetOrgPerson
            givenName: John
            sn: Smith
            cn: john
            manager: uid=mary,ou=people,dc=example,dc=com
            -----------------------------------    
                    mary是john的经理(manager)
            使用sets写一个ACL：
                允许manager更新一些属性
            -----------------------------------    
            attrs=carLicense,homePhone,mobile,pager,telephoneNumber
            by self write
            by set="this/manager & user" write
            by * read
            -----------------------------------    
                在此set中，扩展为正在访问的条目，
                    因此当john的条目被访问时，“this/manager”扩展为“uid=mary,ou=people,dc=example,dc=com”。
                    如果“manager(uid=mary)”自己正在访问John的条目，ACL将匹配并授予对这些属性的写访问权。

            
            到目前为止，可以使用 dnattr 关键字获得相同的行为。
            但是，有了sets，我们可以进一步增强此 ACL。
                假设我们要允许经理的秘书也更新这些属性。这是我们的做法：
            -----------------------------------  
            access to dn.exact="uid=john,ou=people,dc=example,dc=com"
                attrs=carLicense,homePhone,mobile,pager,telephoneNumber
                by self write
                by set="this/manager & user" write
                by set="this/manager/secretary & user" write
                by * read
            -----------------------------------   
            -----------------------------------   
            DN: uid=john,ou=people,dc=example,dc=com
            uid: john
            manager: uid=mary,ou=people,dc=example,dc=com 

            DN: uid=mary,ou=people,dc=example,dc=com
            uid: john
            secretary: uid=jane,ou=people,dc=example,dc=com 

            DN: uid=jane,ou=people,dc=example,dc=com
            uid: jane
            -----------------------------------   
                    在此示例中，
                        jane是mary的秘书
                        mary是john的经理
                    整个关系由manager和secretary属性定义，它们都是distinguishedName语法(即 完整DN)
            当访问uid=john条目时，this/manager/secretary将变为uid=jane,ou=people,dc=example,dc=com
            ----------------------------------- 
                this = [uid=john,ou=people,dc=example,dc=com]
                this/manager = \
                [uid=john,ou=people,dc=example,dc=com]/manager = uid=mary,ou=people,dc=example,dc=com
                this/manager/secretary = \
                [uid=mary,ou=people,dc=example,dc=com]/secretary = uid=jane,ou=people,dc=example,dc=com   
            -----------------------------------    
            最终结果是，当 Jane 访问 John 的条目时，jane将被授予对指定属性的写访问权限。
            更好的是，这将发生在她访问的所有以 Mary 为经理的条目上。

            这一切都很酷，也很不错，但也许赋予秘书太多权力。
            也许我们需要进一步限制它。
            例如，我们只允许“执行秘书”拥有此权力：
            ----------------------------------- 
            access to dn.exact="uid=john,ou=people,dc=example,dc=com"
             attrs=carLicense,homePhone,mobile,pager,telephoneNumber
             by self write
             by set="this/manager & user" write
             by set="this/manager/secretary &
                 [cn=executive,ou=group,dc=example,dc=com]/member* &
                 user" write
             by * read   
            -----------------------------------    
                它几乎与前面的ACL相同，但是我们要求连接上来的user必须是cn=executive组中的(可能是嵌套的)
            
            
9. 限制(Limits)            
    9.1. 介绍(instruction)
        通常希望限制每个 LDAP 客户端可以消耗的服务器资源。
            OpenLDAP 提供了两组限制：
                大小限制可以限制客户端可以在单个操作中检索的条目数，
                而时间限制可以限制操作可以继续的时间长度。
            根据发起操作的人，可以给两种类型的限制赋予不同的值。
    
    9.2. 软硬限制(Soft and Hard limits)

        服务器管理员可以指定软限制和硬限制(通常一起称为管理限制)。
            可以将软限制视为默认限制值。
            普通 LDAP 用户不能超过硬限制。

        LDAP 客户端可以在发出搜索操作时指定自己的大小和时间限制
            如果客户指定了限制，则请求值和硬限制中的较低者将成为操作的限制。
            如果客户端未指定限制，则服务器将应用软限制。
        
        如果 LDAP 客户端请求的搜索返回的结果超出限制所允许的数量，
            则会出现 adminLimitExceeded 错误。
        请注意，
            即使已超过限制，服务器通常也会返回一些结果：
            此功能对于只想检查某些条目是否存在而无需查看所有条目的客户端很有用。

        rootdn 不受任何限制。


    9.3. 全局限制(Global Limits)

        服务器配置的全局部分中指定的限制用作默认值，如果数据库没有设置更具体的限制，则使用默认值。
            默认大小限制为 500 个条目，
            默认时间限制为 3600 秒。

        在 slapd.conf中，关键字是：
            sizelimit 
            timelimit
        slapd中，关键字是：
            olcSizeLimit 
            olcTimeLimit

        简单形式：将软限制和硬限制设置为相同的值：
            sizelimit {<integer>|unlimited}
            timelimit {<integer>|unlimited}

        扩展形式：允许分别设置软限制和硬限制：
            sizelimit size[.{soft|hard|unchecked}]=<integer> [...]
            timelimit time[.{soft|hard}]=<integer> [...]
                例如：sizelimit size.soft=10 size.hard=75
        
        请务必确保配置了正确的索引
            这在大型目录中非常重要，
            因为索引无法满足的搜索可能会导致服务器检查数百万个条目

    9.4. 每个数据库的限制(Per-Database Limits)
       
        每个数据库可以有一组自己的限制，这些限制可以覆盖全局限制。
            语法更加灵活，它允许将不同的限制应用于不同的实体。
            请注意，实体与条目不同：
                实体在这里用于表示启动LDAP操作的 person ID 或process
        
        slapd.conf配置中，关键字是：limits
        slapd config中，关键字是： olcLimits
        语法都是相同的：
            limits <selector> <limit> [<limit> [...]]

        可以多次指定限制条款，以将不同的限制应用于不同的启动器(initiators)。
            服务器依次检查每个子句，直到找到与该操作的发起者(initiator)或基本DN(base DN) 匹配的子句为止。
            如果找不到匹配项，则将使用全局限制。

        9.4.1. 指定限制适用于谁(Specify who the limits apply to)    
            <selector>部分，采用下表的值：
                        Table 9.1: Limits Entity Specifiers
                Specifier	                        Entities
                *	                                All, including anonymous and authenticated users
                anonymous	                        Anonymous (non-authenticated) users
                users	                            Authenticated users
                dn[.<type>][.<style>]=<pattern>]	Entry or entries within a scope that match <pattern>
                group[/oc[/at]]=<pattern>	        Members of a group
            type  可以是： self ，this
            style 可以是： exact, base, onelevel, subtree, children, regex, anonymous
        
        9.4.2. 指定时间限制(Specify time limits)  
            语法：
                time[.{soft|hard}]=<integer>
                    integer 是响应搜索请求所花费的秒数
                    如果既未指定 soft 又未指定 hard，则该值将同时用于这两个值
                        例如：limits anonymous time=27
                    unlimited可用于完全消除硬限制
                        例如：limits dn.exact="cn=anyuser,dc=example,dc=org" time.hard=unlimited

        9.4.3. 指定大小限制(Specifying size limits)    
            语法： 
                size[.{soft|hard|unchecked}]=<integer>
                    中<integer>是搜索请求时将返回 slapd 的最大条目数。
                    Soft, hard, unchecked与全局限制中含义相同


        9.4.4. 大小限制和分页结果(Size limits and Paged Results)    

            如果 LDAP 客户端将 pagedResultsControl 添加到搜索操作中，则默认使用硬大小限制
                大小限制适用于搜索中返回的条目总数，而不适用于单个页面。
            
            对于分页搜索，可能会强制执行其他大小限制。
                
                使用 size.pr 控制最大页面大小：
                    size.pr={<integer>|noEstimate|unlimited}
                        如果未显式设置大小，则<integer>是最大页面大小
                        noEstimate 在当前实现中无效，因为服务器无论如何都不返回结果大小的估计值
                        unlimited表示未限制最大页面大小
                
                使用 size.prtotal 控制分页搜索可以返回的条目总数
                    默认情况下，该限制与正常的size.hard 限制相同
                    size.prtotal={<integer>|unlimited|disabled}
                        Unlimited取消了分页搜索可以返回的条目数的限制
                        disabled可用于有选择地禁用分页结果搜索

    9.5. 限制配置的例子(Example Limit Configurations)
        9.5.1. 简单的全局限制(Simple Global Limits)
            -----------------------------------    
            sizelimit 50
            timelimit 10
            -----------------------------------    
                将搜索结果限制为50，时间限制为10秒
                这个简单的全局设置，应用于除rootdn之外的所有用户的搜索
        9.5.2. 全局软硬限制(Global Hard and Soft Limits)
            为了防止客户端进行非常低效的非索引搜索，请同时添加unchecked限制：
                sizelimit size.soft=5 size.hard=100 size.unchecked=100
        9.5.3.给特定用户更大的限制(Giving specific users larger limits)
            在全局配置中设置了适当的默认限制后，可能希望使某些用户能够检索更大的结果集。
            这是在每个数据库配置中执行此操作的方法：
            -----------------------------------    
            limits dn.exact="cn=anyuser,dc=example,dc=org" size=100000
            limits dn.exact="cn=personnel,dc=example,dc=org" size=100000
            limits dn.exact="cn=dirsync,dc=example,dc=org" size=100000
            -----------------------------------    
            通常最好避免在服务器配置中提及特定用户。
            更好的方法是给组更高的限制：
            -----------------------------------    
            limits group/groupOfNames/member="cn=bigwigs,dc=example,dc=org" size=100000
            -----------------------------------    
        9.5.4.限制谁可以分页搜索(Limiting who can do paged searches)
            可能某些应用程序需要使用分页搜索来检索的非常大的结果集，但是您不希望普通LDAP 用户使用 pagedResults 控件。
            pr 和 prtotal 限制可以帮助：
            -----------------------------------    
            limits group/groupOfNames/member="cn=dirsync,dc=example,dc=org" size.prtotal=unlimited
            limits users size.soft=5 size.hard=100 size.prtotal=disabled
            limits anonymous size.soft=2 size.hard=5 size.prtotal=disabled
            -----------------------------------    

    9.6. 更多信息(Further Information)
            有关更多信息，请参见 slapd.conf(5)，ldapsearch(1)和 slapd.access(5)


10. 数据库创建和维护工具(Database Creation and Maintenance Tools)
    如何从头来时创建一个数据库，遇到问题时如何进行故障排除。
    两种创建数据库的方法：
        1.使用LDAP在线创建(法一)
            启动slapd并使用LDAP客户端添加条目；
            适用于较小的数据库(几百或者几千个条目)
        2.使用slapd附带的可执行程序(法二)
            当你需要创建成千上万个条目，或者 确保在创建数据库时不访问数据库，
            此方法是最佳选择
            注意：并非所有的数据库类型都支持这些可执行程序
    
    10.1. (法一)通过 LDAP 创建数据库Creating a database over LDAP
        
        使用你所选的LDAP client(例如ldapadd)添加条目
            在启动slapd之前，确保你已经在配置文件中设置好了以下选项
                suffix <dn> 
                    将此设置为您要创建的子树的根的DN
                    例如：suffix "dc=example,dc=com"
                directory <directory>
                    指定一个目录，在该目录中创建索引文件
                        需要使用适当的权限创建该目录，以便 slapd 可以写入该目录
                    例如：directory /usr/local/var/openldap-data
                rootdn <dn>
                rootpw <passwd>
                    定义超级用户(root用户)
                        具有添加体条目的权限
                    例如：
                        rootdn "cn=Manager,dc=example,dc=com"
                        rootpw secret
                index {<attrlist> | default} [pres,eq,approx,sub,none]
                    确保数据库定义包含所需的索引定义(一个或多个索引选项)
                    例如：
                        index cn,sn,uid pres,eq,approx,sub
                        index objectClass eq
                            这将为cn，sn和uid属性，创建presence，equality(相等)，approximate(近似)和substring(子字符串)索引
                            为objectClass属性创建equality(相等)索引
                                注意：并非所有索引类型都适用于所有属性类型
            启动slapd，与LDAP客户端连接，开始添加条目
                创建一个entries.ldif
                -----------------------------------
                # Organization for Example Corporation
                dn: dc=example,dc=com
                objectClass: dcObject
                objectClass: organization
                dc: example
                o: Example Corporation
                description: The Example Corporation

                # Organizational Role for Directory Manager
                dn: cn=Manager,dc=example,dc=com
                objectClass: organizationalRole
                cn: Manager
                description: Directory Manager
                -----------------------------------
            然后使用命令创建这个条目：
                 ldapadd -f entries.ldif -x -D "cn=Manager,dc=example,dc=com" -w secret
    
    10.2. (法二)离线创建数据库Creating a database off-line
        使用sladp数据库工具进行离线创建
            适用于：成千上万的条目需要创建
            这些工具读取slapd配置文件和一个输入文件，并且 输入文件中的文本代表了要添加的条目
            对于支持这些工具的数据库类型，它们直接产生出数据库文件
            有一些重要的参数，确保已经设置在了 包含数据库定义的 配置文件中
                suffix <dn> 
                    将此设置为您要创建的子树的根的DN
                    例如：suffix "dc=example,dc=com"
                directory <directory>
                    指定一个目录，在该目录中创建索引文件
                        需要使用适当的权限创建该目录，以便 slapd 可以写入该目录
                    例如：directory /usr/local/var/openldap-data
                index {<attrlist> | default} [pres,eq,approx,sub,none]
                    确保数据库定义包含所需的索引定义(一个或多个索引选项)
                    例如：
                        index cn,sn,uid pres,eq,approx,sub
                        index objectClass eq
                            这将为cn，sn和uid属性，创建presence，equality(相等)，approximate(近似)和substring(子字符串)索引
                            为objectClass属性创建equality(相等)索引
                                注意：并非所有索引类型都适用于所有属性类型
        
        10.2.1. slapadd (The slapadd program)    
            配置完毕后，运行 slapadd程序来创建主数据库和关联的索引：
                slapadd -l <inputfile> -f <slapdconfigfile>
                    [-d <debuglevel>] [-n <integer>|-b <suffix>]

                    -l <inputfile>
                        指定LDIF格式的输入文件，文件包含了要以文本形式添加的条目
                    -f <slapdconfigfile>
                        指定slapd配置文件，该文件告诉我们在哪里创建索引，创建什么索引
                    -F <slapdconfdirectory>
                        指定slapd的配置目录
                            如果同时指定了-f和-F：将读取slapd配置文件，然后转换为slapd配置目录格式并写入指定目录
                                如果还指定了dryrun模式，则不会进行任何转换
                            如果未指定-f和-F中任何一个，那么在尝试使用默认配置文件之前 将尝试读取默认配置目录 
                                如果存在有效的配置目录，则默认的配置文件将被忽略
                    -d <debuglevel>
                        打开调试
                        调试级别和slapd相同【7.1节中有个 调试级别表】
                    -n <databasenumber>
                        (可选的参数)指定要修改的数据库
                            配置文件中列出的第一个数据库是1，第二个是2，以此类推
                            默认情况下，使用配置文件中的第一个数据库
                            该参数，不可以和-b一起使用
                    -b <suffix>
                        (可选的参数)指定要修改的数据库 
                            提供的suffix和数据库的suffix(后缀)进行匹配，以确定数据库号
                            不应与-n一起使用
                    

        10.2.2. slapindex(The slapindex program)
            有时可能需要重新生成索引(例如在修改 slapd.conf之后),使用 slapindex可以做到这一点
            语法： 
                slapindex -f <slapdconfigfile>
                    [-d <debuglevel>] [-n <databasenumber>|-b <suffix>]

                    -f -d -n -b选项和slapadd相同
                    slapindex根据当前数据库内容重建所有索引
        
        10.2.3. slapcat(The slapcat program)
            slapcat用于将数据库转储到LDIF文件中
                当你想对数据库进行易于理解的备份时，或者 当你要离线编辑数据库时
            语法： 
                slapcat -l <filename> -f <slapdconfigfile>
                    [-d <debuglevel>] [-n <databasenumber>|-b <suffix>]

                    -n -b选项用于在 -f指定的slapd.conf 中选择数据库
                    相应的LDIF输出写入到 标准输出 或 -l指定的文件  中

        10.3. LDIF文本条目格式(The LDIF text entry format)
            LDAP数据交换格式(LDAP Data Interchange Format (LDIF)),简称为LDIF，
                它使用简单文本格式来表示LDAP条目
            
            条目的基本形式是：
            -----------------------------------    
            # comment
            dn: <distinguished name>
            <attrdesc>: <attrvalue>
            <attrdesc>: <attrvalue>
            ...
            -----------------------------------    
                '#' :     注释
                <attrdesc>: 
                    可以是简单的属性类型，例如：cn，objectClass 
                        或者 1.2.3 (与属性类型关联的OID)
                        或者 包含诸如cn;lang_en_US或userCertificate;inary之类的选项

            以一个空格或者tab开头的行，是上一行的继续    
                -----------------------------------   
                dn: cn=Barbara J Jensen,dc=example,dc=
                 com 
                cn: Barbara J
                 Jensen 
                -----------------------------------   
            等价于 
                -----------------------------------  
                dn: cn=Barbara J Jensen,dc=example,dc=com
                cn: Barbara J Jensen  
                -----------------------------------    

            在不同的行上指定多个属性值(<attrvalue>)。例如
                -----------------------------------  
                cn: Barbara J Jensen
                cn: Babs Jensen  
                -----------------------------------    
            
            1.如果<attrvalue>包含非打印字符或以空格，冒号(':')或小于('<')开头，
                则 <attrdesc> 后跟一个双冒号("::")，并使用 base64 编码值。
                例如，值“以空格开头”将这样编码：
                    cn:: IGJlZ2lucyB3aXRoIGEgc3BhY2U=
            2.<attrvalue>
                也可以指定一个包含 属性值 的URL
                例如，从指定文件件/path/to/file.jpeg获取jpegPhoto值：
                    cn:< file:///path/to/file.jpeg
            
            在同一LDIF文件中使用空行来间隔各个条目
            下面的示例包含了3个条目：
            -----------------------------------    
            # Barbara's Entry
            dn: cn=Barbara J Jensen,dc=example,dc=com
            cn: Barbara J Jensen
            cn: Babs Jensen
            objectClass: person
            sn: Jensen

            # Bjorn's Entry
            dn: cn=Bjorn J Jensen,dc=example,dc=com
            cn: Bjorn J Jensen
            cn: Bjorn Jensen
            objectClass: person
            sn: Jensen
            # Base64 encoded JPEG photo
            jpegPhoto:: /9j/4AAQSkZJRgABAAAAAQABAAD/2wBDABALD
            A4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQ
            ERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVG

            # Jennifer's Entry
            dn: cn=Jennifer J Jensen,dc=example,dc=com
            cn: Jennifer J Jensen
            cn: Jennifer Jensen
            objectClass: person
            sn: Jensen
            # JPEG photo from file
            jpegPhoto:< file:///path/to/file.jpeg
            -----------------------------------    
                注意
                    Bjorn条目中的jpegPhoto使用base64编码，
                    Jennifer条目中的jpegPhoto从URL所指示的位置获得。

            注意： 
                每一行的结尾不要包含多余的空格



11. 后端(Backends)
    
    后端执行实际的存储和检索，以相应LDAP的请求。
        后端可以被静态编译进slapd，
        或者
        当启用模块支持后，可以动态加载后端
    
    如果你的安装使用动态模块
        需要添加相关的moduleload指令
        后端模块的通用名称是：
            back_<backend name>.la
        例如，你需要加载hdb后端：
            moduleload back_hdb.la 

    11.1. Berkeley DB Backends
        11.1.1. Overview
            slapd的hdb后端，是一个正常/普通的的slapd数据库后端。
                它使用Oracle Berkeley DB (BDB)包来存储数据，
                它广泛的使用索引和缓存来加速数据访问
            
            hdb是原始bdb后端的变体，最初是为与 BDB 一起使用而编写的；
            hdb使用支持子树重命名的分层数据库布局；
            它在其他方面和bdb的行为完全相同，并且所有相同的配置选项都适用。

            注意：
                hdb数据库需要一个更大的idlcachesize(idl缓存)，才能获得更好的搜索性能，
                通常是cachesize (entry cache size)(缓存大小(条目缓存大小))的三倍或者更大
            
            注意：
                hdb后端已经取代了bdb后端，并且很快将不推荐使用两者，
                而推荐使用新的mdb后端。
        11.1.2. back-bdb/back-hdb Configuration
            略
        11.1.3. Further Information
            略
    
    11.2. LDAP
        11.2.1. 概览(Overview)
            slapd的LDAP后端不是一个实际的数据库，
                相反 它作为一个proxy 将传入请求转发给另一个LDAP服务器。
                在处理请求时，它会追踪referrals，使得/以便 referrals进行完全处理，而不是将其返回给slapd客户端
            
            明确绑定到back-ldap数据库的会话会创建它们自己与远端LDAP服务器的专用连接。
            匿名会话会和远端服务器共享一个匿名连接。
            对于通过其他机制绑定的会话，相同的DN的所有会话会，将共享相同的连接。
            此连接池策略，可以通过 减少重复建立/断开多个连接的开销，来提高代理的效率。

            ldap数据库可以作为一个信息服务，即本地通过了身份验证的客户端 可能以某种修改的形式 声明(asserted)给远端服务器。
            出于此目的，proxy(代理)使用管理员身份绑定到远端的服务器，并且，如果需要，授权声明的(asserted)身份

            许多其他后端(Backends)和叠加层(Overlays)都大量使用它

        11.2.2. back-ldap 配置(back-ldap Configuration)
            如前所述，slapd-ldap被很多其他后端(Backends)和叠加层(Overlays)用在幕后。
                它们中的一些，仅仅提供了一些配置指令，但是管理员可以使用所有的slapd-ldap选项。
            
            例如，
                “(Translucent Proxy)半透明代理”从远程LDAP服务器检索条目，这些条目可以被定义的数据库部分覆盖，
                它只有四个特定的(translucent- directives)半透明指令，但是可以使用任何普通/正常的slapd-ldap选项进行配置。
                详见{[slapo-translucent]}。
            
            其他"(Overlays)叠加层"允许您在常规的 slapd-ldap指令之前标记指令。
            例如，slapo-chain覆盖层可以做到这一点
                “很少有特定的链覆盖(chain overlay)指令;
                然而，与ldap后端实例相关的指令可能被覆盖层(overlay)隐式实例化，当与覆盖层结合使用时，可能会假定有特殊含义。
                它们在slapd-ldap中被描述，它们也需要以chain-作为前缀。”

            在本指南的“基于推送的Replication(复制)”部分，你可能还看到了slapd-ldap的使用和描述。

            很明显，slapd-ldap后端非常灵活 并且在OpenLDAP套间中大量使用。

            以下是一个非常简单的例子，但是slapd-ldap后端的强大功能已经可以通过使用uri列表看到了:
            -----------------------------------    
            database ldap
            suffix "dc=suretecsystems,dc=com"
            rootdn "cn=slapd-ldap"
            uri ldap://localhost/ ldap://remotehost ldap://remotehost2
            -----------------------------------   
                    URI 列表以空格或逗号分隔。
                    每当响应的服务器不是列表中的第一个服务器时，都会重新排列列表，
                    并将响应的服务器移至最前端，以便在下次需要建立连接时首先与它联系。 

            使用"MirrorMode复制(MirrorMode replication)"时，此功能可用于提供一种负载均衡。
        
        11.2.3. Further Information
            略

    11.3. LDIF     
        11.3.1. 概览Overview
            slapd的 LDIF后端 是一个基本的存储后端，它以 LDIF格式 在文本文件中存储条目，并利用文件系统创建数据库的树形结构。
            它旨在作为便宜，低性能的易于使用的后端。

            当使用具有持久性存储的 cn=config动态配置数据库 时，配置数据将使用此后端存储。
                更多信息请参见slapd-config

        11.3.2. back-ldif配置(back-ldif Configuration)
            像许多其他后端一样，可以使用很少的配置行来实例化 LDIF后端：
            -----------------------------------  
            include ./schema/core.schema

            database  ldif
            directory ./ldif
            suffix    "dc=suretecsystems,dc=com"
            rootdn    "cn=LDIF,dc=suretecsystems,dc=com"
            rootpw    LDIF  
            -----------------------------------  
            如果，我们为dc=suretecsystems,dc=com添加dcObject，可以看到它是如何在文件系统的幕后添加的
            -----------------------------------
            dn: dc=suretecsystems,dc=com
            objectClass: dcObject
            objectClass: organization
            dc: suretecsystems
            o: Suretec Systems Ltd    
            -----------------------------------    
            -----------------------------------  
            ldapadd -x -H ldap://localhost:9011 -f suretec.ldif -D "cn=LDIF,dc=suretecsystems,dc=com" -w LDIF  
            -----------------------------------    
                    现在，已经将dcObject添加到目录中了

            现在，在 ./ldif/文件夹下，有如下文件
            -----------------------------------  
            # ls ./ldif
            dc=suretecsystems,dc=com.ldif  
            -----------------------------------
            我们查看下这个文件的内容
            -----------------------------------    
            # cat ldif/dc\=suretecsystems\,dc\=com.ldif

            dn: dc=suretecsystems
            objectClass: dcObject
            objectClass: organization
            dc: suretecsystems
            o: Suretec Systems Ltd.
            structuralObjectClass: organization
            entryUUID: 2134b714-e3a1-102c-9a15-f96ee263886d
            creatorsName: cn=LDIF,dc=suretecsystems,dc=com
            createTimestamp: 20080711142643Z
            entryCSN: 20080711142643.661124Z#000000#000#000000
            modifiersName: cn=LDIF,dc=suretecsystems,dc=com
            modifyTimestamp: 20080711142643Z
            -----------------------------------    
            这是使用 slapcat 等导出目录时将获得的完整格式。
        
        11.3.3. Further Information
            略
    
    11.4. LMDB
        11.4.1. 概述(Overview)
            推荐使用slapd的mdb后端作为 普通slapd数据库的主后端。
                mdb使用OpenLDAP自己的"Lightning Memory-Mapped Database（LMDB)"库来存储数据，
                并打算替换Berkeley DB后端。
            
            它像BDB后端一样支持索引，但它不使用缓存，也不需要进行调整/调优即可提供最大的搜索性能。
            和hdb一样，它也是完全分层的，并支持在常量时间内重命名子树。
        
        11.4.2. back-mdb 配置(back-mdb Configuration)
            与 BDB 后端不同，可以用很少的配置行实例化 mdb 后端：
            -----------------------------------  
            include ./schema/core.schema

            database  mdb
            directory ./mdb
            suffix    "dc=suretecsystems,dc=com"
            rootdn    "cn=mdb,dc=suretecsystems,dc=com"
            rootpw    mdb
            maxsize   1073741824  
            -----------------------------------  
                    除了最小配置所需的常规参数外，mdb后端还需要设置最大值。
                    这是数据库有望达到的最大记录(以字节为单位)。文件系统必须提供足够的可用空间以容纳此大小。  
        
        11.4.3. Further Information
            略 
        

    11.5. Metadirectory
        11.5.1. 概览Overview

            slapd的 元后端(meta backend) 对一组称为“目标”的 远程LDAP服务器执行基本的LDAP代理。
                这些服务器中包含的信息可以表示为属于单个目录信息树(DIT)。

            建议你：了解slapd-ldap后端的基本功能。
                slapd-ldap后端被设计为ldap后端的增强(版),
                这两个后端共享很多功能(实际上，它们也共享部分代码)，
            
            ldap后端：用于代理指向但个服务器的操作
            元后端(meta backend)：主要用于代理多个服务器，并可能命名上下文。

            这些特性虽然在许多场景中都很有用，但可能会给某些应用程序带来过多的开销，因此应该仔细考虑其使用。

        11.5.2. back-mate配置(back-meta Configuration)
            稍后
        11.5.3. Further Information
            略 
    

    11.6. Monitor
        11.6.1. 概览Overview

            slapd的 监视器后端(monitor backend) 不是实际的数据库；
                如果启用，它将由 slapd 自动生成并动态维护，其中包含有关守护程序的运行状态的信息。

            要检查所有监视器信息，发出一个以cn= monitor为基础的子树搜索，请求返回属性“+”和“*”。
                监视器后端主要生成操作属性，LDAP仅返回显式请求的操作属性。
                请求属性“+”是一个请求所有操作属性的扩展。

            请参阅“监控(Monitoring)”部分。


        11.6.2. back-monitor Configuration

            (monitor database)监控器数据库只能实例化一次，
                即，slapd.conf文件中只能出现一次“数据库监控器(database monitor)”。
                后缀(suffix)也自动设置为“cn=Monitor”。

            可以设置 rootdn 和 rootpw
                以下是实例化一个监视器后端(monitor backend)所需的全部：
            -----------------------------------  
            include ./schema/core.schema

            database monitor
            rootdn "cn=monitoring,cn=Monitor"
            rootpw monitoring  
            -----------------------------------    
            可以像其他任何数据库一样 将访问控制应用于此数据库，
                例如：
            ----------------------------------- 
            access to dn.subtree="cn=Monitor"
                by dn.exact="uid=Admin,dc=my,dc=org" write
                by users read
                by * none   
            -----------------------------------  

            注意：
                必须加载core.schema才能使 监视器数据库(monitor database) 正常工作。  

            小例子， 
                通过ldapsearch返回数据：
            ----------------------------------- 
            ldapsearch -x -H ldap://localhost:9011 -b 'cn=Monitor'
            # extended LDIF
            #
            # LDAPv3
            # base <cn=Monitor> with scope subtree
            # filter: (objectclass=*)
            # requesting: ALL
            #

            # Monitor
            dn: cn=Monitor
            objectClass: monitorServer
            cn: Monitor
            description: This subtree contains monitoring/managing objects.
            description: This object contains information about this server.
            description: Most of the information is held in operational attributes, which
            must be explicitly requested.

            # Backends, Monitor
            dn: cn=Backends,cn=Monitor
            objectClass: monitorContainer
            cn: Backends
            description: This subsystem contains information about available backends.   
            -----------------------------------  

            请参阅“监控(Monitoring)”部分，以获取 通过此后端获取可用信息的 完整示例。  


        11.6.3. Further Information
            略

    11.7. Null
        11.7.1. 概览Overview

            slapd的 Null后端(Null backend) 肯定是 slapd 最有用的部分：
                搜索: 返回成功，但没有条目。
                比较: 返回compareFalse。
                更新: 返回成功(除非readonly处于开启状态)，但不执行任何操作。
                除非给出了数据库选项“bind on”，否则除了rootdn之外的绑定将失败。
                slapadd和slapcat工具同样令人兴奋。

            受/dev/null 的启发。

        11.7.2. back-null配置(back-null Configuration)

            配置,
                你的slapd.conf配置文件像下面这样：
            -----------------------------------    
            database null
            suffix "cn=Nothing"
            bind on
            -----------------------------------    
                bind on意味着，你可以给这个suffix绑定任何DN和password；默认是 bind off
            
            用ldapsearch测试这个后端
            -----------------------------------  
            ldapsearch -x -H ldap://localhost:9011 -D "uid=none,cn=Nothing" -w testing -b 'cn=Nothing'
            # extended LDIF
            #
            # LDAPv3
            # base <cn=Nothing> with scope subtree
            # filter: (objectclass=*)
            # requesting: ALL
            #

            # search result
            search: 2
            result: 0 Success

            # numResponses: 1  
            -----------------------------------  
        
        11.7.3. Further Information
            略

    11.8. Passwd
        11.8.1. 概览Overview

            slapd的 PASSWD后端(PASSWD backend) 提供 系统passwd文件中 列出的用户帐户信息（默认为/etc/passwd）

            提供此后端仅用于演示目的。每个条目的 DN 为“uid=<username>,<suffix>”。
        
        11.8.2. back-passwd 配置(back-passwd Configuration)
            -----------------------------------    
            include ./schema/core.schema

            database passwd
            suffix "cn=passwd"
            -----------------------------------
            使用 ldapsearch 进行测试    
            -----------------------------------    
            ldapsearch -x -H ldap://localhost:9011 -b 'cn=passwd'
            # extended LDIF
            #
            # LDAPv3
            # base <cn=passwd> with scope subtree
            # filter: (objectclass=*)
            # requesting: ALL
            #

            # passwd
            dn: cn=passwd
            cn: passwd
            objectClass: organizationalUnit

            # root, passwd
            dn: uid=root,cn=passwd
            objectClass: person
            objectClass: uidObject
            uid: root
            cn: root
            sn: root
            description: root
        
        11.8.3. Further Information
            略
        
    
    11.9. Perl/Shell
        slapd的 Perl后端 通过将 perl解释器嵌入slapd来工作



    11.10. Relay
        11.10.1. 概览Overview
            这个slapd后端的主要目的是
                将在同一个slapd实例中运行的 数据库中定义的命名上下文 映射到 虚拟命名上下文，
                如果需要，可以使用attributeType和objectClass。
                它需要rwm覆盖(rwmo verlay)。
            此后端和上面提到的覆盖层是实验性的。
        11.10.2. back-relay配置(back-relay Configuration)
            稍后
        11.10.3. Further Information
            略

    11.11. SQL
        未看！！！

12. Overlays
    Overlays 是软件组件，
        可提供 类似于后端提供的 功能钩子，
        可以将其堆在后端调用的顶部，
        也可以作为 后端响应顶部的回调 来更改其行为。

            -----------------------------------    
            -----------------------------------    
            -----------------------------------    
            -----------------------------------    
            -----------------------------------    

                    
12. Overlays
13. Schema Specification 模式规范
14. Security Considerations 安全注意事项
17. 构造分布式目录服务(Constructing a Distributed Directory Service
18. 复制Replication
19. 维护Maintenance
20. 监视器(Monitoring)

 
            -----------------------------------    
            -----------------------------------    
            
                -----------------------------------
                -----------------------------------

            -----------------------------------
        -----------------------------------
        -----------------------------------
        -----------------------------------
        -----------------------------------

    ----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
-----------------------------------
-----------------------------------
-----------------------------------
-----------------------------------
