
--------------------------------------------------------------------------------
本文档说明：
    主要记录了 官方手册：《OpenLDAP-2.4-AdminGuide-ZH_EN.pdf》
        的阅读笔记
        官方2.4手册：https://www.openldap.org/doc/

https://www.openldap.org/doc/ 《OpenLDAP 2.4 Administrator's Guide》  OpenLDAP官方2.4版本的手册

----------------------------------------openLDAP同步原理及配置------------------------------------------
此部分忽略 

1.openLDAP同步原理
    openLDAP同步复制(简称syncrepl)机制是消费方的一个复制引擎。
        syncrepl引擎作为slapd的一个线程驻留在消费者那里；
        它建立一个消费者复制，方法是连接复制 provider进行初始化DIT，并进行定期内容拉取 及时根据内容变更来更新目录树信息。
    syncrepl 使用LDAP内容同步协议作为服务器之间同步数据所使用的协议
        有5种同步机制
        拉模式 pull-mode
            refreshOnly同步模式下
                 provider处理定期的拉请求消息
            消费者定期拉取 provider服务器的内容
        推模式 push-mode
            refreshAndPersist同步模式下
                 provider维护了 对 持久性消费者的跟踪，内容修改时发送更新
            消费者监听 provider实时发送的更新信息
    syncrepl是可扩展的

    slurpd同步机制已经废除，2.4版本后采用syncrepl机制
----------------------------------------------------------------------------------
此部分忽略 

看《Linux+UNIX+OpenLDAP实战指南.郭大勇.2016.pdf》《OpenLDAP-2.4-AdminGuide-ZH_EN.pdf》阅读RFC 
    梳理一遍概念：https://www.cnblogs.com/kevingrace/p/5773974.html 
        https://blog.csdn.net/oyym_mv/article/details/94404663
----------------------------------------------------------------------------------
此部分忽略 

暂时不做：配置docker，运行起来openLDAO的主从；
        #我们使用docker-centos7作为容器环境
        #以特权模式启动 并挂在本机的配置文件目录到docker的/home/
        docker run -d -it --rm --name=ldap  --privileged -p 80:80 -p 389:389 -p 636:636 -v /home/gos/workspace/Git_WorkAndStudy/LDAP/my_OpenLDAP_Config/:/home/ centos:7 /usr/sbin/init
        #进入容器
        docker exec -it ldap bash 
        #安装docker
        yum install -y yum-utils
        yum-config-manager \
            --add-repo \
            https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
        yum makecache fast
        yum install docker-ce docker-ce-cli containerd.io
        systemctl start docker      
        #GitHub上维护的openLDAP的docker： https://github.com/osixia/docker-openldap
        docker run -p 389:389 -p 636:636 -p 389:389 -p 80:80 --name my-openldap-container --detach osixia/openldap:1.5.0
----------------------------------------------------------------------------------

LDAP-RFC 
    http://www.faqs.org/rfcs/rfc4510.html
      LDAP: The Protocol [RFC4511]
      LDAP: Directory Information Models [RFC4512]
      LDAP: Authentication Methods and Security Mechanisms [RFC4513]
      LDAP: String Representation of Distinguished Names [RFC4514]
      LDAP: String Representation of Search Filters [RFC4515]
      LDAP: Uniform Resource Locator [RFC4516]
      LDAP: Syntaxes and Matching Rules [RFC4517]
      LDAP: Internationalized String Preparation [RFC4518]
      LDAP: Schema for User Applications [RFC4519]


----------------------------------------------------------------------------------

    OpenLDAP: 通过IP协议提供访问控制和维护分布式信息的目录信息

    每个entry
        含有一堆属性(attributes)和一个DN(a globally-unique Distinguished Name)
        DN用来引用entry
        每个属性 包含了一个type和一个或多个value;value取决于type
        DN由自身的RDN(cn或者uid)和祖先的DN共同组成
            The full DN format is described in RFC4514, "LDAP: String Representation of Distinguished Names."
    
    slapd 是个独立的守护进程，可以看作是轻量级的X.500目录服务器。

    LDAPv3在1990年代后期开发，以取代LDAPv2。

    ------------chapter 04-官网推荐的配置和安装步骤--------------------------------------------------------------
4.1. 获取和提取软件
    gunzip -c openldap-VERSION.tgz | tar xf -
    cd openldap-VERSION
    #查看发行版随附的 COPYRIGHT，LICENSE，README 和 INSTALL 文档

4.2. 必备软件
4.2.1. 传输层安全
    OpenLDAP 客户端和服务器需要安装 OpenSSL，GnuTLS 或 MozNSS TLS库 以提供传输层安全性服务。
    安装 OpenSSL，GnuTLS，or MozNSS      to provide Transport Layer Security services.                   # TLS

4.2.2. 简单身份验证和安全层
    OpenLDAP 客户端和服务器需要安装 Cyrus SASL库 以提供简单的身份验证和安全层服务。
    安装 Cyrus SASL                     to provide Simple Authentication and Security Layer services.   # SASL

4.2.3. Kerberos 身份验证服务
    OpenLDAP 客户端和服务器支持 Kerberos 身份验证服务
    安装 Kerberos                        为了提供强大的身份验证机制 

4.2.4. 数据库软件
    OpenLDAP 的slapd MDB主数据库后端 使用OpenLDAP自身附带的LMDB软件
    OpenLDAP 的slapd BDB和HDB的数据库后端 需要 Oracle Corporation的Berkeley DB

4.2.5. 多线程
    openLDAP 支持各种品种的线程

4.2.6. TCP Wrappers
    slapd 支持 TCP Wrappers(IP级别的访问控制过滤器)。
        对于包含非公共信息的服务器，建议使用 TCP Wrappers 或其他 IP级别的访问过滤器(例如 IP级别的防火墙提供的过滤器)。
            后面会讲到，对于IP级别的防控： 不推荐使用TCP Wrappers，建议使用防火墙

4.3. 运行配置
    ./configure --help      #查看可用选项
    ./configure [options] [variable=value ...]

    配置脚本还在命令行和环境中查找某些变量
            CC          C编译器
            CFLAGS      C编译选项
            CPPFLAGS    C预处理选项
            LDFLAGS     链接选项
            LIBS        库

    #举例子：
        启用 TCP Wrappers(默认没有启用)
        ./configure --enable-wrappers
        如果TCP Wrappers 头文件和库分别安装在/usr/local/include 和/usr/local/lib 中
            ./configure --enable-wrappers     \
                CPPFLAGS="-I/usr/local/include"   \
                LDFLAGS="-L/usr/local/lib -Wl,-rpath,/usr/local/lib"

4.4. 编译软件

    #运行配置脚本后，输出的最后一行应为：
        Please "make depend" to build dependencies
    否则根据 提示及具体平台 检查配置选项

    #构建依赖
    make depend

    #编译
    make

4.5. 测试软件
    #测试 如果您的配置不支持某些测试，例如复制测试，则可以跳过。
    make test

4.6. 安装软件
    #默认安装目录是 /usr/local ， 也可以在运行配置脚本时通过--prefix指定
    #安装   通常，安装需要超级用户权限
    su root -c 'make install'

    #你将在 /usr/local/etc/openldap 或者 /etc/openldap 找到slpad 的配置文件
    



    ------------chapter 05-配置 slapd--------------------------------------------------------------

5. 配置 slapd

    OpenLDAP2.3及更高版本 开始使用：运行时 动态配置引擎slapd-config(5)，
        1.完全启用 LDAP
        2.使用 标准LDAP操作(ldapmodify...) 进行管理
        3.配置数据存储在LDIF数据库中，通常在/usr/local/etc/openldap/slapd.d/ 或者/etc/openldap/slapd.d/ 目录中；
        4.允许即时更改slapd的所有配置选项，通常无需重新启动服务器即可使更改生效
    
    最新版本中已经不使用slapd.conf，使用slapd-config
        虽然目前支持slapd.conf
        但将来的版本将不支持
    通过slapd.conf配置slap将在chapter06介绍
        如何使slapd自动从slapd.conf转换为 slapd-config的信息
    
    注意：尽管 lapd-config(5)系统将其配置存储为(基于文本的)LDIF 文件，但是您绝对不要直接编辑任何LDIF文件。
        配置更改应通过LDAP操作执行，
        例如 ldapadd，ldapdelete或 ldapmodify

5.1. Configuration Layout
5.1. 配置布局

    slapd配置存储为 具有预定义schema(模式)和DIT的 特殊LDAP目录。
        有一些特定的objectClasses用于承载全局配置选项，模式定义，后端和数据库定义以及各种其他项目。
        
    slapd-config 配置树具有非常具体的结构。
        树的根名为 cn=config 并包含全局配置设置。
        其他设置包含在单独的子条目中
            Dynamically loaded modules      #module     # --enable-modules配置后才能使用该功能
            Schema definitions              #schema     # 包含了：从配置文件加载或者运行时添加的 user schema
            Backend-specific configuration              # 定义在数据库条目的子级(下一级)中
            Database-specific configuration #olcDatabase
    
    图 5.1 中显示了一个示例 配置树(configuration tree.)
                        -----------------------
                        |cn=config            |
                        |Global config options|
                        -----------------------
                                    |
                ------------------------------------------
                |                   |                    |
        ------------------   ---------------   ---------------------
        |cn=module{0}    |   |cn=schema    |   |olcDatabase={1}bdb |
        |A set of modules|   |System schema|   |A back-bdb instance|
        ------------------   ---------------   ---------------------
                                    |
                            ------------------
                            |                |
                    -------------   ---------------
                    |cn={0}core |   |cn={1}cosine |
                    |Core schema|   |COSINE schema|

    LDIF格式的配置文件，规则如下：
        以'#'字符开头的注释行将被忽略。
        如果一行以单个空格开头，则将其视为前一行的延续(即使前一行是注释)，并且会删除单个前导空格。
        各个条目由空白行分隔。

    LDIF 配置的总体布局如下：
        ----------------------------------
        # global configuration settings
        dn: cn=config
        objectClass: olcGlobal
        cn: config
        <global config settings>

        # schema definitions
        dn: cn=schema,cn=config
        objectClass: olcSchemaConfig
        cn: schema
        <system schema>

        dn: cn={X}core,cn=schema,cn=config
        objectClass: olcSchemaConfig
        cn: {X}core
        <core schema>

        # additional user-specified schema
        ...

        # backend definitions
        dn: olcBackend=<typeA>,cn=config
        objectClass: olcBackendConfig
        olcBackend: <typeA>
        <backend-specific settings>

        # database definitions
        dn: olcDatabase={X}<typeA>,cn=config
        objectClass: olcDatabaseConfig
        olcDatabase: {X}<typeA>
        <database-specific settings>

        # subsequent definitions and settings
        ...

        ----------------------------------
    
    LDAP数据库本质上是无序的。
        数字索引 {X} 
            用于在配置数据库时 强制执行一致的排序，以便保留所有排序依存关系。
            在大多数情况下，不必提供索引。它会根据条目的创建顺序自动生成。
    
    slapd 配置中使用的 大多数属性 和 objectClasses 的名称中都带有前缀“olc”( olc是 OpenLDAP Configuration的简写 )
        通常 属性 == “olc”前缀 + 旧式slapd.conf配置文件的关键字
    
    配置指令的参数：
        参数中若有空格，则用""把参数括起来
        <> 应该用实际参数替换
    
    示例配置文件，
        在/usr/local/etc/openldap 或/etc/openldap 目录中。
        /usr/local/etc/openldap/schema/ 或/etc/openldap/schema/ 目录中还提供了许多包含模式定义的文件(属性类型和对象类)。


5.2. Configuration Directives
5.2. 配置指令
    下面将从 cn=config 条目中的全局指令开始，详细介绍常用的配置指令

5.2.1. cn=config
    
--------------------------------------------------cn=config
        此条目中包含的指令通常适用于整个服务器。
        它们大多数是面向系统或面向连接的，与数据库无关。
        此条目必须具有 
            objectClass: olcGlobal

    olcIdleTimeout: <integer>
        对于空闲的客户端连接，指定几秒后强制关闭
        默认值为 0，将禁用此功能。

    olcLogLevel: <level>
        指定 调试语句 和 操作统计信息 应进行 syslog 的级别(当前记录到 syslogd LOG_LOCAL4 设备)。
        必须配置 OpenLDAP --enable-debug(默认设置)才能正常工作(两个统计级别除外，它们始终处于启用状态)。
            注意：必须已经使用--enable-debug 进行编译
       
        要显示 哪种级别对应哪种调试，调用 slapd 的时候加上-d?
            slapd -d?

        日志级别可以指定为整数或关键字。
        可以使用多个日志级别，并且这些级别是可叠加的。
        
        <level>的可能值为：
                Table 5.1: Debugging Levels
            Level	Keyword	        Description
            -1	    any	            enable all debugging                        #打开全部日志
            0	 	                no debugging                                #不包含调试信息
            1	    (0x1 trace)	    trace function calls
            2	    (0x2 packets)	debug packet handling
            4	    (0x4 args)	    heavy trace debugging
            8	    (0x8 conns)	    connection management                       #connection
            16	    (0x10 BER)	    print out packets sent and received
            32	    (0x20 filter)	search filter processing                    #filter
            64	    (0x40 config)	configuration processing
            128	    (0x80 ACL)	    access control list processing
            256	    (0x100 stats)	stats log connections/operations/results
            512	    (0x200 stats2)	stats log entries sent
            1024	(0x400 shell)	print communication with shell backends
            2048	(0x800 parse)	print entry parsing debugging
            16384	(0x4000 sync)	syncrepl consumer processing
            32768	(0x8000 none)	only messages that get logged whatever log level is set
        
        所需的日志级别 可以以 单/多个整数(十进制/十六进制),单/多个显示的名称 输入，
            组合时使用时，默认位进行了 或运算。
            例如 下面的这些都是等价的
                olcLogLevel 129
                olcLogLevel 0x81
                olcLogLevel 128 1
                olcLogLevel 0x80 0x1
                olcLogLevel acl trace            
        示例：
            olcLogLevel -1           #记录大量调试信息
            olcLogLevel conns filter #只 记录连接和搜索过滤器处理
            olcLogLevel none         #仅记录任何设置的日志级别的消息，无论级别如何；但是没有日志发生时不等同于0
            olcLogLevel stats        #默认情况下 配置 基本统计日志；如果从未定义过olcLogLevel，则不会发生任何日志记录(相当于 0 级)
    
    olcReferral: <URI>
        当 slapd 找不到本地数据库来处理请求时，指定要传回的引用(即：指定能处理此次请求的slapd server)
        如  olcReferral: ldap://root.openldap.org

    以上几个配置指令的 一个简单使用示例 Sample Entries(示例条目)如下：
        -------------
        dn: cn=config
        objectClass: olcGlobal
        cn: config
        olcIdleTimeout: 30
        olcLogLevel: Stats
        olcReferral: ldap://root.openldap.org
        -------------


-------------------------cn=module
    cn=module
        如果在配置slapd的时候 启用了对 动态加载模块 的支持,则cn=module条目 可用于指定要加载的模块集
        必须包含  objectClass: olcModuleList
    olcModuleLoad: <filename>
        指定要加载的 动态可加载模块的名称。
        文件名 可以是绝对路径名或者简单文件名
            写绝对路径名,就可以不写olcModulePath: <pathspec>
            写简单文件名,就需要写olcModulePath: <pathspec>
        将在 olcModulePath: <pathspec>指令 指定的目录中去 搜索 非绝对名称
    olcModulePath: <pathspec>
        指定目录列表,用以搜索可加载模块;
        通常，路径以冒号分隔.但也取决于操作系统.
    Sample Entries(示例条目)如下：
        -------------
        dn: cn=module{0},cn=config
        objectClass: olcModuleList
        cn: module{0}
        olcModuleLoad: /usr/local/lib/smbk5pwd.la

        dn: cn=module{1},cn=config
        objectClass: olcModuleList
        cn: module{1}
        olcModulePath: /usr/local/lib:/usr/local/lib/slapd
        olcModuleLoad: accesslog.la
        olcModuleLoad: pcache.la
        -------------
        我的目录是
            /usr/lib64/openldap/smbk5pwd.la
            /usr/lib64/:/usr/lib64/openldap/

------------------------cn=schema
    cn=schema
        条目cn=schema包含所有以 slapd 形式硬编码的模式定义
            此条目中的值由slapd生成，所以无需在配置文件中提供任何schema value
            但是仍然需要定义该条目,以作为用户定义的架构的基础，以便在其下添加。
        必须包含 objectClass: olcSchemaConfig
    
    olcAttributeTypes: <RFC4512 Attribute Type Description>
        该指令定义属性类型
        请参见 第13章 Schema Specification 
    
    olcObjectClasses: <RFC4512 Object Class Description>
        该指令定义了一个对象类
        请参见 第13章 Schema Specification 
    
    Sample Entries(示例条目)如下：
        -------------
        dn: cn=schema,cn=config
        objectClass: olcSchemaConfig
        cn: schema

        dn: cn=test,cn=schema,cn=config
        objectClass: olcSchemaConfig
        cn: test
        olcAttributeTypes: ( 1.1.1
          NAME 'testAttr'
          EQUALITY integerMatch
          SYNTAX 1.3.6.1.4.1.1466.115.121.1.27 )
        olcAttributeTypes: ( 1.1.2 NAME 'testTwo' EQUALITY caseIgnoreMatch
         SUBSTR caseIgnoreSubstringsMatch SYNTAX 1.3.6.1.4.1.1466.115.121.1.44 )
        olcObjectClasses: ( 1.1.3 NAME 'testObject'
         MAY ( testAttr $ testTwo ) AUXILIARY )
        -------------


--------------------------olcBackend
    后端参数指令(Backend-specific Directives)
        适用于相同类型的所有数据库实例，并且取决于指令，数据库指令可能会覆盖后端指令。
        必须包含 objectClass: olcBackendConfig
    olcBackend: <type> 
        该指令标志着后端声明的开始。 
        <type>应该为下表之一
                表 5.2：数据库后端
                Table 5.2: Database Backends
            Types	        Description
            bdb	        Berkeley DB transactional backend (deprecated)
            config	    Slapd configuration backend
            dnssrv	    DNS SRV backend
            hdb	        Hierarchical variant of bdb backend (deprecated)
            ldap	    Lightweight Directory Access Protocol (Proxy) backend
            ldif	    Lightweight Data Interchange Format backend
            mdb	        Memory-Mapped DB backend
            meta	    Meta Directory backend
            monitor	    Monitor backend
            passwd	    Provides read-only access to passwd(5)
            perl	    Perl Programmable backend
            shell	    Shell (extern program) backend
            sql	SQL     Programmable backend
        示例:
            olcBackend: bdb
        注意:
            没有为该条目定义其他指令。
            特定的后端类型可以为它们的特定用途定义其他属性，但是到目前为止，还没有定义。 
            因此，这些指令通常不会出现在任何实际配置中。
    Sample Entry(示例条目)如下：
        -------------
        dn: olcBackend=bdb,cn=config
        objectClass: olcBackendConfig
        olcBackend: bdb
        -------------


--------------------------数据库参数指令(Database-specific Directives)
    数据库参数指令(Database-specific Directives)
        每种类型的数据库都支持本节中的指令。
        数据库条目必须包含 objectClass: olcDatabaseConfig 
    
    olcDatabase: [{<index>}]<type>
        该指令命名一个特定的数据库实例。
        数字{<index>}用来区分相同类型的多个数据库。通常可以省略索引，而 slapd 会自动生成它。
        <type>是表5.2中列出的受支持的数据库后端类型之一或前端类型。
            (The frontend)前端是一个特殊的数据库，用于保存 应该被应用于所有其他数据库的数据库级选项。
                后续的数据库定义也可能会覆盖某些前端设置。
            (The config database)配置数据库也很特殊.
            即使未显式配置 config 和 frontend 数据库，也总是隐式创建它们，并且它们在创建其他任何数据库之前都被创建。
        示例:
            olcDatabase: bdb    #这标志着一个新的 BDB 数据库实例的开始
            olcDatabase: mdb    #这标志着一个新的 MDB 数据库实例的开始
    
    olcAccess: to <what> [ by <who> [<accesslevel>] [<control>] ]+
    功能：<who>对<what>设置<accesslevel>
        该指令允许
            一个或多个请求者(由<who>指定)
            对一组条目和/或属性(由<what>指定)的
            访问权限(由<accesslevel>指定)。
        有关基本用法，请参见本指南的 第8章 Access Control
        注意：
            如果未指定 olcAccess 指令，则默认访问控制策略是 to * by * read，允许所有用户(经过身份验证的用户和匿名用户)进行读取访问。
        注意：
            前端中定义的访问控制将附加到所有其他数据库的控制中。
    
    olcReadonly { TRUE | FALSE }
        该指令将数据库置于“只读”模式。任何修改数据库的尝试都将返回“不愿执行”错误。
        如果在consumer上设置，则仍然会发生 由syncrepl发送的修改
        默认:olcReadonly: FALSE
    
    olcRootDN: <DN>
        指定管理员DN; 
            此DN对数据库的操作将不受限制
            此DN可以引用 SASL 身份
        基于Entry的示例:   olcRootDN: cn=Manager,dc=example,dc=com
        基于SASL的示例:    olcRootDN: uid=root,cn=example.com,cn=digest-md5,cn=auth

    olcRootPW: <password>
        为olcRootDN: <DN>的DN指定密码
            示例:  olcRootPW: 123456
        可以使用slappasswd生成密码的哈希  slappasswd -s 123456
            示例:  olcRootPW: {SSHA}ePepK+E+QnYuDaUP1Fymdau9deDd0Hoe

    olcSizeLimit: <integer>
        该指令指定 从搜索操作返回的最大条目数
        默认:  olcSizeLimit: 500

    olcSuffix: <dn suffix>
        即指定：从哪个子树开始查询
        该指令指定 传递到此后端数据库执行查询的 DN 后缀。
            可以指定多个后缀行，通常每个数据库定义至少需要一个后缀行。
            (某些后端类型，例如“frontend”和“monitor”使用硬编码后缀，该后缀可能不会在配置中被覆盖。)
        示例：olcSuffix: dc=example,dc=com
            DN 以“dc=example，dc=com”结尾的查询将传递到此后端。
        注意：
            当选择要传递查询的后端时，slapd会按照配置的顺序查看每个数据库定义中的后缀值。
                如果一个数据库后缀是另一个数据库的前缀，则它必须出现在配置之后。

    olcSyncrepl
            olcSyncrepl: rid=<replica ID>
                provider=ldap[s]://<hostname>[:port]
                [type=refreshOnly|refreshAndPersist]
                [interval=dd:hh:mm:ss]
                [retry=[<retry interval> <# of retries>]+]
                searchbase=<base DN>
                [filter=<filter str>]
                [scope=sub|one|base]
                [attrs=<attr list>]
                [attrsonly]
                [sizelimit=<limit>]
                [timelimit=<limit>]
                [schemachecking=on|off]
                [bindmethod=simple|sasl]
                [binddn=<DN>]
                [saslmech=<mech>]
                [authcid=<identity>]
                [authzid=<identity>]
                [credentials=<passwd>]
                [realm=<realm>]
                [secprops=<properties>]
                [starttls=yes|critical]
                [tls_cert=<file>]
                [tls_key=<file>]
                [tls_cacert=<file>]
                [tls_cacertdir=<path>]
                [tls_reqcert=never|allow|try|demand]
                [tls_cipher_suite=<ciphers>]
                [tls_crlcheck=none|peer|all]
                [logbase=<base DN>]     
                [logfilter=<filter str>]
                [syncdata=default|accesslog|changelog]
        该指令
            将当前slapd 建立为 复制consumer站点  通过运行syncrepl复制引擎，从而将当前数据库指定为 内容 provider 的consumer。
            consumer数据库 和 provider的最新内容保持同步
        rid 
            用于标识复制consumer(cosumer)服务器中的当前 syncrepl 指令
            <replica ID>
                唯一标识当前 syncrepl 指令所描述的 syncrepl 规范
                为非负数且长度不超过三位十进制数
        provider
            provider的 LDAP URI
                指定 包含provider content的 provider站点作为LDAP URI
                这个参数指定了  可以找到provider slap instance 的 scheme host以及可选的port
                <hostname> 可以是域名或者IP 
                [:port]    端口是可选的,如果未提供<port>，则使用标准LDAP端口号(389 或 636)
                例如 ldap://provider.example.com:389 或 ldaps://192.168.1.1:636      
            请注意，syncrepl 使用 consumer启动的协议，因此其规范位于consumer上。
        
        使用 搜索规范 作为结果集 来定义 syncrepl consumer的内容 
            consumer slapd 将根据搜索规范 向  provider slapd 发送搜索请求
            搜索规范包含 searchbase , scope, filter, attrs, exattrs, attrsonly, sizelimit, timelimit 
                searchbase没有默认值，必须始终指定。
                    即：指定树根，去哪棵树下开始查找
                scope默认为 sub，
                    scope的可能值：
                        base
                        one
                        sub
                        children
                filter默认为(objectclass=*)，
                    过滤器
                attrs 默认为“*，+”以复制所有用户和操作属性，
                    指定：返回哪些属性
                attrsonly 默认情况下未设置。
                sizelimit 和 timelimit 都默认为“unlimited”，并且只能指定正整数或“unlimited”。
                    指定 从搜索操作返回的最大条目数
                    指定 slapd 响应搜索请求所花费的最大秒数(实时)
                exattrs 选项还可以用于指定应从传入条目中省略的属性。

        type
            LDAP内容同步协议有两种类型：refreshOnly 和 refreshAndPersist
            refreshOnly 
                在每个同步操作完成后的间隔时间内，周期性地重新调度下一个同步搜索操作。 （！！！！！！！！！！！！！！！！！）
                间隔由间隔参数指定,默认是1天   
                    [interval=dd:hh:mm:ss]
            refreshAndPersist
                同步搜索在 provider slapd实例中保持不变
                对 provider的进一步更新将对consumer产生“searchResultEntry”作为对持久同步搜索的搜索响应。
                （！！！！！！！！！！！！！！！！！）
        
        retry=[<retry interval> <# of retries>]
            如果复制发生错误,则consumer将根据retry参数尝试重新连接
            <重试间隔><重试次数>
                例如，retry="60 10 300 3" 
                    使消费者在前 10 次中每 60 秒重试一次，然后在接下来的 3 次中每 300 秒重试一次，然后再停止重试。
            在<重试次数>中的+表示无限次重试直到成功。

        [schemachecking=on|off]
            打开后,将在LDAP Syncconsumer(consumer)站点上强制执行模式(schema)检查
            如果将其关闭，则将在不检查schema一致性的情况下存储条目。
            默认为关闭。
        
        [binddn=<DN>]
            给出了要绑定的 DN
            该DN 对 provider数据库中的复制内容具有读权限 （！！！！！！！！！！！！！！！！！）

        [bindmethod=simple|sasl]
            是simple还是sasl,取决于连接到  providerslapd实例 时 是基于密码的简单(simple)身份验证还是使用SASL身份验证

        simple身份验证
            除非有足够的数据完整性和机密性保护(例如 TLS 或 IPsec)，否则不应使用简单身份验证。
            简单身份验证 需要指定
                binddn=<DN>             #DN
                credentials=<passwd>    #密码
        SASL身份验证
            通常建议使用 SASL 身份验证
            需要使用 saslmech=<mech> 来指定一种机制.
                根据机制可以分别使用身份验证和/或凭据 指定 身份验证身份和/或凭据
                authzid=<identity>用于指定授权身份
        
        [realm=<realm>]         指定一个特定的机制进行身份验证  ???!!!
        [secprops=<properties>] 指定Cyrus SASL安全属性
        [starttls=yes|critical] 
            starttls 指定在认证提供商之前使用 StartTLS 扩展操作来建立 TLS 会话。
                当参数是critical时 如果 StartTLS 请求失败，会话将被中止; 否则，syncrepl 会话将继续运行而没有 TLS.
            [tls_reqcert=never|allow|try|demand] 设置默认为"demand"
            其他 TLS 设置默认与主要的 slapdTLS 设置相同。

        [logbase=<base DN>]
            cn=accesslog
            cn=changelog
        [logfilter=<filter str>]
        [syncdata=default|accesslog|changelog]
            syncdata=accesslog
            syncdata=changelog
        consumer可以查询数据修改日志，而不是复制整个条目
            对于将要使用的日志,必须适当设置 [logbase=<base DN>]和[logfilter=<filter str>] 参数
                如果日志符合slapo-accesslog,则必须将 [syncdata=default|accesslog|changelog] 设置为accesslog
                如果日志符合 过时的changelog,则必须将 [syncdata=default|accesslog|changelog] 设置为changelog
                如果忽略了 [syncdata=default|accesslog|changelog] 参数或将其设置为“默认”，则将忽略日志参数


        使用 bdb，hdb 和 mdb 后端支持 syncrepl 复制机制
    
    [olcTimeLimit: <integer>]
        该指令指定了 slapd 响应搜索请求所花费的最大秒数(实时)。如果请求在此时间内未完成，则将返回: 指示超出时间限制的结果。
        默认：
            olcTimeLimit: 3600
    
    olcUpdateref: <URL>
        仅适用于副本(或 shadow) slapd 实例.
        用于指定 要返回给客户端的URL , 客户端将在副本上提交更新请求 
        如果多次指定，则提供每个 URL
        Example:
            olcUpdateref:   ldap://provider.example.net
    
    Sample Entries(示例条目)如下：
        -------------
        dn: olcDatabase=frontend,cn=config
        objectClass: olcDatabaseConfig
        objectClass: olcFrontendConfig
        olcDatabase: frontend
        olcReadOnly: FALSE
        dn: olcDatabase=config,cn=config
        objectClass: olcDatabaseConfig
        olcDatabase: config
        olcRootDN: cn=Manager,dc=example,dc=com
        -------------

上面的数据库设置和下面的数据库设置 为什么不合并在一起   ？？？？？？？？？？？？？为什么！！！
这两个配置是如何结合的 ？？？？？ 


------------------------BDB 和 HDB 数据库指令(BDB and HDB Database Directives)
    BDB 和 HDB 数据库指令
        此类别中的指令适用于 BDB 和 HDB 数据库。
            除了上面定义的通用数据库指令外，它们还用于olcDatabase 条目中。
            有关 BDB/HDB 配置指令的完整参考，请参见 slapd-bdb。
        除了objectClass: olcDatabaseConfig之外，BDB 和 HDB 数据库条目还必须分别具有 
            objectClass: olcBdbConfig 和
            objectClass: olcHdbConfig 
    olcDbDirectory: <directory>
        指定 包含数据库和相关索引的 BDB文件所在的目录
        Default:
            olcDbDirectory: /usr/local/var/openldap-data
    olcDbCachesize: <integer>
        指定由 BDB后端数据库实例 维护的内存中缓存条目 的大小。
        Default:
            olcDbCachesize: 1000
    olcDbCheckpoint: <kbyte> <min>
        指定 对BDB事务日志  进行检查点的频率
            检查点操作 会将数据库缓冲刷到磁盘，并在日志中写入检查点记录。
        检查点将会被触发 的情况：
            1.上一个检查点已经写入   <kbyte>数据   或者
            2.上一个检查点已经过去过 <min>分钟
        这两个参数默认都为零，在这种情况下，它们将被忽略。
        当<min>为非零值时，内部任务将每隔<min>分钟运行一次 以执行检查点。
        Example:
            olcDbCheckpoint: 1024 10
    olcDbConfig: <DB_CONFIG setting>
        此属性指定 要放置在 数据库目录的DB_CONFIG文件中的 配置指令。
        在服务器启动时，
            如果尚不存在DB_CONFIG文件，则将创建 DB_CONFIG 文件并将该属性中的设置写入其中。
            如果DB_CONFIG文件存在，则将读取其内容并将其显示在此属性中。
        该属性是多值的，以容纳多个配置指令。
        没有提供默认值，但是必须！在此处使用适当的设置以获得最佳的服务器性能。
            对此属性所做的任何更改都将写入 DB_CONFIG 文件中，并将导致数据库环境被重置，因此更改可以立即生效。
            如果数据库环境缓存很大，并且最近未进行检查点检查，则此重置操作可能会花费很长时间。
                建议：：在使用 LDAP Modify 更改此属性之前，建议使用 Berkeley DBdb_checkpoint 实用工具手动执行单个检查点。
        Example:
            olcDbConfig: set_cachesize 0 10485760 0
            olcDbConfig: set_lg_bsize 2097512
            olcDbConfig: set_lg_dir /var/tmp/bdb-log
            olcDbConfig: set_flags DB_LOG_AUTOREMOVE
            在此示例中：
                BDB缓存 设置为 10MB，
                BDB事务日志缓冲区的大小 设置为 2MB，
                并且事务日志文件将存储在/var/tmp/bdb-log 目录中。
                还设置了一个标志，告诉 BDB 一旦其内容已被(检查点)检查过并且不再需要它们，则删除事务日志文件
                    没有此设置，事务日志文件将继续累积，直到其他一些清除过程将其删除为止
                    但是如果删除了事务日志文件，则无法对灾难性故障进行恢复（！！！！！！！！！！！！！！！）
        理想情况下，
            BDB缓存 必须至少与数据库的工作集一样大，
            日志缓冲区的大小 应足够大以容纳大多数事务而不会溢出，
            并且日志目录必须独立于主数据库文件的物理磁盘(不在同一个物理磁盘上)。
            并且数据库目录和日志目录都应该与用于常规系统活动(例如root，boot或swap filesystems)的磁盘分开。  
    olcDbNosync: { TRUE | FALSE }
         此选项导致 磁盘数据库内容在更改后不会立即与内存更改同步。
         将此选项设置为 TRUE可能会提高性能，但会牺牲数据完整性。
         该指令与使用下面指令的效果相同
            olcDbConfig: set_flags DB_TXN_NOSYNC     
    olcDbIDLcacheSize: <integer>
        在index slots中指定 内存中索引缓存的大小。
        默认值为零。
        较大的值将加快索引条目的频繁搜索。
            最佳大小取决于数据库的数据和搜索特征，
            但是使用三倍于条目缓存大小(entry cache size)的数字是一个很好的开始。
        Example:
            olcDbIDLcacheSize: 3000
    olcDbIndex: {<attrlist> | default} [pres,eq,approx,sub,none]
        该指令指定 要为给定属性维护的 索引
        如果仅给出<attrlist>，则将保留默认索引。
        索引关键字对应于 可以在 LDAP搜索过滤器 中使用的常见匹配类型。
        Example:
            olcDbIndex: default pres,eq      ？？？？？？？？？？？？？pres索引是什么！！！
            olcDbIndex: uid
            olcDbIndex: cn,sn pres,eq,sub
            olcDbIndex: objectClass eq
                在此示例中：
                    第一行设置 默认索引集， 以 保持/维护 pres(present 存在)和eq(equality 相等)
                    第二行导致为 uid属性类型 保留/维护 默认的(pres，eq)索引集。
                    第三行导致为 cn和sn属性类型 维护pres，eq和sub(substring 子字符串) 索引
                    第四行导致为 objectClass属性类型 维护eq索引
        没有不等式匹配的索引关键字。
            通常，这些匹配不使用索引。
            但是，某些属性确实支持 基于相等性索引的 不等式匹配的 索引。
        可以将sub(substring index 子字符串索引)更明确地指定为 subinitial，subany 或 subfinal，与子字符串匹配过滤器(substring match filter)的三个可能的组件相对应。
            subinitial(子初始索引)  仅索引出现在属性值开头的子字符串。
            subfinal(子最终索引)    仅索引出现在属性值末尾的子字符串，
            subany(子任何索引)      索引出现在值中任何地方的子字符串。
        注意：
            默认情况下，为属性设置索引也会影响该属性的每个子类型。
            例如，在name属性上设置eq索引会导致 cn，sn 和从name属性继承的所有其他属性 被索引(具有name的同种索引)。
        注意：
            默认情况下，不维护任何索引。
            通常建议在 objectClass 上至少保留一个eq索引(equality index)。
                olcDbindex: objectClass eq
        应根据 数据库上最常用的搜索 配置其他索引.
            不应该为某个属性配置presence indexing，  除非该属性在数据库中很少出现,并且在目录的正常使用过程中对该属性的 presence searches 非常频繁。
            大多数应用程序不使用presence searches，因此通常presence indexing不是很有用。
        如果在 slapd 运行时更改此设置，则将运行内部任务以生成更改的索引数据。
            在索引器执行工作时，所有服务器操作都可以照常继续。
            如果在索引任务完成之前 slapd 已停止，则必须使用 slapindex 工具手动完成索引编制。
    olcDbLinearIndex: { TRUE | FALSE }
        如果设置为：TRUE，
            1. slapindex 将一次索引一个属性。
            2. 将使用整个数据库中的多次遍历分别处理每个索引属性
                当 BDB缓存 小(数据库大小 超过 BDB缓存大小)时，此选项将提高 slapindex 性能。
                当 BDB缓存 足够大时，不需要设置此选项，因为这会降低性能。
            使用此选项，slapadd 不会建立索引，并且必须使用 slapindex。
        默认设置为：FALSE，
            1. 在这种情况下，一个条目的所有索引属性将同时被处理。
            2. slapadd 会执行完全索引，因此不需要单独的 slapindex 运行。
    olcDbMode: { <octal> | <symbolic> }
        该指令指定 新创建的数据库索引文件 应具有的 文件保护模式。
            格式可以是 0600 或-rw------
        Default:
            olcDbMode: 0600            
    olcDbSearchStack: <integer>
        指定 用于 搜索过滤器评估(search filter evaluation) 的堆栈深度。
            搜索过滤器在堆栈上进行评估，以适应嵌套的 AND/OR子句。
            为每个服务器线程分配一个单独的堆栈。
            堆栈的深度决定了 无需任何额外的内存分配即可 评估过滤器的复杂程度。
            嵌套 比搜索堆栈深度 更深的过滤器 将导致为 该特定搜索操作 分配一个单独的堆栈。
                这些单独的分配可能会对服务器性能产生重大负面影响，
                但是指定过多的堆栈也将消耗大量内存。
        每次搜索 
            在32位计算机上每级使用512K字节，
            在64位计算机上每级使用1024K字节。
                单个堆栈的 512KB 大小是由编译时常量设置的，
                如果需要，可以更改此常量。必须重新编译代码才能使更改生效。
        默认堆栈深度为 16，因此在 32 位和 64 位计算机上，每个线程分别使用 8MB 或 16MB
        Default:
            olcDbSearchStack: 16
    olcDbShmKey: <integer>
        指定 共享内存BDB环境(shared memory BDB environment) 的密钥。
            如果指定了非零值，它将被用作标识 将容纳环境的 共享内存区域的键。
        默认情况下,
            BDB环境 使用 内存映射文件(memory mapped files)。
        Example:
            olcDbShmKey: 42

    
    Sample Entry(示例条目)如下：
        -------------
        dn: olcDatabase=hdb,cn=config
        objectClass: olcDatabaseConfig
        objectClass: olcHdbConfig
        olcDatabase: hdb
        olcSuffix: dc=example,dc=com
        olcDbDirectory: /usr/local/var/openldap-data
        olcDbCacheSize: 1000
        olcDbCheckpoint: 1024 10
        olcDbConfig: set_cachesize 0 10485760 0
        olcDbConfig: set_lg_bsize 2097152
        olcDbConfig: set_lg_dir /var/tmp/bdb-log
        olcDbConfig: set_flags DB_LOG_AUTOREMOVE
        olcDbIDLcacheSize: 3000
        olcDbIndex: objectClass eq
        -------------





    --------------------5.3 配置示例(Configuration Example)
    说明：
        以下是示例配置，并在其中插入解释性文字。
        它定义了两个数据库来处理 X.500 树的不同部分；
        都是 BDB 数据库实例。
        显示的行号仅供参考，不包含在实际文件中。
        
    首先，全局配置部分：
        -------------
        1. # example config file - global configuration entry
        2. dn: cn=config
        3. objectClass: olcGlobal
        4. cn: config
        5. olcReferral: ldap://root.openldap.org
        6.
        -------------
                第 1 行是注释。
                第 2-4 行将其标识为全局配置条目。
                第 5 行上的 olcReferral：指令表示，
                    对于以下定义的数据库之一而言  
                    非本地的查询将被引用到 主机root.openldap.org的标准端口(389)上运行的LDAP服务 上。
                第 6 行是空白行，指示该条目的结尾。
        -------------
        7. # internal schema
        8. dn: cn=schema,cn=config
        9. objectClass: olcSchemaConfig
        10. cn: schema
        11.
        -------------
                第 7 行是注释。
                第 8-10 行将其标识为模式子树的根。
                该条目中的实际模式定义被硬编码到slapd 中，因此此处未指定其他属性。
                第 11 行是空白行，指示该条目的结尾。
        -------------
        12. # include the core schema
        13. include: file:///usr/local/etc/openldap/schema/core.ldif
        14.
        -------------
                第 12 行是注释。
                第 13 行是一个LDIF包含指令，
                    访问核心的模式，模式定义为LDIF文件格式。
                第 14 行是空白行。
    接下来是数据库定义。
        第一个数据库是特殊的frontend(前段)数据库，其设置全局应用于所有其他数据库。
        -------------
        15. # global database parameters
        16. dn: olcDatabase=frontend,cn=config
        17. objectClass: olcDatabaseConfig
        18. olcDatabase: frontend
        19. olcAccess: to * by * read
        20.
        -------------
                第 15 行是注释。
                第 16-18 行将这个条目标识为全局数据库条目。
                第 19 行是全局访问控制。
                    它适用于所有条目(在任何适用的 数据库特定的 访问控制之后)。
                第 20 行是空白行。
    下一个条目定义配置后端。
    config backend
        -------------
        21. # set a rootpw for the config database so we can bind.
        22. # deny access to everyone else.
        23. dn: olcDatabase=config,cn=config
        24. objectClass: olcDatabaseConfig
        25. olcDatabase: config
        26. olcRootPW: {SSHA}XKYnrjvGT3wZFQrDD5040US592LxsdLy
        27. olcAccess: to * by * none
        28.
        -------------
                第 21-22 行是注释。
                第 23-25 行将此条目标识为config database(配置数据库)条目。
                第 26 行定义了此数据库的超级用户密码。(DN 默认为“cn=config”。)
                第 27 行拒绝对该数据库的所有访问，因此只有超级用户才能访问它。
                    (这已经是 config数据库上的默认访问权限。
                    这里仅列出来进行说明，并重申，
                    除非显式配置了作为超级用户进行身份验证的方法，
                    否则将无法访问config 数据库。)
                第 28 行是空白行。
    下一个条目定义一个 BDB 后端，
    BDB backend
        该后端将处理 对 树的“dc=example，dc=com”部分 中的内容的查询。
        将为几个属性维护索引，并保护 userPassword属性 免受未经授权的访问。
        -------------
        29.    # BDB definition for example.com
        30.    dn: olcDatabase=bdb,cn=config
        31.    objectClass: olcDatabaseConfig
        32.    objectClass: olcBdbConfig
        33.    olcDatabase: bdb
        34.    olcSuffix: dc=example,dc=com
        35.    olcDbDirectory: /usr/local/var/openldap-data
        36.    olcRootDN: cn=Manager,dc=example,dc=com
        37.    olcRootPW: secret
        38.    olcDbIndex: uid pres,eq
        39.    olcDbIndex: cn,sn pres,eq,approx,sub
        40.    olcDbIndex: objectClass eq
        41.    olcAccess: to attrs=userPassword
        42.      by self write
        43.      by anonymous auth
        44.      by dn.base="cn=Admin,dc=example,dc=com" write
        45.      by * none
        46.    olcAccess: to *
        47.      by self write
        48.      by dn.base="cn=Admin,dc=example,dc=com" write
        49.      by * read
        50.
        -------------
                第 29 行是注释。
                第 30-33 行将该条目标识为 BDB数据库 配置条目。
                第 34 行指定了要传递给该数据库进行查询的 DN后缀。
                第 35 行指定数据库文件所在的目录。
                第 36 和 37 行标识数据库超级用户和相关密码。该条目不受访问控制，大小，时间限制的限制。
                第 38 行到第 40 行表示要为各种属性维护的索引。
                第 41 至 49 行指定了对该数据库中条目的访问控制。
                    对于所有适用的条目，
                            userPassword属性可由条目本身和“admin”条目 改写。
                                它可以用于身份验证/授权目的，否则不可读(即不允许匿名用户读)。
                            其他属性
                                该条目和“admin”条目均可以写入所有其他属性，
                                所有其他用户(已认证或未认证)都可以读取所有其他属性。
                第 50 行是空白行，指示该条目的结尾。
    下一个条目定义另一个 BDB 数据库。
    another BDB database
        该查询处理涉及dc=example，dc=net子树，
            但由 与第一个数据库相同的实体 管理。
        注意：如果没有第60行的话，由于第 19 行的全局访问规则，将允许所有读访问。
        -------------
        51.    # BDB definition for example.net
        52.    dn: olcDatabase=bdb,cn=config
        53.    objectClass: olcDatabaseConfig
        54.    objectClass: olcBdbConfig
        55.    olcDatabase: bdb
        56.    olcSuffix: dc=example,dc=net
        57.    olcDbDirectory: /usr/local/var/openldap-data-net
        58.    olcRootDN: cn=Manager,dc=example,dc=com
        59.    olcDbIndex: objectClass eq
        60.    olcAccess: to * by users read
        -------------





    --------------------5.4 将老的slapd.conf配置文件转换为cn=config格式(Converting old style slapd.conf(5) file to cn=config format)
    前提：
        配置好config backend的rootDN和rootPW，因为默认是无法访问的
    
    如果你还未准备好拥有一个database config section，那么在slapd.conf文件的末尾添加如下内容
        database config
        rootpw VerySecret

    注意：由于 config backend 可将任意代码加载到slapd进程中，
            因此 警惕谁可以访问它 非常重要。
        由于简单密码容易受到密码猜测攻击的而变得脆弱，
            因此最好省略rootpw，
            仅配置 rootDN ，并使用 SASL 进行身份验证。
        
        #转换
        slaptest -f /usr/local/etc/openldap/slapd.conf -F /usr/local/etc/openldap/slapd.d
        #验证
        ldapsearch -x -D cn=config -w VerySecret -b cn=config
        然后您可以丢弃旧的 slapd.conf文件

        注意：从slapd.conf文件转换为slapd.d格式时，包含的所有文件也将集成到生成的配置数据库中。



    --------------------chapter 6 slapd.conf配置文件(了解 ，算是对前一章所学的回顾)
    slapd.conf文件已经被废弃
        除非你的站点 仅仅只需要一个后端 并且你的站点没有更新(无法运行最新的slapd-config系统)
        通常存在于 /usr/local/etc/openldap目录下 ，可以通过slapd的命令行指定文件路径
    slapd.conf文件  
        包含三种类型的配置信息：全局，特定于后端，特定于数据库
            首先指定全局信息，然后指定特定于后端类型的信息，然后指定特定于数据库实例的信息
            全局指令可以被后端指令/数据库指令覆盖 ， 后端指令可以被数据库指令覆盖
        空行和注释(以'#'开头)被忽略；
        若某行以空格开头，则此行是前一行的延续。
    slapd.conf文件的一般格式如下：
        -------------
        # global configuration directives
        <global config directives>

        # backend definition
        backend <typeA>
        <backend-specific directives>

        # first database definition & config directives
        database <typeA>
        <database-specific directives>

        # second database definition & config directives
        database <typeB>
        <database-specific directives>

        # second database definition & config directives
        database <typeA>
        <database-specific directives>

        # subsequent backend & database definitions & config directives
        ...
        -------------
                配置指令可以携带参数，以空格隔开
                    如果参数包含空格，则应该将参数用双引号括起来
                    如果参数包含双引号和反斜杠，则应该在字符前加上反斜杠
                发行版
                    携带了一个示例配置文件在/usr/local/etc/openldap 目录中
                    提供了很多包含模式定义的文件在/usr/local/etc/openldap/schema 目录中
    详细介绍常用的配置文件指令，完整列表参看第5章
        本节将配置文件指令分为全局，特定于后端和特定于数据的，描述每个指令及其默认值(如果有)，并给出其用法示例。
        全局指令
            本节中的指令适用于所有后端和数据库，除非在后端或数据库定义中明确覆盖了这些指令，应由实际文本替换 <>
            access to <what> [ by <who> [<accesslevel>] [<control>] ]+
                该指令允许一个或多个请求者(由<who>指定)对一组条目和/或属性(由<what>指定)的访问权限(由<accesslevel>指定)。
                和 olcAccess: to <what> [ by <who> [<accesslevel>] [<control>] ]+ 功能相同，不再赘述
                详见第8章access control
            attributetype <RFC4512 Attribute Type Description>
                该指令定义属性类型
                和olcAttributeTypes: <RFC4512 Attribute Type Description>功能相同，不再赘述
            idletimeout <integer>
                强制关闭空闲的客户端连接之前要等待的秒数，默认情况下，为 0 将禁用此功能。
                和olcIdleTimeout: <integer>功能相同，不再赘述
            include <filename>
                该指令指定 slapd 在继续当前文件的下一行之前，应从给定文件中读取其他配置信息。
                    包含的文件应遵循正常的 slapd 配置文件格式。
                    注意：使用此指令时要小心-嵌套 include 指令的数量没有限制，并且不会执行循环检测。
            loglevel <level>
                指定 调试语句 和 操作统计信息 应进行 syslog 的级别(当前记录到 syslogd LOG_LOCAL4 设备)。
                和olcLogLevel: <level>功能相同，不再赘述
            objectclass <RFC4512 Object Class Description>
                该指令定义了一个对象类
                和olcObjectClasses: <RFC4512 Object Class Description>功能相同，不再赘述
            referral <URI>
                当 slapd 找不到本地数据库来处理请求时，指定要传回的引用
                如  olcReferral: ldap://root.openldap.org
                和olcReferral: <URI>功能相同，不再赘述
            sizelimit <integer>
                该指令指定 从搜索操作返回的最大条目数
                和olcSizeLimit: <integer>功能相同，不再赘述
            timelimit <integer>
                和[olcTimeLimit: <integer>]功能相同，不再赘述
                该指令指定了 slapd 响应搜索请求所花费的最大秒数(实时)。如果请求在此时间内未完成，则将返回: 指示超出时间限制的结果。
        一般后端指令
            本节中的指令仅适用于定义它们的后端。
                每种类型的后端都支持它们
                后端指令适用于相同类型的所有数据库实例，并且数据库指令可能会覆盖后端指令
            backend <type>
                该指令标志着后端声明的开始。 
                <type>应该为后端类型之一
                和olcBackend: <type> 功能相同，不再赘述 
        一般数据库指令
            本节中的指令仅适用于定义它们的数据库。
                每种类型的数据库都支持它们。
            database <type>
                该指令标志着数据库实例声明的开始
                和olcDatabase: [{<index>}]<type>功能相同，不再赘述
            limits <selector> <limit> [<limit> [...]]
                根据操作的发起者或基本 DN 指定时间和大小限制。
            readonly { on | off }
                该指令将数据库置于“只读”模式。任何修改数据库的尝试都将返回“不愿执行”错误。
                如果在consumer上设置，则仍然会发生由 syncrepl 发送的修改
                和olcReadonly { TRUE | FALSE }功能相同，不再赘述
            rootdn <DN>
                指定管理员DN; 此DN对数据库的操作将不受限制
                和olcRootDN: <DN>功能相同，不再赘述
            rootpw <password>
                为olcRootDN: <DN>的DN指定密码
                和olcRootPW: <password>功能相同，不再赘述
            suffix <dn suffix>
                该指令指定 传递到此后端数据库执行查询的 DN 后缀。
                和olcSuffix: <dn suffix>功能相同，不再赘述
            syncrepl
                该指令
                    将当前slapd 建立为 复制consumer站点  通过运行syncrepl复制引擎，从而将当前数据库指定为 内容 provider 的consumer。
                    consumer数据库 和 provider的最新内容保持同步
                和olcSyncrepl功能相同，不再赘述
            updateref <URL>
                仅适用于副本(或 shadow) slapd 实例.
                用于指定 要返回给客户端的URL , 客户端将在副本上提交更新请求
                和olcUpdateref: <URL>功能相同，不再赘述
        BDB 和 HDB 数据库指令
            directory <directory>
                指定 包含数据库和相关索引的 BDB文件所在的目录
                和olcDbDirectory: <directory>功能相同，不再赘述
    slapd.conf配置文件示例
        首先，全局配置部分：
        -------------
        1.    # example config file - global configuration section
        2.    include /usr/local/etc/schema/core.schema
        3.    referral ldap://root.openldap.org
        4.    access to * by * read
        -------------
                第 1 行是注释。
                第 2 行包含另一个包含核心模式定义的配置文件。
                第 3 行上的“referral”意味着，以下定义的数据库之一 不在本地的查询 则转到root.openldap.org 的标准端口(389)上运行的 LDAP 服务中。
                第 4 行是全局访问控制。它适用于所有条目(在任何适用的数据库特定的访问控制之后)。
        下一部分定义了一个 BDB 后端，该后端将处理对树的“dc=example，dc=com”部分中内容的查询。
            该数据库将被复制到两个副本 slapd 中，一个在 truelies，另一个在judgmentday。
            将为几个属性维护索引，并保护 userPassword 属性免受未经授权的访问。            
        -------------
        5.    # BDB definition for the example.com
        6.    database bdb
        7.    suffix "dc=example,dc=com"
        8.    directory /usr/local/var/openldap-data
        9.    rootdn "cn=Manager,dc=example,dc=com"
        10.    rootpw secret
        11.    # indexed attribute definitions
        12.    index uid pres,eq
        13.    index cn,sn pres,eq,approx,sub
        14.    index objectClass eq
        15.    # database access control definitions
        16.    access to attrs=userPassword
        17.        by self write
        18.        by anonymous auth
        19.        by dn.base="cn=Admin,dc=example,dc=com" write
        20.        by * none
        21.    access to *
        22.        by self write
        23.        by dn.base="cn=Admin,dc=example,dc=com" write
        24.        by * read
        -------------
                第 5 行是注释。
                第 6 行上的 database 关键字标记了数据库定义的开始。
                第 7 行指定了将查询传递到此数据库的 DN 后缀。
                第 8 行指定数据库文件所在的目录。
                第 9 和 10 行标识数据库超级用户和相关密码。该条目不受访问控制或大小或时间限制的限制。
                第 12 到 14 行表示各种属性要维护的索引。
                第 16 至 24 行指定对此数据库中条目的访问控制。
                    对于所有适用的条目，
                        userPassword 属性
                            可由条目本身和“admin”条目写入。用于身份验证/授权目的，验证不通过则不可读。
                        其他属性
                            该条目和“admin”条目均可以写入所有其他属性，所有用户(已认证或未认证)都可以读取所有其他属性。
        下一部分定义了另一个 BDB 数据库。
            该查询处理涉及 dc=example,dc=net子树的查询，但由与第一个数据库相同的实体管理。
            请注意，如果没有第 39 行，则由于第4 行有全局访问规则，因此将允许读访问。
        -------------
        33.    # BDB definition for example.net
        34.    database bdb
        35.    suffix "dc=example,dc=net"
        36.    directory /usr/local/var/openldap-data-net
        37.    rootdn "cn=Manager,dc=example,dc=com"
        38.    index objectClass eq
        39.    access to * by users read
        -------------



    --------------------chapter 7 运行 slapd配置文件(Running slapd)
    slapd 作为一个独立服务运行。
        这使服务器可以利用缓存的优势，管理基础数据库的并发问题，并节省系统资源。
    slapd 支持许多命令行选项，如手册页中所述。本节详细介绍了一些常用选项。
        -f <filename>
            为slapd 指定备用配置文件
            默认为/usr/local/etc/openldap/slapd.conf
        -F <slapd-config-directory>
            指定 slapd配置目录
            默认为/usr/local/etc/openldap/slapd.d/
                    如果同时指定了-f 和-F，则将读取配置文件 并将其转换为配置目录格式 并写入指定的目录。
                    如果未指定任何选项，则 slapd 将在尝试使用默认配置文件之前尝试读取默认配置目录。
                    如果存在有效的配置目录，则默认配置文件将被忽略。
        -h <URLs>
            此选项指定替代的侦听器配置。
                默认值为 ldap:///，这意味着默认 LDAP389端口 的所有接口上使用 基于TCP的LDAP。
                您可以指定特定的host-pair对或其他协议方案(例如 ldaps://或ldapi://)。
                        URL         Protocol        Transport
                        ldap:///    LDAP            TCP port 389
                        ldaps:///   LDAP over SSL   TCP port 636
                        ldapi:///   LDAP            IPC (Unix-domain socket)
                例如，-h "ldaps:// ldap://127.0.0.1:666" 将创建两个侦听器：
                    一个侦听器用于ldaps://默认的636端口上所有接口上的(非标准)ldaps://方案，
                    另一个是在666端口上的localhost(环回)接口上用于标准 ldap://方案。
                    可以使用主机名或 IPv4 或 IPv6 地址来指定主机。端口值必须是数字。
                对于基于IPC的LDAP，可以在URL中编码 Unix 域套接字的路径名。
                    请注意，目录分隔符必须像其他任何专用于URL的字符一样，都经过 URL 编码。
                    因此套接字/usr/local/var/ldapi必须被编码为 ldapi://%2Fusr%2Flocal%2Fvar%2Fldapi
                        请注意：
                            ldapi:///传输并未得到广泛实现：非 OpenLDAP 客户端可能无法使用它。
        -n <service-name>
            此选项指定用于日志记录和其他目的的服务名称。
                默认服务名称为 slapd
        -l <syslog-local-user>
            指定 syslog 工具的本地用户。
                值可以是 LOCAL0，LOCAL1，LOCAL2，...和 LOCAL7。
                默认值为 LOCAL4。
                并非所有系统都支持此选项。
        -u user -g group
            分别指定 用户和组 以其身份运行。
                用户可以是 用户名或uid。
                组可以是 组名或gid。
        -r directory
            指定运行时目录。
                在打开侦听器之后，但在读取任何配置文件或初始化任何后端之前，slapd 会将 chroot(2)切换到该目录。
        -d <level> | ?
            项将 slapd 调试级别设置为<level>
                级别为"?"时字符，将打印各种调试级别，并退出slapd
                    在上面的  olcLogLevel: <level>  下 有个调试级别表
                注意：
                    调试级别可叠加
                注意：
                    slapd 必须已经使用--enable-debug 进行编译
    启动 slapd
        slapd 的运行方式如下：/usr/local/libexec/slapd [<option>]*
                我的slapd目录
                    [root@localhost openldap]# find / -name "slapd"
                    /etc/sysconfig/slapd
                    /usr/sbin/slapd
            其中/usr/local/libexec 由 configure 确定，而<option>是上述选项之一
            除非您指定了调试级别(包括级别 0)，否则 slapd 会自动从其控制终端ffork and detach，并在后台运行。
    停止 slapd 
        为了安全地杀死 Slapd ，你应该
            kill -INT `cat /usr/local/var/slapd.pid`  
                    我的目录是
                        [root@localhost openldap]# find / -name "slapd.pid"
                        /run/openldap/slapd.pid
                其中/usr/local/var 由配置决定
                用更粗暴的方法杀死 slapd 可能会导致信息丢失或数据库损坏。




    --------------------chapter 8. 访问控制(Access Control)
    随着越来越多的 具有不同敏感度的数据 填充目录，控制 对目录各种各样的访问权限 变得越来越重要。
        例如，目录可能包含 您需要通过合同或法律保护的机密性质的数据。
        或者，如果使用目录控制对其他服务的访问，
            则 对该目录的不适当访问可能会为您的站点安全性创建攻击途径，从而严重破坏您的资产。
        可通过两种方法配置对目录的访问，
            一种使用 slapd 配置文件，
            另一种使用 slapd-config(5)格式(配置 slapd)。
        默认的访问控制策略是允许所有客户端读取。
            无论定义了什么访问控制策略，rootdn拥有对所有内容的全部权限(即：身份验证，搜索，比较，读取和写入)。
                因此，列出rootdn的权限是没有用的(并导致性能下降)
                
    以下各节将更深入地描述访问控制列表，并给出一些示例和建议。有关完整的详细信息，请参见 slapd.access(5)
    8.2. 通过静态配置做访问控制
        对条目和属性的访问由 访问配置文件指令(access configuration file directive) 控制。通用的访问语句形式为：
                -----------------------------------
                <access directive> ::= access to <what>
                    [by <who> [<access>] [<control>] ]+
                <what> ::= * |
                    [dn[.<basic-style>]=<regex> | dn.<scope-style>=<DN>]
                    [filter=<ldapfilter>] [attrs=<attrlist>]
                <basic-style> ::= regex | exact
                <scope-style> ::= base | one | subtree | children
                <attrlist> ::= <attr> [val[.<basic-style>]=<regex>] | <attr> , <attrlist>
                <attr> ::= <attrname> | entry | children
                <who> ::= * | [anonymous | users | self
                        | dn[.<basic-style>]=<regex> | dn.<scope-style>=<DN>]
                    [dnattr=<attrname>]
                    [group[/<objectclass>[/<attrname>][.<basic-style>]]=<regex>]
                    [peername[.<basic-style>]=<regex>]
                    [sockname[.<basic-style>]=<regex>]
                    [domain[.<basic-style>]=<regex>]
                    [sockurl[.<basic-style>]=<regex>]
                    [set=<setspec>]
                    [aci=<attrname>]
                <access> ::= [self]{<level>|<priv>}
                <level> ::= none | disclose | auth | compare | search | read | write | manage
                <priv> ::= {=|+|-}{m|w|r|s|c|x|d|0}+
                <control> ::= [stop | continue | break]
                -----------------------------------
                        <what>部分选择   要应用访问权限的 条目和/或属性，
                        <who>部分指定    给哪些实体 授予访问权限，
                        <access>部分指定 授予访问权限。
                        支持多个<who> <access> <control>三元组，从而允许 向许多实体授予 对同一组条目和属性的 不同访问权限。
                        此处未描述所有这些访问控制选项；有关更多详细信息，请参见 slapd.access(5)手册页。
        8.2.1 访问权限控制哪些内容(What to control access to)
            <what>部分确定 把访问控制应用到哪些 条目和属性上。
                通常以两种方式选择条目：
                    通过DN 和通过filter(过滤器)。
                可以同时使用DN和filter
            -----------------------------------
                以下限定符按 DN 选择条目：
                    -----------------------------------
                    to *
                    to dn[.<basic-style>]=<regex>
                    to dn.<scope-style>=<DN>
                    -----------------------------------
                            第一种形式用于   选择 所有 条目。
                            第二种形式用于   通过 正则表达式与条目的DN进行匹配 来选择 条目。
                            第三种形式用于   选择 DN请求范围内的 条目。
                                <scope-style>
                                范围可以是 base，one，subtree 或 children。
                                base     仅匹配 具有DN的条目(仅仅DN一个)，
                                one        匹配 其父代是 DN 的条目(这个DN的第一代儿子)，
                                subtree    匹配 子树中(树的根是DN)的所有条目(DN + 这个DN的所有儿子和后代)，
                                children   匹配 DN 下的所有条目(这个DN的所有儿子和后代，但不匹配DN自己)。
                                    例如
                                    -----------------------------------
                                    0: o=suffix
                                    1: cn=Manager,o=suffix
                                    2: ou=people,o=suffix
                                    3: uid=kdz,ou=people,o=suffix
                                    4: cn=addresses,uid=kdz,ou=people,o=suffix
                                    5: uid=hyc,ou=people,o=suffix
                                    -----------------------------------
                                    则
                                    -----------------------------------
                                    dn.base="ou=people,o=suffix" match 2;
                                    dn.one="ou=people,o=suffix" match 3, and 5;
                                    dn.subtree="ou=people,o=suffix" match 2, 3, 4, and 5; 
                                    dn.children="ou=people,o=suffix" match 3, 4, and 5.
                                    -----------------------------------
                                <basic-style> ::= regex | exact
                                    regex ？？？？？
                                    exact ？？？？？
                使用filter(过滤器)选择条目
                    to filter=<ldap filter>
                        <ldap filter>是字符串，例如： to filter=(objectClass=person)
                在<what>字句中可以同时使用DN和filter 来选择条目
                    to dn.one="ou=people,o=suffix" filter=(objectClass=person)
            -----------------------------------
                attrs=<attribute list>
                    包含 逗号分隔的 属性名称列表 来选择条目中的属性
                attrs=<attribute> val[.<style>]=<regex>
                    使用 单个属性名称以及值选择器 来选择属性的特定值
                有两个特殊的伪属性项和子项。
                    要读取(并返回)目标条目，必须具有对目标条目属性的读取权限。
                    要执行搜索，必须对搜索库的条目属性具有搜索权限。
                    要添加或删除条目，必须对条目的条目属性具有写权限，并且必须对条目的父级子属性具有写权限。
                    要重命名条目，必须对条目的条目属性具有写权限，并且对旧父和新父的子属性都具有写权限。
                    本节末尾的完整示例应有助于解决问题。
                有一个特殊的条目选择器"*"
                    用于选择任何条目。
                    未提供<what>时使用 等效于"dn=.*"
        8.2.2. 赋予谁访问权限(Who to grant access to)
            <who> 标识 被授予访问权限的 一个或多个实体。
                注意：访问权限被授予“实体”而不是“条目”。
                -----------------------------------
                        able 6.3: Access Entity Specifiers(表 6.3: 访问权限实体说明符)
                Specifier	                Entities                
                *	                        All, including anonymous and authenticated users    所有用户，包括匿名用户和认证用户
                anonymous	                Anonymous (non-authenticated) users                 匿名(未认证)用户
                users	                    Authenticated users                                 通过身份验证的用户
                self	                    User associated with target entry                   与目标条目关联的用户
                dn[.<basic-style>]=<regex>	Users matching a regular expression                 匹配正则表达式的用户
                dn.<scope-style>=<DN>	    Users within scope of a DN                          一个DN范围内的用户
                -----------------------------------
                    此处DN和<what>字句中的DN 行为非常相似
                    还支持其他控制因素。
                        例如：
                            <who>可以被DN-valued属性中列出的条目所限制:
                                dnattr=<dn-valued attribute name>
                                dnattr用于对 条目的属性中列出了DN的条目 授予访问权限   ？？？？？？？？？？？？？没看懂！！！
                                    例如： 向 被列为组条目的所有者的任何人授予对组条目的访问权限
                    有些因素可能并不适合所有环境(或任何环境)     
                        例如，
                            域因子(domain factor)依赖于 IP 到域名的查找。
                            由于这些很容易被欺骗，因此应避免使用域因子。           
        8.2.3. 赋予哪些访问权限(The access to grant)
            <access>
                -----------------------------------
                    Table 6.4: Access Levels(表 6.4: 访问级别)
                Level           Privileges Description
                none =         0 no access
                disclose =     d needed for information disclosure on error
                auth =        dx needed to authenticate (bind)
                compare =    cdx needed to compare
                search =    scdx needed to apply search filters
                read =     rscdx needed to read search results
                write =   wrscdx needed to modify/rename
                manage = mwrscdx needed to manage
                -----------------------------------
                        每个级别都意味着所有较低级别的访问权限会被同时赋予。
                            例如，授予某人对某项的 写访问权限 也将授予他们读，搜索，比较，身份验证和公开访问权限。
                            但是，可以使用权限说明符来授予特定权限。
        8.2.4. 访问控制评估(Access Control Evaluation)
            --------先比较<what>
            在评估是否应授予 某些请求者 访问条目和/或属性的权限时，
                slapd将 条目和/或属性 与 配置文件中给出的<what> selectors进行比较。
            
            对于每个条目，首先应用 保存该条目的数据库中提供的访问控制(如果没有保存在任何数据库中，则应用全局访问控制)，
            然后应用全局访问指令。
                概述：对于每个条目 先应用数据库中存储的该条目的访问控制，然后应用全局的访问控制
                
            但是，在处理访问列表时，由于全局访问列表被有效地附加到每个数据库列表中，
            因此如果结果列表为非空列表，则访问列表隐式的以 access to * by * none 指令结尾。
            
            如果没有适用于后端的访问指令，则使用默认读取。
            
            (在此优先级内)按访问指令在配置文件中出现的顺序 对其进行检查。
                Slapd停在与 条目和/或属性 匹配的第一个<what> selector上。
                相应的访问指令是 一个slapd 将用来评估访问的指令。
            
            --------然后比较<who>
            接下来，slapd 按照请求出现的顺序比较 请求访问 上面选择的访问指令 的<who> selectors的实体。
            它停在 与请求者匹配的第一个<who> selector上。
                这确定了请求访问的实体 对条目和/或属性的 访问权。

            --------最后比较<access>
            最后，slapd 将所选<access>条款中授予的访问权限与客户端请求的访问权限进行比较。
                如果允许更大或相等的访问权限，则授予访问权限。
                否则，访问将被拒绝
                
            --------指令的顺序非常重要
            访问指令的评估顺序使其在配置文件中的位置很重要。
                如果就其选择的条目而言，
                    一个访问指令比另一个访问指令更具体，则它应该"首先"出现在配置文件中。（！！！！！！！！！！！！！）
                同样，
                    如果一个<who>选择器比另一个选择器更具体，则应在访问指令中排在第一位。
                下面给出的访问控制示例应有助于使这一点变得清楚。

        8.2.5. 访问控制示例(Access Control Examples)
            
            -----------------------------------
            access to * by * read
            -----------------------------------
                    此访问指令 向所有人授予读取访问权限。
            
            -----------------------------------
            access to *
                by self write
                by anonymous auth  ？？？？？？？
                by * read
            -----------------------------------
                    该指令 
                        允许用户修改其条目，
                        允许匿名者针对这些条目进行身份验证，
                        并允许所有其他人读取这些条目(其实只有验证并通过的user能read，因为禁止了匿名访问)。
                    请注意，只有第一个符合条件的<who>条款适用。
                        因此，匿名用户被授予身份验证，而不是读取权限。
                    最后一个子句也可以是“by users read”。
            
            -----------------------------------
            access to *
                by ssf=128 self write
                by ssf=64 anonymous auth
                by ssf=64 users read
            -----------------------------------
                    根据适当的保护级别来限制操作。示例显示了如何使用安全强度因子(SSF)。
                        如果已建立强度为 128 或更高的安全保护，则此指令允许用户修改自己的条目；
                        允许匿名用户进行身份验证访问；
                        在已建立 64 或更高的安全保护时，则可以进行读取访问。
                        如果客户端没有建立足够的安全保护，则将应用隐式的 by * none 条款。
            
            下面的示例显示了如何使用 样式说明符 在两个"顺序很重要!!!"的访问指令中 按DN选择条目
            -----------------------------------
            access to dn.children="dc=example,dc=com"
                by * search
            access to dn.children="dc=com"
                by * read
            -----------------------------------
                    dc=example,dc=com子树下的条目 被赋予"搜索"权限
                    dc=com子树下的条目 被授予"读取"权限； 
                        但dc=example,dc=com子树下的条目没有读取权限
                    dc=com，没有被赋予权限，因为这两个指令均不匹配DN
                        children：匹配DN的所有后代
                注意：
                    如果这些访问控制指令的顺序颠倒了，
                    那么将永远不会执行位于后面的指令语句，因为dc=example,dc=com下的条目也都在dc=com下
                注意：
                    如果 无法访问指令匹配项 或 <who>子句无法访问，则拒绝访问
                    也就是说，对指令的每次访问均以 by * none 子句结尾。
                    
            在处理访问列表时，由于全局访问列表已有效地加到每个数据库列表中，
                因此如果结果列表为非空列表，则访问列表将以隐式的 access to* by * none 结尾。
            
            如果没有适用于后端的访问指令，则使用默认读取。


            下一个示例再次显示了排序的重要性，无论是访问指令还是 by <who>子句。
                它还显示了如何使用 属性选择器 来授予对 特定属性和各种<who>选择器 的访问权限。
            -----------------------------------
                access to dn.subtree="dc=example,dc=com" attrs=homePhone
                    by self write
                    by dn.children="dc=example,dc=com" search
                    by peername.regex=IP=10\..+ read
                access to dn.subtree="dc=example,dc=com"
                    by self write
                    by dn.children="dc=example,dc=com" search
                    by anonymous auth    ？？？？？？？
            -----------------------------------
                    本示例适用于“dc=example,dc=com”子树中的所有条目的所有属性，除了homePhone属性。

                        条目可以写入自身，
                        example.com 条目下的条目可以进行搜索，
                        除了身份验证/授权(始终以匿名方式进行)之外，其他任何人都没有访问权限(暗含 by * none)。

                        homePhone属性可由该条目写入，
                        可由 example.com 下的条目搜索，
                        可由网络 10 连接的客户端可读，否则不可读(隐含 by * none)。

                    所有其他访问都被 access to * by * none 的隐式访问所拒绝。


            有时允许特定的 DN 在属性中添加或删除自身很有用。
                例如，如果您想创建一个组并允许人们从 member 属性中添加和删除他们自己的 DN，
                则可以使用如下访问指令来完成此操作：
            -----------------------------------
            access to attrs=member,entry
                by dnattr=member selfwrite   ？？？？？？？？？？？？？没看懂！！！
            -----------------------------------
                    dnattr <who> selector 表示该访问权限 适用于成员属性中列出的条目。
                    selfwrite access selector表示此类成员只能从属性中添加或删除自己的 DN，而不能从其他值中添加或删除它们。
                    需要添加条目属性，因为需要访问条目才能访问任何条目的属性。

            -----------------------------------

    8.3. 通过动态配置做访问控制(Access Control via Dynamic Configuration)
        对 slapd 条目和属性的访问由 olcAccess属性控制，
            该属性的值是访问指令的序列。
            olcAccess 配置的一般形式为：
            -----------------------------------
            olcAccess: <access directive>
            <access directive> ::= to <what>
                [by <who> [<access>] [<control>] ]+
            <what> ::= * |
                [dn[.<basic-style>]=<regex> | dn.<scope-style>=<DN>]
                [filter=<ldapfilter>] [attrs=<attrlist>]
            <basic-style> ::= regex | exact
            <scope-style> ::= base | one | subtree | children
            <attrlist> ::= <attr> [val[.<basic-style>]=<regex>] | <attr> , <attrlist>
            <attr> ::= <attrname> | entry | children
            <who> ::= * | [anonymous | users | self
                    | dn[.<basic-style>]=<regex> | dn.<scope-style>=<DN>]
                [dnattr=<attrname>]
                [group[/<objectclass>[/<attrname>][.<basic-style>]]=<regex>]
                [peername[.<basic-style>]=<regex>]
                [sockname[.<basic-style>]=<regex>]
                [domain[.<basic-style>]=<regex>]
                [sockurl[.<basic-style>]=<regex>]
                [set=<setspec>]
                [aci=<attrname>]
            <access> ::= [self]{<level>|<priv>}
            <level> ::= none | disclose | auth | compare | search | read | write | manage
            <priv> ::= {=|+|-}{m|w|r|s|c|x|d|0}+
            <control> ::= [stop | continue | break]
            -----------------------------------
                    <what>部分选择   要应用访问权限的 条目和/或属性，
                    <who>部分指定    给哪些实体 授予访问权限，
                    <access>部分指定 授予访问权限。
                    支持多个<who> <access> <control>三元组，从而允许 向许多实体授予 对同一组条目和属性的 不同访问权限。
                    此处未描述所有这些访问控制选项；有关更多详细信息，请参见 slapd.access(5)手册页。
        8.3.1 访问权限控制哪些内容(What to control access to)
            <what>部分确定 把访问控制应用到哪些 条目和属性上。
                通常以两种方式选择条目：
                    通过DN 和通过filter(过滤器)。
                可以同时使用DN和filter
            -----------------------------------
                以下限定符按 DN 选择条目：
                    -----------------------------------
                    to *
                    to dn[.<basic-style>]=<regex>
                    to dn.<scope-style>=<DN>
                    -----------------------------------
                            第一种形式用于   选择 所有 条目。
                            第二种形式用于   通过 正则表达式与条目的DN进行匹配 来选择 条目。
                            第三种形式用于   选择 DN请求范围内的 条目。
                                范围可以是 base，one，subtree 或 children。
                                base     仅匹配 具有DN的条目(仅仅DN一个)，
                                one        匹配 其父代是 DN 的条目(这个DN的第一代儿子)，
                                subtree    匹配 子树中(树的根是DN)的所有条目(DN + 这个DN的所有儿子和后代)，
                                children   匹配 DN 下的所有条目(这个DN的所有儿子和后代，但不匹配DN自己)。
                                    例如
                                    -----------------------------------
                                    0: o=suffix
                                    1: cn=Manager,o=suffix
                                    2: ou=people,o=suffix
                                    3: uid=kdz,ou=people,o=suffix
                                    4: cn=addresses,uid=kdz,ou=people,o=suffix
                                    5: uid=hyc,ou=people,o=suffix
                                    -----------------------------------
                                    则
                                    -----------------------------------
                                    dn.base="ou=people,o=suffix" match 2;
                                    dn.one="ou=people,o=suffix" match 3, and 5;
                                    dn.subtree="ou=people,o=suffix" match 2, 3, 4, and 5; 
                                    dn.children="ou=people,o=suffix" match 3, 4, and 5.
                                    -----------------------------------
                使用filter(过滤器)选择条目
                    to filter=<ldap filter>
                        <ldap filter>是字符串，例如： to filter=(objectClass=person)
                在<what>字句中可以同时使用DN和filter 来选择条目
                    to dn.one="ou=people,o=suffix" filter=(objectClass=person)
            -----------------------------------
                attrs=<attribute list>
                    包含 逗号分隔的 属性名称列表 来选择条目中的属性
                attrs=<attribute> val[.<style>]=<regex>
                    使用 单个属性名称以及值选择器 来选择属性的特定值
                有两个特殊的伪属性项和子项。
                    要读取(并返回)目标条目，必须具有对目标条目属性的读取权限。
                    要执行搜索，必须对搜索库的条目属性具有搜索权限。
                    要添加或删除条目，必须对条目的条目属性具有写权限，并且必须对条目的父级子属性具有写权限。
                    要重命名条目，必须对条目的条目属性具有写权限，并且对旧父和新父的子属性都具有写权限。
                    本节末尾的完整示例应有助于解决问题。
                有一个特殊的条目选择器"*"
                    用于选择任何条目。
                    未提供<what>时使用 等效于"dn=.*"
        8.3.2. 赋予谁访问权限(Who to grant access to)
            <who> 标识 被授予访问权限的 一个或多个实体。
                注意：访问权限被授予“实体”而不是“条目”。
                -----------------------------------
                        able 6.3: Access Entity Specifiers(表 6.3: 访问权限实体说明符)
                Specifier	                Entities                
                *	                        All, including anonymous and authenticated users    所有用户，包括匿名用户和认证用户
                anonymous	                Anonymous (non-authenticated) users                 匿名(未认证)用户
                users	                    Authenticated users                                 通过身份验证的用户
                self	                    User associated with target entry                   与目标条目关联的用户
                dn[.<basic-style>]=<regex>	Users matching a regular expression                 匹配正则表达式的用户
                dn.<scope-style>=<DN>	    Users within scope of a DN                          一个DN范围内的用户
                -----------------------------------
                    此处DN和<what>字句中的DN 行为非常相似
                    还支持其他控制因素。
                        例如：
                            <who>可以被DN-valued属性中列出的条目所限制:
                                dnattr=<dn-valued attribute name>
                                dnattr用于对 条目的属性中列出了DN的条目 授予访问权限   ？？？？？？？？？？？？？没看懂！！！
                                    例如： 向 被列为组条目的所有者的任何人授予对组条目的访问权限
                    有些因素可能并不适合所有环境(或任何环境)     
                        例如，
                            域因子(domain factor)依赖于 IP 到域名的查找。
                            由于这些很容易被欺骗，因此应避免使用域因子。 
        8.3.3. 赋予哪些访问权限(The access to grant)
            <access>
                -----------------------------------
                    Table 6.4: Access Levels(表 6.4: 访问级别)
                Level           Privileges Description
                none =         0 no access
                disclose =     d needed for information disclosure on error
                auth =        dx needed to authenticate (bind)
                compare =    cdx needed to compare
                search =    scdx needed to apply search filters
                read =     rscdx needed to read search results
                write =   wrscdx needed to modify/rename
                manage = mwrscdx needed to manage
                -----------------------------------
                        每个级别都意味着所有较低级别的访问权限会被同时赋予。
                            例如，授予某人对某项的 写访问权限 也将授予他们读，搜索，比较，身份验证和公开访问权限。
                            但是，可以使用权限说明符来授予特定权限。
        8.3.4. 访问控制评估(Access Control Evaluation)
            
            在评估是否应授予 某些请求者 访问条目和/或属性的权限时，
                slapd将 条目和/或属性 与 配置文件中给出的<what> selectors进行比较。
            
            对于每个条目，首先应用 保存该条目的数据库中提供的访问控制(如果没有保存在任何数据库中，则应用全局访问控制)，
            然后应用全局访问指令(在前端数据库定义中保存)    
                概述：对于每个条目 先应用数据库中存储的该条目的访问控制，然后应用全局的访问控制
                
            但是，在处理访问列表时，由于全局访问列表被有效地附加到每个数据库列表中，
            因此如果结果列表为非空列表，则访问列表隐式的以 access to * by * none 指令结尾。
            
            如果没有适用于后端的访问指令，则使用默认读取。
            
            (在此优先级内)按访问指令在配置文件中出现的顺序 对其进行检查。
                Slapd停在与 条目和/或属性 匹配的第一个<what> selector上。
                相应的访问指令是 一个slapd 将用来评估访问的指令。
            
            --------然后比较<who>
            接下来，slapd 按照请求出现的顺序比较 请求访问 上面选择的访问指令 的<who> selectors的实体。
            它停在 与请求者匹配的第一个<who> selector上。
                这确定了请求访问的实体 对条目和/或属性的 访问权。

            --------最后比较<access>
            最后，slapd 将所选<access>条款中授予的访问权限与客户端请求的访问权限进行比较。
                如果允许更大或相等的访问权限，则授予访问权限。
                否则，访问将被拒绝
                
            --------指令的顺序非常重要
            访问指令的评估顺序使其在配置文件中的位置很重要。
                如果就其选择的条目而言，
                    一个访问指令比另一个访问指令更具体，则它应该"首先"出现在配置文件中。
                同样，
                    如果一个<who>选择器比另一个选择器更具体，则应在访问指令中排在第一位。
                下面给出的访问控制示例应有助于使这一点变得清楚。

        8.3.5. 访问控制示例(Access Control Examples)
            
            -----------------------------------
            access to * by * read
            -----------------------------------
                    此访问指令 向所有人授予读取访问权限。
            
            -----------------------------------
            access to *
                by self write
                by anonymous auth
                by * read
            -----------------------------------
                    该指令 
                        允许用户修改其条目，
                        允许匿名者针对这些条目进行身份验证，
                        并允许所有其他人读取这些条目(其实只有验证并通过的user能read，因为禁止了匿名访问)。
                    请注意，只有第一个符合条件的<who>条款适用。
                        因此，匿名用户被授予身份验证，而不是读取权限。
                    最后一个子句也可以是“by users read”。
            
            -----------------------------------
            access to *
                by ssf=128 self write
                by ssf=64 anonymous auth
                by ssf=64 users read
            -----------------------------------
                    根据适当的保护级别来限制操作。示例显示了如何使用安全强度因子(SSF)。
                        如果已建立强度为 128 或更高的安全保护，则此指令允许用户修改自己的条目；
                        允许匿名用户进行身份验证访问；
                        在已建立 64 或更高的安全保护时，则可以进行读取访问。
                        如果客户端没有建立足够的安全保护，则将应用隐式的 by * none 条款。
            
            下面的示例显示了如何使用 样式说明符 在两个"顺序很重要!!!"的访问指令中 按DN选择条目
            -----------------------------------
            access to dn.children="dc=example,dc=com"
                by * search
            access to dn.children="dc=com"
                by * read
            -----------------------------------
                    dc=example,dc=com子树下的条目 被赋予"搜索"权限
                    dc=com子树下的条目 被授予"读取"权限； 
                        但dc=example,dc=com子树下的条目没有读取权限
                    dc=com，没有被赋予权限，因为这两个指令均与DN不匹配
                注意：
                    如果这些访问控制指令的顺序颠倒了，
                    那么将永远不会执行位于后面的指令语句，因为dc=example,dc=com下的条目也都在dc=com下
                注意：
                    如果 没有olcAccess: 去匹配指令 或 没有<who>子句，则拒绝访问
                    也就是说，对指令的每次访问均以 by * none 子句结尾。
                    
            在处理访问列表时，由于全局访问列表已有效地加到每个数据库列表中，
                因此如果结果列表为非空列表，则访问列表将以隐式的 access to* by * none 结尾。
            
            如果没有适用于后端的访问指令，则使用默认读取。

            下一个示例再次显示了排序的重要性，无论是访问指令还是 by <who>子句。
                它还显示了如何使用 属性选择器 来授予对 特定属性和各种<who>选择器 的访问权限。
            -----------------------------------
                access to dn.subtree="dc=example,dc=com" attrs=homePhone
                    by self write
                    by dn.children="dc=example,dc=com" search
                    by peername.regex=IP=10\..+ read
                access to dn.subtree="dc=example,dc=com"
                    by self write
                    by dn.children="dc=example,dc=com" search
                    by anonymous auth
            -----------------------------------
                    本示例适用于“dc=example,dc=com”子树中的所有条目的所有属性，除了homePhone属性。

                        一个条目可以写入自身，
                        example.com 条目下的条目可以进行搜索，
                        除了身份验证/授权(始终以匿名方式进行)之外，其他任何人都没有访问权限(暗含 by * none)。

                        homePhone属性可由该条目写入，
                        可由 example.com 下的条目搜索，
                        可由网络 10 连接的客户端可读，否则不可读(隐含 by * none)。
                    
                    所有其他访问都被 access to * by * none 的隐式访问所拒绝。


            有时允许特定的 DN 在属性中添加或删除自身很有用。
                例如，如果您想创建一个组并允许人们从 member 属性中添加和删除他们自己的 DN，
                则可以使用如下访问指令来完成此操作：
            -----------------------------------
            access to attrs=member,entry
                by dnattr=member selfwrite   ？？？？？？？？？？？？？没看懂！！！
            -----------------------------------
                    dnattr <who> selector 表示该访问权限 适用于成员属性中列出的条目。
                    selfwrite access selector表示此类成员只能从属性中添加或删除自己的 DN，而不能从其他值中添加或删除它们。
                    需要添加条目属性，因为需要访问条目才能访问任何条目的属性。


        8.3.6. 访问控制顺序(Access Control Ordering)
            olcAccess 指令的顺序对于正确评估至关重要,
            但是 LDAP 属性通常不保留其值的顺序,因此 OpenLDAP 使用自定义的扩展架构来维护这些值的固定顺序
                该排序是在每个值之前添加一个数字索引“{X}”，类似于对配置条目进行排序。
                这些索引标签由 slapd 自动维护，并且在最初定义值时无需指定。
                例如
                -----------------------------------
                olcAccess: to attrs=member,entry
                by dnattr=member selfwrite
                olcAccess: to dn.children="dc=example,dc=com"
                by * search
                olcAccess: to dn.children="dc=com"
                by * read
                -----------------------------------
                当您使用 slapcat 或 ldapsearch 读回它们时，它们将包含
                -----------------------------------
                olcAccess: {0}to attrs=member,entry
                by dnattr=member selfwrite
                olcAccess: {1}to dn.children="dc=example,dc=com"
                by * search
                olcAccess: {2}to dn.children="dc=com"
                by * read
                -----------------------------------
            当使用 ldapmodify 编辑访问规则时，数字索引可用于指定要更改的特定值。
                可以使用此索引代替实际访问值(或在实际访问值之外)。
                当管理多个访问规则时，使用此数字索引非常有帮助。
                例如，
                    如果我们需要更改上面的第二条规则以授予写访问权限而不是搜索权限，则可以尝试以下 LDIF：
                    -----------------------------------
                    changetype: modify
                    delete: olcAccess
                    olcAccess: to dn.children="dc=example,dc=com" by * search
                    -
                    add: olcAccess
                    olcAccess: to dn.children="dc=example,dc=com" by * write
                    -
                    -----------------------------------
                    但是此示例无法保证现有值保持其原始顺序，因此很可能会导致安全配置损坏。
                应使用数字索引！！！：
                    -----------------------------------
                    changetype: modify
                    delete: olcAccess
                    olcAccess: {1}
                    -
                    add: olcAccess
                    olcAccess: {1}to dn.children="dc=example,dc=com" by * write
                    -
                    -----------------------------------
                    此示例
                        删除 olcAccess 属性值＃1 中的任何规则(无论其值如何)，
                        并添加一个值＃1 的新值。结果将是
                    -----------------------------------
                    olcAccess: {0}to attrs=member,entry
                    by dnattr=member selfwrite
                    olcAccess: {1}to dn.children="dc=example,dc=com"
                    by * write
                    olcAccess: {2}to dn.children="dc=com"
                    by * read
                    -----------------------------------


    8.4. 访问控制常见示例(Access Control Common Examples)
        8.4.1. 基本 ACLs(Basic ACLs)
            -----------------------------------
            access to attrs=userPassword
            by self =xw         ？？？？？？
            by anonymous auth
            by * none
            access to *
            by self write
            by users read
            by * none
            -----------------------------------
                第一个 ACL 
                    允许用户更新(但不读取)密码，
                    匿名用户针对此属性进行身份验证，
                    以及(隐式)拒绝其他用户的所有访问。
                第二个 ACL 
                    允许用户完全访问其条目，
                    经过身份验证的用户可以读取任何内容，
                    并且(隐式)拒绝其他用户(在这种情况下为匿名用户)的所有访问。
       
        8.4.2. 匹配匿名和身份验证用户(Matching Anonymous and Authenticated users)
            
            匿名用户的 DN 为空。
                虽然可以使用 dn.exact=""或 dn.regex="^$"，但 slapd 提供了一个匿名的简写形式，应改为使用:
            -----------------------------------  
            access to *
                by anonymous none
                by * read             
            -----------------------------------  
                所有匿名(未认证)用户 没有任何权限，
                其他人有 读权限。             
            
            通过了身份验证的用户具有 DN。
                尽管 dn.regex=".+"将与任何经过身份验证的用户匹配，但 OpenLDAP 为用户提供了捷径，应该使用它：
            -----------------------------------    
                access to *
                    by users read
                    by * none
            -----------------------------------     
                此 ACL 
                    已认证用户 读权限，
                    其他用户(即匿名用户) 没有任何权限。          
            
        8.4.3. 控制 rootdn 访问(Controlling rootdn access)            

            您可以在 slapd.conf 或 slapd.d/ 中指定 rootdn ，而无需指定 rootpw。
                然后，您必须添加具有相同 dn 的实际目录条目，
                例如：
            -----------------------------------    
            dn: cn=Manager,o=MyOrganization
            cn: Manager
            sn: Manager
            objectClass: person
            objectClass: top
            userPassword: {SSHA}someSSHAdata           
            -----------------------------------   
            然后以 rootdn 身份绑定到该 DN，
                而这又需要对该条目的 DN 和 userPassword进行身份验证，
                可以通过 ACL 对其进行限制。
                例如：            
            -----------------------------------   
            access to dn.base="cn=Manager,o=MyOrganization"
                by peername.regex=127\.0\.0\.1 auth  ？？？？？auth
                by peername.regex=192\.168\.0\..* auth
                by users none
                by * none            
            -----------------------------------  
                此ACL 
                    仅允许来自 本主机和192.168.0.0/24的 rootdn 进行绑定


        8.4.4. 通过分组来管理权限(Managing access with Groups)            
            
            有几种方法可以做到这一点。这里说明了一种方法。
            请考虑以下 DIT 布局：
            -----------------------------------  
            +-dc=example,dc=com
            +---cn=administrators,dc=example,dc=com
            +---cn=fred blogs,dc=example,dc=com             
            -----------------------------------    
            组中的对象(采用 LDIF 格式)：           
            -----------------------------------   
            dn: cn=administrators,dc=example,dc=com
            cn: administrators of this region
            objectclass: groupOfNames (important for the group acl feature)
            member: cn=fred blogs,dc=example,dc=com
            member: cn=somebody else,dc=example,dc=com            
            -----------------------------------   
            然后，
                可以通过在 slapd.conf的权限指令中添加适当的 组条款 来授予对此组成员的访问权限。
                例如，            
            -----------------------------------   
            access to dn.children="dc=example,dc=com"
                by self write
                by group.exact="cn=Administrators,dc=example,dc=com" write  ？？？？？
                by * auth            
            -----------------------------------        

            可以像dn使用正则表达式(如dn.regex)去匹配dn，同样可以使用expand去匹配组名(group.expand)
                例如：
            -----------------------------------        
            access to dn.regex="(.+,)?ou=People,(dc=[^,]+,dc=[^,]+)$"
                attrs=children,entry,uid     ？？？？？children？？？？？
            by group.expand="cn=Managers,$2" write
            by users read
            by * auth       
            -----------------------------------  
            上图假设在 groupOfNames对象类的 member属性类型 中找到组成员。
                如果您需要使用其他组对象和/或其他属性类型，请使用以下 slapd.conf语法：      
                    access to <what>
                        by group/<objectclass>/<attributename>=<DN> <access>    
                    例如：   
            -----------------------------------    
            access to *
                by
                    group/organizationalRole/roleOccupant="cn=Administrator,dc=example,dc=com" write           
            -----------------------------------      
            在这种情况下，
                我们有一个 ObjectClass organizationalRole，
                其中包含 roleOccupant 属性中的管理员DN。
                例如：                                                      ？？？？？？？？？？？？？没看懂！！！
            -----------------------------------  
            dn: cn=Administrator,dc=example,dc=com
            cn: Administrator
            objectclass: organizationalRole
            roleOccupant: cn=Jane Doe,dc=example,dc=com         ？？？？？    
            ----------------------------------- 
            注意：
                指定的成员属性类型必须是 DN 或 NameAndOptionalUID 语法，
                并且指定的对象类应允许该属性类型。




        8.4.5. 授予对属性子集的访问权限(Granting access to a subset of attributes)     
            
            在ACL中指定 属性名称列表 来对一组属性授予权限
                还需要，授予条目自身的访问权限。
                还要注意，子级如何控制添加，删除和重命名条目的能力。
            -----------------------------------     
            # mail: self may write, authenticated users may read
            access to attrs=mail
            by self write
            by users read
            by * none

            # cn, sn: self my write, all may read
            access to attrs=cn,sn
            by self write
            by * read

            # immediate children: only self can add/delete entries under this entry
            access to attrs=children
            by self write

            # entry itself: self may write, all may read
            access to attrs=entry ？？？？？
            by self write
            by * read

            # other attributes: self may write, others have no access
            access to *
            by self write
            by * none          
            -----------------------------------    
                还可以指定 ObjectClass 名称，这将影响该 objectClass 所需和/或允许的所有属性。
                如何指定：
                    attrlist中以 @作为前缀 和 以！作为前缀 的名称被直接视为 objectClass 名称。
                    但是在这种情况下，访问规则会影响该 objectClass 不需要或不允许的属性。           


        8.4.6. 允许用户写入其下的所有条目(Allowing a user write to all entries below theirs)     

            -----------------------------------       
            access to dn.regex="(.+,)?(uid=[^,]+,o=Company)$"
                by dn.exact,expand="$2" write                       ？？？？？？？？？？？？？没看懂！！！
                by anonymous auth        
            -----------------------------------   
                用户可 对自己和自己的孩子 都有写权限   


        8.4.7. 允许创建条目(Allowing entry creation)     
                 

            -----------------------------------    
            o=<basedn>
                ou=domains
                    associatedDomain=<somedomain>
                        ou=users
                            uid=<someuserid>
                            uid=<someotheruserid>
                        ou=addressbooks
                            uid=<someuserid>
                                cn=<someone>
                                cn=<someoneelse>      
            -----------------------------------  
            对于另一个域<someotherdomain>：             
            -----------------------------------  
            o=<basedn>
                ou=domains
                    associatedDomain=<someotherdomain>
                        ou=users
                            uid=<someuserid>
                            uid=<someotheruserid>
                        ou=addressbooks
                            uid=<someotheruserid>
                                cn=<someone>
                                cn=<someoneelse>             
            -----------------------------------    
            如果 用户uid=<someuserid> 仅为其自己的内容创建一个条目，则可以编写如下的 ACL：           
            -----------------------------------    
            # this rule lets users of "associatedDomain=<matcheddomain>"
            # write under "ou=addressbook,associatedDomain=<matcheddomain>,ou=domains,o=<basedn>",
            # i.e. a user can write ANY entry below its domain's address book;
            # this permission is necessary, but not sufficient, the next
            # will restrict this permission further


            access to dn.regex="^ou=addressbook,associatedDomain=([^,]+),ou=domains,o=<basedn>$" attrs=children
                    by dn.regex="^uid=([^,]+),ou=users,associatedDomain=$1,ou=domains,o=<basedn>$$" write   ？？？？？
                    by * none


            # Note that above the "by" clause needs a "regex" style to make sure
            # it expands to a DN that starts with a "uid=<someuserid>" pattern
            # while substituting the associatedDomain submatch from the "what" clause.


            # This rule lets a user with "uid=<matcheduid>" of "<associatedDomain=matcheddomain>"
            # write (i.e. add, modify, delete) the entry whose DN is exactly
            # "uid=<matcheduid>,ou=addressbook,associatedDomain=<matcheddomain>,ou=domains,o=<basedn>"
            # and ANY entry as subtree of it


            access to dn.regex="^(.+,)?uid=([^,]+),ou=addressbook,associatedDomain=([^,]+),ou=domains,o=<basedn>$"
                    by dn.exact,expand="uid=$2,ou=users,associatedDomain=$3,ou=domains,o=<basedn>" write
                    by * none


            # Note that above the "by" clause uses the "exact" style with the "expand"
            # modifier because now the whole pattern can be rebuilt by means of the
            # submatches from the "what" clause, so a "regex" compilation and evaluation
            # is no longer required.    
            -----------------------------------    

        8.4.8. 访问控制中使用正则表达式的经验(Tips for using regular expressions in Access Control)     
            
            当打算使用正则表达式匹配时，请始终使用 dn.regex=<pattern>
                dn=<pattern>默认为dn.exact<pattern>
                
                要匹配至少一个字符： 请使用(.+)而不是(.*) ，因为(.*)也匹配空字符串。
                
                不要使用正则表达式进行匹配，因为 不安全且昂贵 例子：dn.regex=".*dc=example,dc=com"
                    不安全，
                        因为任何包含 dc=example,dc=com 的字符串都将匹配，而我们需要的是那些以dc=example,dc=com结尾的字符串；
                            使用 .*dc=example，dc=com$ 代替。
                    还不安全，
                        由于.*dc 那么以dc结尾的任何字符串，例如mydc 也将匹配。
                        如果您确实需要一个仅允许dc=example，dc=com 或其任何子树的正则表达式，
                            请使用^(.+,)?dc=example,dc=com$，
                            这意味着：左侧的任何内容 dc=...(如果有的话)必须以逗号结尾；
                    价格昂贵，
                        因为如果您不需要子匹配项，则可以使用范围界定，例如：dn.subtree="dc=example,dc=com"
                
                在匹配模式中包含 dc=example,dc=com
                    dn.children="dc=example,dc=com"
                从匹配模式中排除 dc=example,dc=com，或者只允许一个子级别的匹配。
                    dn.onelevel="dc=example,dc=com"
                注意：
                    1.始终在正则表达式中使用^和$
                    2.始终使用([^,]+)来表示一个 RDN
                    3.不要将rootdn添加到by子句中。因为对于以rootdn身份执行的操作，甚至不处理 ACL
                    4.使用速记, user匹配经过身份验证的用户，anonymous匹配匿名用户。
                    5.如果您需要的是范围界定和/或子字符串替换，请不要在<by>子句中使用 dn.regex；
                        使用作用域样式(例如exact, onelevel, children or subtree)，
                        并且样式修饰符扩展以引起子字符串扩展。For instance, 例如，
                            -----------------------------------    
                            access to dn.regex=".+,dc=([^,]+),dc=([^,]+)$"
                                by dn.regex="^[^,],ou=Admin,dc=$1,dc=$2$$" write
                            -----------------------------------    
                            尽管正确，但可以安全有效地替换为
                            -----------------------------------    
                            access to dn.regex=".+,(dc=[^,]+,dc=[^,]+)$"
                                by dn.onelevel,expand="ou=Admin,$1" write ？？？？？？
                            -----------------------------------    
                                    其中<what>子句中的正则表达式更紧凑，
                                    而<by>子句中的正则表达式被 具有子字符串扩展功能的 onelevel 代替。


        8.4.9. 根据安全强度因子(ssf)授予和拒绝访问(Granting and Denying access based on security strength factors (ssf))     

            可以基于安全强度因子(SSF)限制访问
            -----------------------------------  
            access to dn="cn=example,cn=edu"
                by * ssf=256 read  
            -----------------------------------    

            0(0)表示无保护，
            1 表示仅完整性保护，
            56 DES 或其他弱密码，
            112 三重 DES 和其他强密码，
            128 RC4，
            Blowfish 和其他现代强密码。

            其他可能性：
                transport_ssf=<n>
                tls_ssf=<n>
                sasl_ssf=<n>
            
            推荐 256


        8.4.10. 当事情没有按预期进行时(When things aren't working as expected)     
            例如：
            -----------------------------------  
            access to *
                by anonymous auth
            
            access to *
                by self write
            
            access to *
                by users read  
            -----------------------------------   
                您可能会认为这将允许任何用户登录，读取所有内容并在登录后更改自己的数据。
                但是在此示例中，只有登录有效，而 ldapsearch 不返回任何数据。
                原因是：
                    SLAPD会逐行通过其访问配置，并在访问规则的一部分中找到匹配项后立即停止。 
            应该写为：
            -----------------------------------   
            access to *
                by anonymous auth
                by self write
                by users read 
            -----------------------------------   
            通用规则是：“首先使用特殊访问规则，最后使用普通访问规则” 


        
    8.5. 集合-根据关系授予权限(Sets - Granting rights based on relationships)
        集合最好通过示例来说明。
        以下各节将提供一些 ACL 示例集，以助理解。

        8.5.1. 组中的组(Groups of Groups)     
            
            OpenLDAP ACL 不会在组内扩展组(不支持在组中嵌套另一个组)，
                一个组包含了另一个组作为它的成员，那么被包含的组无法拥有成员。
            例如：
            -----------------------------------    
            dn: cn=sudoadm,ou=group,dc=example,dc=com
            cn: sudoadm
            objectClass: groupOfNames
            member: uid=john,ou=people,dc=example,dc=com
            member: cn=accountadm,ou=group,dc=example,dc=com

            dn: cn=accountadm,ou=group,dc=example,dc=com
            cn: accountadm
            objectClass: groupOfNames
            member: uid=mary,ou=people,dc=example,dc=com
            -----------------------------------    
                如果我们在上述条目中使用 标准组ACL，并且允许 sudoadm组的成员在某个地方写，
                则不会包括 mary：
            -----------------------------------    
             access to dn.subtree="ou=sudoers,dc=example,dc=com"
                by group.exact="cn=sudoadm,ou=group,dc=example,dc=com" write
                by * read
            -----------------------------------    


            但是，通过集合(sets)，
                我们可以使得ACL递归，支持在组中嵌套组；
                因此，对于组中的每一成员，都可以进一步扩展了。
            ----------------------------------- 
             access to dn.subtree="ou=sudoers,dc=example,dc=com"
                by set="[cn=sudoadm,ou=group,dc=example,dc=com]/member* & user" write
                by * read   
            ----------------------------------- 
                此ACL设置表示：
                    使用 cn=sudoadm 这个 DN，检查其成员属性(其中的*表示递归)，然后将结果与经过身份验证的用户的 DN 相交。
                    如果结果为非空，则ACL视其为匹配项，并授予写访问权限。
                        首先我们得到 uid=john 这个 DN。该条目没有member属性，因此扩展在此处停止。
                        现在我们进入 cn=accountadm。这确实有一个member属性，即 uid=mary。但是 uid=mary 条目没有成员，因此我们再次在这里停止。
                        最终比较是： {"uid=john,ou=people,dc=example,dc=com","uid=mary,ou=people,dc=example,dc=com"} & user
                        因此，此set(集)将在 sudoadm 组中包括 mary，并且将允许她进行写访问。
            
            
            
        8.5.2. 没有DN语法的Group ACLs(Group ACLs without DN syntax)     
            
            传统的Group ACLs 还有上面的有关递归组的例子，都要求将 member指定为DN，而不是用户名(usernames)
            但是，通过使用sets(集合)，我们可以在Group ACLs中，使用简单名(uid 或 username)
            示例：
            -----------------------------------
            dn: cn=sudoadm,ou=group,dc=example,dc=com
            cn: sudoadm
            objectClass: posixGroup
            gidNumber: 1000
            memberUid: john    
            -----------------------------------    
                使用memeberUid定义组成员
                对于这种类型的组，我们不能使用Group ACLs，我们应该使用set ACL 进行权限的赋予
            -----------------------------------  
            access to dn.subtree="ou=sudoers,dc=example,dc=com"
                by set="[cn=sudoadm,ou=group,dc=example,dc=com]/memberUid & user/uid"
            write
                by * read  
            -----------------------------------   
                说明：
                    使用一个简单的交集(和8.5.1类似)
                        将通过身份验证的uid和组中的memberUid属性进行比较，
                        如果匹配，则交集非空，ACL将会赋予这个user写权限。 
                    这种情况下，
                        如果是mary，则不会赋予她写权限，因为她的uid没有在组的memberUid中列出。
            
            
        8.5.3. Following references     
            现在将展示一个非常强大的示例：说明我们如何使用sets(集合)
                当OpenLDAP管理员理解了本示例的含义后，he will smile！！！！

            以一个用户条目开始
            -----------------------------------    
            dn: uid=john,ou=people,dc=example,dc=com
            uid: john
            objectClass: inetOrgPerson
            givenName: John
            sn: Smith
            cn: john
            manager: uid=mary,ou=people,dc=example,dc=com
            -----------------------------------    
                    mary是john的经理(manager)
            使用sets写一个ACL：
                允许manager更新一些属性
            -----------------------------------    
            attrs=carLicense,homePhone,mobile,pager,telephoneNumber
            by self write
            by set="this/manager & user" write
            by * read
            -----------------------------------    
                在此set中，扩展为正在访问的条目，
                    因此当john的条目被访问时，“this/manager”扩展为“uid=mary,ou=people,dc=example,dc=com”。
                    如果“manager(uid=mary)”自己正在访问John的条目，ACL将匹配并授予对这些属性的写访问权。

            
            到目前为止，可以使用 dnattr 关键字获得相同的行为。
            但是，有了sets，我们可以进一步增强此 ACL。
                假设我们要允许经理的秘书也更新这些属性。这是我们的做法：
            -----------------------------------  
            access to dn.exact="uid=john,ou=people,dc=example,dc=com"
                attrs=carLicense,homePhone,mobile,pager,telephoneNumber
                by self write
                by set="this/manager & user" write
                by set="this/manager/secretary & user" write
                by * read
            -----------------------------------   
            -----------------------------------   
            DN: uid=john,ou=people,dc=example,dc=com
            uid: john
            manager: uid=mary,ou=people,dc=example,dc=com 

            DN: uid=mary,ou=people,dc=example,dc=com
            uid: john
            secretary: uid=jane,ou=people,dc=example,dc=com 

            DN: uid=jane,ou=people,dc=example,dc=com
            uid: jane
            -----------------------------------   
                    在此示例中，
                        jane是mary的秘书
                        mary是john的经理
                    整个关系由manager和secretary属性定义，它们都是distinguishedName语法(即 完整DN)
            当访问uid=john条目时，this/manager/secretary将变为uid=jane,ou=people,dc=example,dc=com
            ----------------------------------- 
                this = [uid=john,ou=people,dc=example,dc=com]
                this/manager = \
                [uid=john,ou=people,dc=example,dc=com]/manager = uid=mary,ou=people,dc=example,dc=com
                this/manager/secretary = \
                [uid=mary,ou=people,dc=example,dc=com]/secretary = uid=jane,ou=people,dc=example,dc=com   
            -----------------------------------    
            最终结果是，当 Jane 访问 John 的条目时，jane将被授予对指定属性的写访问权限。
            更好的是，这将发生在她访问的所有以 Mary 为经理的条目上。

            这一切都很酷，也很不错，但也许赋予秘书太多权力。
            也许我们需要进一步限制它。
            例如，我们只允许“执行秘书”拥有此权力：
            ----------------------------------- 
            access to dn.exact="uid=john,ou=people,dc=example,dc=com"
             attrs=carLicense,homePhone,mobile,pager,telephoneNumber
             by self write
             by set="this/manager & user" write
             by set="this/manager/secretary &
                 [cn=executive,ou=group,dc=example,dc=com]/member* &
                 user" write
             by * read   
            -----------------------------------    
                它几乎与前面的ACL相同，但是我们要求连接上来的user必须是cn=executive组中的(可能是嵌套的)
            
            
9. 限制(Limits)            
    9.1. 介绍(instruction)
        通常希望限制每个 LDAP 客户端可以消耗的服务器资源。
            OpenLDAP 提供了两组限制：
                大小限制可以限制客户端可以在单个操作中检索的条目数，
                而时间限制可以限制操作可以继续的时间长度。
            根据发起操作的人，可以给两种类型的限制赋予不同的值。
    
    9.2. 软硬限制(Soft and Hard limits)

        服务器管理员可以指定软限制和硬限制(通常一起称为管理限制)。
            可以将软限制视为默认限制值。
            普通 LDAP 用户不能超过硬限制。

        LDAP 客户端可以在发出搜索操作时指定自己的大小和时间限制
            如果客户指定了限制，则请求值和硬限制中的较低者将成为操作的限制。
            如果客户端未指定限制，则服务器将应用软限制。
        
        如果 LDAP 客户端请求的搜索返回的结果超出限制所允许的数量，
            则会出现 adminLimitExceeded 错误。
        请注意，
            即使已超过限制，服务器通常也会返回一些结果：
            此功能对于只想检查某些条目是否存在而无需查看所有条目的客户端很有用。

        rootdn 不受任何限制。


    9.3. 全局限制(Global Limits)

        服务器配置的全局部分中指定的限制用作默认值，如果数据库没有设置更具体的限制，则使用默认值。
            默认大小限制为 500 个条目，
            默认时间限制为 3600 秒。

        在 slapd.conf中，关键字是：
            sizelimit 
            timelimit
        slapd中，关键字是：
            olcSizeLimit 
            olcTimeLimit

        简单形式：将软限制和硬限制设置为相同的值：
            sizelimit {<integer>|unlimited}
            timelimit {<integer>|unlimited}

        扩展形式：允许分别设置软限制和硬限制：
            sizelimit size[.{soft|hard|unchecked}]=<integer> [...]
            timelimit time[.{soft|hard}]=<integer> [...]
                例如：sizelimit size.soft=10 size.hard=75
        
        请务必确保配置了正确的索引
            这在大型目录中非常重要，
            因为索引无法满足的搜索可能会导致服务器检查数百万个条目

    9.4. 每个数据库的限制(Per-Database Limits)
       
        每个数据库可以有一组自己的限制，这些限制可以覆盖全局限制。
            语法更加灵活，它允许将不同的限制应用于不同的实体。
            请注意，实体与条目不同：
                实体在这里用于表示启动LDAP操作的 person ID 或process
        
        slapd.conf配置中，关键字是：limits
        slapd config中，关键字是： olcLimits
        语法都是相同的：
            limits <selector> <limit> [<limit> [...]]

        可以多次指定限制条款，以将不同的限制应用于不同的启动器(initiators)。
            服务器依次检查每个子句，直到找到与该操作的发起者(initiator)或基本DN(base DN) 匹配的子句为止。
            如果找不到匹配项，则将使用全局限制。

        9.4.1. 指定限制适用于谁(Specify who the limits apply to)    
            <selector>部分，采用下表的值：
                        Table 9.1: Limits Entity Specifiers
                Specifier	                        Entities
                *	                                All, including anonymous and authenticated users
                anonymous	                        Anonymous (non-authenticated) users
                users	                            Authenticated users
                dn[.<type>][.<style>]=<pattern>]	Entry or entries within a scope that match <pattern>
                group[/oc[/at]]=<pattern>	        Members of a group
            type  可以是： self ，this
            style 可以是： exact, base, onelevel, subtree, children, regex, anonymous
        
        9.4.2. 指定时间限制(Specify time limits)  
            语法：
                time[.{soft|hard}]=<integer>
                    integer 是响应搜索请求所花费的秒数
                    如果既未指定 soft 又未指定 hard，则该值将同时用于这两个值
                        例如：limits anonymous time=27
                    unlimited可用于完全消除硬限制
                        例如：limits dn.exact="cn=anyuser,dc=example,dc=org" time.hard=unlimited

        9.4.3. 指定大小限制(Specifying size limits)    
            语法： 
                size[.{soft|hard|unchecked}]=<integer>
                    中<integer>是搜索请求时将返回 slapd 的最大条目数。
                    Soft, hard, unchecked与全局限制中含义相同


        9.4.4. 大小限制和分页结果(Size limits and Paged Results)    

            如果 LDAP 客户端将 pagedResultsControl 添加到搜索操作中，则默认使用硬大小限制
                大小限制适用于搜索中返回的条目总数，而不适用于单个页面。
            
            对于分页搜索，可能会强制执行其他大小限制。
                
                使用 size.pr 控制最大页面大小：
                    size.pr={<integer>|noEstimate|unlimited}
                        如果未显式设置大小，则<integer>是最大页面大小
                        noEstimate 在当前实现中无效，因为服务器无论如何都不返回结果大小的估计值
                        unlimited表示未限制最大页面大小
                
                使用 size.prtotal 控制分页搜索可以返回的条目总数
                    默认情况下，该限制与正常的size.hard 限制相同
                    size.prtotal={<integer>|unlimited|disabled}
                        Unlimited取消了分页搜索可以返回的条目数的限制
                        disabled可用于有选择地禁用分页结果搜索

    9.5. 限制配置的例子(Example Limit Configurations)
        9.5.1. 简单的全局限制(Simple Global Limits)
            -----------------------------------    
            sizelimit 50
            timelimit 10
            -----------------------------------    
                将搜索结果限制为50，时间限制为10秒
                这个简单的全局设置，应用于除rootdn之外的所有用户的搜索
        9.5.2. 全局软硬限制(Global Hard and Soft Limits)
            为了防止客户端进行非常低效的非索引搜索，请同时添加unchecked限制：
                sizelimit size.soft=5 size.hard=100 size.unchecked=100
        9.5.3.给特定用户更大的限制(Giving specific users larger limits)
            在全局配置中设置了适当的默认限制后，可能希望使某些用户能够检索更大的结果集。
            这是在每个数据库配置中执行此操作的方法：
            -----------------------------------    
            limits dn.exact="cn=anyuser,dc=example,dc=org" size=100000
            limits dn.exact="cn=personnel,dc=example,dc=org" size=100000
            limits dn.exact="cn=dirsync,dc=example,dc=org" size=100000
            -----------------------------------    
            通常最好避免在服务器配置中提及特定用户。
            更好的方法是给组更高的限制：
            -----------------------------------    
            limits group/groupOfNames/member="cn=bigwigs,dc=example,dc=org" size=100000
            -----------------------------------    
        9.5.4.限制谁可以分页搜索(Limiting who can do paged searches)
            可能某些应用程序需要使用分页搜索来检索的非常大的结果集，但是您不希望普通LDAP 用户使用 pagedResults 控件。
            pr 和 prtotal 限制可以帮助：
            -----------------------------------    
            limits group/groupOfNames/member="cn=dirsync,dc=example,dc=org" size.prtotal=unlimited
            limits users size.soft=5 size.hard=100 size.prtotal=disabled
            limits anonymous size.soft=2 size.hard=5 size.prtotal=disabled
            -----------------------------------    

    9.6. 更多信息(Further Information)
            有关更多信息，请参见 slapd.conf(5)，ldapsearch(1)和 slapd.access(5)


10. 数据库创建和维护工具(Database Creation and Maintenance Tools)
    如何从头来时创建一个数据库，遇到问题时如何进行故障排除。
    两种创建数据库的方法：
        1.使用LDAP在线创建(法一)
            启动slapd并使用LDAP客户端添加条目；
            适用于较小的数据库(几百或者几千个条目)
        2.使用slapd附带的可执行程序(法二)
            当你需要创建成千上万个条目，或者 确保在创建数据库时不访问数据库，
            此方法是最佳选择
            注意：并非所有的数据库类型都支持这些可执行程序
    
    10.1. (法一)通过 LDAP 创建数据库Creating a database over LDAP
        
        使用你所选的LDAP client(例如ldapadd)添加条目
            在启动slapd之前，确保你已经在配置文件中设置好了以下选项
                suffix <dn> 
                    将此设置为您要创建的子树的根的DN
                    例如：suffix "dc=example,dc=com"
                directory <directory>
                    指定一个目录，在该目录中创建索引文件
                        需要使用适当的权限创建该目录，以便 slapd 可以写入该目录
                    例如：directory /usr/local/var/openldap-data
                rootdn <dn>
                rootpw <passwd>
                    定义超级用户(root用户)
                        具有添加体条目的权限
                    例如：
                        rootdn "cn=Manager,dc=example,dc=com"
                        rootpw secret
                index {<attrlist> | default} [pres,eq,approx,sub,none]
                    确保数据库定义包含所需的索引定义(一个或多个索引选项)
                    例如：
                        index cn,sn,uid pres,eq,approx,sub
                        index objectClass eq
                            这将为cn，sn和uid属性，创建presence，equality(相等)，approximate(近似)和substring(子字符串)索引
                            为objectClass属性创建equality(相等)索引
                                注意：并非所有索引类型都适用于所有属性类型
            启动slapd，与LDAP客户端连接，开始添加条目
                创建一个entries.ldif
                -----------------------------------
                # Organization for Example Corporation
                dn: dc=example,dc=com
                objectClass: dcObject
                objectClass: organization
                dc: example
                o: Example Corporation
                description: The Example Corporation

                # Organizational Role for Directory Manager
                dn: cn=Manager,dc=example,dc=com
                objectClass: organizationalRole
                cn: Manager
                description: Directory Manager
                -----------------------------------
            然后使用命令创建这个条目：
                 ldapadd -f entries.ldif -x -D "cn=Manager,dc=example,dc=com" -w secret
    
    10.2. (法二)离线创建数据库Creating a database off-line
        使用sladp数据库工具进行离线创建
            适用于：成千上万的条目需要创建
            这些工具读取slapd配置文件和一个输入文件，并且 输入文件中的文本代表了要添加的条目
            对于支持这些工具的数据库类型，它们直接产生出数据库文件
            有一些重要的参数，确保已经设置在了 包含数据库定义的 配置文件中
                suffix <dn> 
                    将此设置为您要创建的子树的根的DN
                    例如：suffix "dc=example,dc=com"
                directory <directory>
                    指定一个目录，在该目录中创建索引文件
                        需要使用适当的权限创建该目录，以便 slapd 可以写入该目录
                    例如：directory /usr/local/var/openldap-data
                index {<attrlist> | default} [pres,eq,approx,sub,none]
                    确保数据库定义包含所需的索引定义(一个或多个索引选项)
                    例如：
                        index cn,sn,uid pres,eq,approx,sub
                        index objectClass eq
                            这将为cn，sn和uid属性，创建presence，equality(相等)，approximate(近似)和substring(子字符串)索引
                            为objectClass属性创建equality(相等)索引
                                注意：并非所有索引类型都适用于所有属性类型
        
        10.2.1. slapadd (The slapadd program)    
            配置完毕后，运行 slapadd程序来创建主数据库和关联的索引：
                slapadd -l <inputfile> -f <slapdconfigfile>
                    [-d <debuglevel>] [-n <integer>|-b <suffix>]

                    -l <inputfile>
                        指定LDIF格式的输入文件，文件包含了要以文本形式添加的条目
                    -f <slapdconfigfile>
                        指定slapd配置文件，该文件告诉我们在哪里创建索引，创建什么索引
                    -F <slapdconfdirectory>
                        指定slapd的配置目录
                            如果同时指定了-f和-F：将读取slapd配置文件，然后转换为slapd配置目录格式并写入指定目录
                                如果还指定了dryrun模式，则不会进行任何转换
                            如果未指定-f和-F中任何一个，那么在尝试使用默认配置文件之前 将尝试读取默认配置目录 
                                如果存在有效的配置目录，则默认的配置文件将被忽略
                    -d <debuglevel>
                        打开调试
                        调试级别和slapd相同【7.1节中有个 调试级别表】
                    -n <databasenumber>
                        (可选的参数)指定要修改的数据库
                            配置文件中列出的第一个数据库是1，第二个是2，以此类推
                            默认情况下，使用配置文件中的第一个数据库
                            该参数，不可以和-b一起使用
                    -b <suffix>
                        (可选的参数)指定要修改的数据库 
                            提供的suffix和数据库的suffix(后缀)进行匹配，以确定数据库号
                            不应与-n一起使用
                    

        10.2.2. slapindex(The slapindex program)
            有时可能需要重新生成索引(例如在修改 slapd.conf之后),使用 slapindex可以做到这一点
            语法： 
                slapindex -f <slapdconfigfile>
                    [-d <debuglevel>] [-n <databasenumber>|-b <suffix>]

                    -f -d -n -b选项和slapadd相同
                    slapindex根据当前数据库内容重建所有索引
        
        10.2.3. slapcat(The slapcat program)
            slapcat用于将数据库转储到LDIF文件中
                当你想对数据库进行易于理解的备份时，或者 当你要离线编辑数据库时
            语法： 
                slapcat -l <filename> -f <slapdconfigfile>
                    [-d <debuglevel>] [-n <databasenumber>|-b <suffix>]

                    -n -b选项用于在 -f指定的slapd.conf 中选择数据库
                    相应的LDIF输出写入到 标准输出 或 -l指定的文件  中

        10.3. LDIF文本条目格式(The LDIF text entry format)
            LDAP数据交换格式(LDAP Data Interchange Format (LDIF)),简称为LDIF，
                它使用简单文本格式来表示LDAP条目
            
            条目的基本形式是：
            -----------------------------------    
            # comment
            dn: <distinguished name>
            <attrdesc>: <attrvalue>
            <attrdesc>: <attrvalue>
            ...
            -----------------------------------    
                '#' :     注释
                <attrdesc>: 
                    可以是简单的属性类型，例如：cn，objectClass 
                        或者 1.2.3 (与属性类型关联的OID)
                        或者 包含诸如cn;lang_en_US或userCertificate;inary之类的选项

            以一个空格或者tab开头的行，是上一行的继续    
                -----------------------------------   
                dn: cn=Barbara J Jensen,dc=example,dc=
                 com 
                cn: Barbara J
                 Jensen 
                -----------------------------------   
            等价于 
                -----------------------------------  
                dn: cn=Barbara J Jensen,dc=example,dc=com
                cn: Barbara J Jensen  
                -----------------------------------    

            在不同的行上指定多个属性值(<attrvalue>)。例如
                -----------------------------------  
                cn: Barbara J Jensen
                cn: Babs Jensen  
                -----------------------------------    
            
            1.如果<attrvalue>包含非打印字符或以空格，冒号(':')或小于('<')开头，
                则 <attrdesc> 后跟一个双冒号("::")，并使用 base64 编码值。
                例如，值“以空格开头”将这样编码：
                    cn:: IGJlZ2lucyB3aXRoIGEgc3BhY2U=
            2.<attrvalue>
                也可以指定一个包含 属性值 的URL
                例如，从指定文件件/path/to/file.jpeg获取jpegPhoto值：
                    cn:< file:///path/to/file.jpeg
            
            在同一LDIF文件中使用空行来间隔各个条目
            下面的示例包含了3个条目：
            -----------------------------------    
            # Barbara's Entry
            dn: cn=Barbara J Jensen,dc=example,dc=com
            cn: Barbara J Jensen
            cn: Babs Jensen
            objectClass: person
            sn: Jensen

            # Bjorn's Entry
            dn: cn=Bjorn J Jensen,dc=example,dc=com
            cn: Bjorn J Jensen
            cn: Bjorn Jensen
            objectClass: person
            sn: Jensen
            # Base64 encoded JPEG photo
            jpegPhoto:: /9j/4AAQSkZJRgABAAAAAQABAAD/2wBDABALD
            A4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQ
            ERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVG

            # Jennifer's Entry
            dn: cn=Jennifer J Jensen,dc=example,dc=com
            cn: Jennifer J Jensen
            cn: Jennifer Jensen
            objectClass: person
            sn: Jensen
            # JPEG photo from file
            jpegPhoto:< file:///path/to/file.jpeg
            -----------------------------------    
                注意
                    Bjorn条目中的jpegPhoto使用base64编码，
                    Jennifer条目中的jpegPhoto从URL所指示的位置获得。

            注意： 
                每一行的结尾不要包含多余的空格



11. 后端(Backends)
    
    后端执行实际的存储和检索，以响应LDAP的请求。
        后端可以被静态编译进slapd，
        或者
        当启用模块支持后，可以动态加载后端
    
    如果你的安装使用动态模块
        需要添加相关的moduleload指令
        后端模块的通用名称是：
            back_<backend name>.la    (  ls /usr/lib64/openldap/  )
        例如，你需要加载hdb后端：
            moduleload back_hdb.la 

    11.1. Berkeley DB Backends
        11.1.1. Overview
            BDB Backends
                slapd的"hdb后端"，是一个普通的的slapd数据库后端。
                它使用Oracle Berkeley DB (BDB)包来存储数据，
                它广泛的使用索引和缓存来加速数据访问
            总结：
                "hdb后端" 使用 "BDB后端"，
                "hdb后端" 使用 "BDB后端" 来执行实际的 存储和检索
            
            hdb是原始bdb后端的变体，最初是为与 BDB 一起使用而编写的；
            hdb使用 支持重命名子树的 分层数据库布局；                   (hierarchical database layout)
            它在其他方面和bdb的行为完全相同，并且所有相同的配置选项都适用。
            总结：
                hdb是bdb的变体 但是比bdb更好 
                hdb和BDB一起配套使用

            注意：
                hdb数据库需要一个更大的idlcachesize(idl缓存)，才能获得更好的搜索性能，
                通常是cachesize (entry cache size)(缓存大小(条目缓存大小))的三倍或者更大
            
            注意：
                hdb后端已经取代了bdb后端，并且很快将不推荐使用两者，
                而推荐使用新的mdb后端。
            总结：
                推荐使用mdb 而不是hdb 也不算bdb

        11.1.2. back-bdb/back-hdb Configuration
            略
        11.1.3. Further Information
            略
    
    11.2. LDAP
        11.2.1. 概览(Overview)
            LDAP backend
            slapd的"LDAP backend"不是一个实际的数据库，
                相反 它作为一个proxy/代理  将传入请求转发给另一个LDAP服务器。
                在处理请求时，它会追踪referrals，
                    使得/以便 referrals进行完全处理，
                    而不是将referrals返回给slapd客户端
            
            连接池
            明确绑定到"back-ldap数据库"的会话 会创建它们自己与远端LDAP服务器的专用连接。
            匿名会话会和远端服务器共享一个匿名连接。
            对于通过其他机制绑定的会话，具有相同DN的所有会话，将共享相同的连接。
            此连接池策略，可以通过 减少 重复建立/断开多个连接的开销，来提高代理的效率。

            ldap数据库可以作为一个信息服务，即本地通过了身份验证的客户端 可能以某种修改的形式 声明(asserted)给远端服务器。
            出于此目的，proxy(代理)使用管理员身份绑定到远端的服务器，并且，如果需要，授权声明的(asserted)身份

            许多其他后端(Backends)和叠加层(Overlays)都大量使用它

        11.2.2. back-ldap 配置(back-ldap Configuration)
            如前所述，slapd-ldap被很多其他后端(Backends)和叠加层(Overlays)用在幕后。
                它们中的一些，仅仅提供了一些配置指令，但是管理员可以使用所有的slapd-ldap选项。
            
            例如，
                “(Translucent Proxy)半透明代理”从远程LDAP服务器检索条目，这些条目可以被定义的数据库部分覆盖，
                它只有四个特定的(translucent- directives)半透明指令，但是可以使用任何普通/正常的slapd-ldap选项进行配置。
                详见{[slapo-translucent]}。
            
            其他"(Overlays)叠加层"允许您在常规的 slapd-ldap指令之前标记指令。
            例如，slapo-chain覆盖层可以做到这一点
                “很少有特定的链覆盖(chain overlay)指令;
                然而，与ldap后端实例相关的指令可能被覆盖层(overlay)隐式实例化，当与覆盖层结合使用时，可能会假定有特殊含义。
                它们在slapd-ldap中被描述，它们也需要以chain-作为前缀。”

            在本指南的“基于推送的Replication(复制)”部分，你可能还看到了slapd-ldap的使用和描述。

            很明显，slapd-ldap后端非常灵活 并且在OpenLDAP套间中大量使用。

            以下是一个非常简单的例子，但是slapd-ldap backend的强大功能已经可以通过使用uri列表看到了:
            -----------------------------------    
            database ldap
            suffix "dc=suretecsystems,dc=com"
            rootdn "cn=slapd-ldap"
            uri ldap://localhost/ ldap://remotehost ldap://remotehost2
            -----------------------------------   
                    URI 列表以空格或逗号分隔。
                    每当响应的服务器不是列表中的第一个服务器时，都会重新排列列表，
                    并将响应的服务器移至最前端，以便在下次需要建立连接时首先与它联系。 

            使用"MirrorMode复制(MirrorMode replication)"时，此功能可用于提供一种负载均衡。
        
        总结：
            slapd-ldap 被很多Backends和Overlays用在幕后。
            slapd-ldap backend 还是很重要的
        
        11.2.3. Further Information
            略

    11.3. LDIF     
        11.3.1. 概览Overview
            slapd的 LDIF backend 是一个基本的存储后端，它以 LDIF格式 在文本文件中存储条目，并利用文件系统创建数据库的树形结构。
            它旨在作为便宜，低性能的易于使用的后端。

            当使用具有持久性存储的 cn=config动态配置数据库 时，配置数据将使用此后端存储。
                更多信息请参见slapd-config
        
        总结：
            当时用 cn=config 动态配置数据库时，会调用 LDIF backend 
                来 在文本文件中存储条目，
                并利用文件系统创建数据库的树形结构。

        11.3.2. back-ldif配置(back-ldif Configuration)
            像许多其他后端一样，可以使用很少的配置行来实例化 LDIF后端：
            -----------------------------------  
            include ./schema/core.schema

            database  ldif
            directory ./ldif
            suffix    "dc=suretecsystems,dc=com"
            rootdn    "cn=LDIF,dc=suretecsystems,dc=com"
            rootpw    LDIF  
            -----------------------------------  
            如果，我们为dc=suretecsystems,dc=com添加dcObject，可以看到它是如何在文件系统的幕后添加的
            -----------------------------------
            dn: dc=suretecsystems,dc=com
            objectClass: dcObject
            objectClass: organization
            dc: suretecsystems
            o: Suretec Systems Ltd    
            -----------------------------------    
            -----------------------------------  
            ldapadd -x -H ldap://localhost:9011 -f suretec.ldif -D "cn=LDIF,dc=suretecsystems,dc=com" -w LDIF  
            -----------------------------------    
                    现在，已经将dcObject添加到目录中了

            现在，在 ./ldif/文件夹下，有如下文件
            -----------------------------------  
            # ls ./ldif
            dc=suretecsystems,dc=com.ldif  
            -----------------------------------
            我们查看下这个文件的内容
            -----------------------------------    
            # cat ldif/dc\=suretecsystems\,dc\=com.ldif

            dn: dc=suretecsystems
            objectClass: dcObject
            objectClass: organization
            dc: suretecsystems
            o: Suretec Systems Ltd.
            structuralObjectClass: organization
            entryUUID: 2134b714-e3a1-102c-9a15-f96ee263886d
            creatorsName: cn=LDIF,dc=suretecsystems,dc=com
            createTimestamp: 20080711142643Z
            entryCSN: 20080711142643.661124Z#000000#000#000000
            modifiersName: cn=LDIF,dc=suretecsystems,dc=com
            modifyTimestamp: 20080711142643Z
            -----------------------------------    
            这是使用 slapcat 等导出目录时将获得的完整格式。
        
        11.3.3. Further Information
            略
    
    11.4. LMDB
        11.4.1. 概述(Overview)
            推荐使用slapd的mdb后端作为 普通slapd数据库的主后端。
                mdb使用OpenLDAP自己的"Lightning Memory-Mapped Database(LMDB)"库来存储数据，
                并打算替换Berkeley DB后端。
            
            它像BDB后端一样支持索引，但它不使用缓存，也不需要进行调整/调优即可提供最大的搜索性能。
            和hdb一样，它也是完全分层的，并支持在常量时间内重命名子树。
        
        11.4.2. back-mdb 配置(back-mdb Configuration)
            与 BDB 后端不同，可以用很少的配置行实例化 mdb 后端：
            -----------------------------------  
            include ./schema/core.schema

            database  mdb
            directory ./mdb
            suffix    "dc=suretecsystems,dc=com"
            rootdn    "cn=mdb,dc=suretecsystems,dc=com"
            rootpw    mdb
            maxsize   1073741824  
            -----------------------------------  
                    除了最小配置所需的常规参数外，mdb后端还需要设置最大值。
                    这是数据库有望达到的最大记录(以字节为单位)。文件系统必须提供足够的可用空间以容纳此大小。  
    总结：
        LMDB backend 正在替换掉 BDB backend
            LMDB backend 是mdb数据库的后端
            BDB backend  是bdb/hdb数据库的后端

        
        11.4.3. Further Information
            略 
        

    11.5. Metadirectory
        11.5.1. 概览Overview

            slapd的 元后端(meta backend) 对一组称为“目标”的 远程LDAP服务器执行基本的LDAP代理。
                这些服务器中包含的信息可以表示为属于单个目录信息树(DIT)。

            建议你：了解slapd-ldap后端的基本功能。
                slapd-ldap后端被设计为ldap后端的增强(版),
                这两个后端共享很多功能(实际上，它们也共享部分代码)，
            
            ldap后端：用于代理指向但个服务器的操作
            元后端(meta backend)：主要用于代理多个服务器，并可能命名上下文。

            这些特性虽然在许多场景中都很有用，但可能会给某些应用程序带来过多的开销，因此应该仔细考虑其使用。

        11.5.2. back-mate配置(back-meta Configuration)
            稍后
        11.5.3. Further Information
            略 
    

    11.6. Monitor
        11.6.1. 概览Overview

            slapd的 监视器后端(monitor backend) 不是实际的数据库；
                如果启用，它将由 slapd 自动生成并动态维护，其中包含有关守护程序的运行状态的信息。

            要检查所有监视器信息，发出一个以cn=monitor为基础的子树搜索，请求返回属性“+”和“*”。
                监视器后端主要生成操作属性，LDAP仅返回显式请求的操作属性。
                请求属性“+”是一个请求所有操作属性的扩展。

            请参阅“监控(Monitoring)”部分。
        
        总结：
            monitor backend 响应 cn=monitor的搜索


        11.6.2. back-monitor Configuration

            (monitor database)监控器数据库只能实例化一次，
                即，slapd.conf文件中只能出现一次“数据库监控器(database monitor)”。
                后缀(suffix)也自动设置为“cn=Monitor”。

            可以设置 rootdn 和 rootpw
                以下是实例化一个监视器后端(monitor backend)所需的全部：
            -----------------------------------  
            include ./schema/core.schema

            database monitor
            rootdn "cn=monitoring,cn=Monitor"
            rootpw monitoring  
            -----------------------------------    
            可以像其他任何数据库一样 将访问控制应用于此数据库，
                例如：
            ----------------------------------- 
            access to dn.subtree="cn=Monitor"
                by dn.exact="uid=Admin,dc=my,dc=org" write
                by users read
                by * none   
            -----------------------------------  

            注意：
                必须加载core.schema才能使 监视器数据库(monitor database) 正常工作。  

            小例子， 
                通过ldapsearch返回数据：
            ----------------------------------- 
            ldapsearch -x -H ldap://localhost:9011 -b 'cn=Monitor'
            # extended LDIF
            #
            # LDAPv3
            # base <cn=Monitor> with scope subtree
            # filter: (objectclass=*)
            # requesting: ALL
            #

            # Monitor
            dn: cn=Monitor
            objectClass: monitorServer
            cn: Monitor
            description: This subtree contains monitoring/managing objects.
            description: This object contains information about this server.
            description: Most of the information is held in operational attributes, which
            must be explicitly requested.

            # Backends, Monitor
            dn: cn=Backends,cn=Monitor
            objectClass: monitorContainer
            cn: Backends
            description: This subsystem contains information about available backends.   
            -----------------------------------  

            请参阅“监控(Monitoring)”部分，以获取 通过此后端获取可用信息的 完整示例。  


        11.6.3. Further Information
            略

    11.7. Null
        11.7.1. 概览Overview

            slapd的 Null后端(Null backend) 肯定是 slapd 最有用的部分：
                搜索: 返回成功，但没有条目。
                比较: 返回compareFalse。
                更新: 返回成功(除非readonly处于开启状态)，但不执行任何操作。
                除非给出了数据库选项“bind on”，否则除了rootdn之外的绑定将失败。
                slapadd和slapcat工具同样令人兴奋。

            受/dev/null 的启发。

        11.7.2. back-null配置(back-null Configuration)

            配置,
                你的slapd.conf配置文件像下面这样：
            -----------------------------------    
            database null
            suffix "cn=Nothing"
            bind on
            -----------------------------------    
                bind on意味着，你可以给这个suffix绑定任何DN和password；默认是 bind off
            
            用ldapsearch测试这个后端
            -----------------------------------  
            ldapsearch -x -H ldap://localhost:9011 -D "uid=none,cn=Nothing" -w testing -b 'cn=Nothing'
            # extended LDIF
            #
            # LDAPv3
            # base <cn=Nothing> with scope subtree
            # filter: (objectclass=*)
            # requesting: ALL
            #

            # search result
            search: 2
            result: 0 Success

            # numResponses: 1  
            -----------------------------------  
        
        11.7.3. Further Information
            略

    11.8. Passwd
        11.8.1. 概览Overview

            slapd的 PASSWD后端(PASSWD backend) 提供 系统passwd文件中 列出的用户帐户信息(默认为/etc/passwd)

            提供此后端仅用于演示目的。每个条目的 DN 为“uid=<username>,<suffix>”。
        
        11.8.2. back-passwd 配置(back-passwd Configuration)
            -----------------------------------    
            include ./schema/core.schema

            database passwd
            suffix "cn=passwd"
            -----------------------------------
            使用 ldapsearch 进行测试    
            -----------------------------------    
            ldapsearch -x -H ldap://localhost:9011 -b 'cn=passwd'
            # extended LDIF
            #
            # LDAPv3
            # base <cn=passwd> with scope subtree
            # filter: (objectclass=*)
            # requesting: ALL
            #

            # passwd
            dn: cn=passwd
            cn: passwd
            objectClass: organizationalUnit

            # root, passwd
            dn: uid=root,cn=passwd
            objectClass: person
            objectClass: uidObject
            uid: root
            cn: root
            sn: root
            description: root
        
        11.8.3. Further Information
            略
        
    
    11.9. Perl/Shell
        slapd的 Perl后端 通过将 perl解释器嵌入slapd来工作



    11.10. Relay
        11.10.1. 概览Overview
            这个slapd后端的主要目的是
                将在同一个slapd实例中运行的 数据库中定义的命名上下文 映射到 虚拟命名上下文，
                如果需要，可以使用attributeType和objectClass。
                它需要rwm覆盖(rwmo verlay)。
            此后端和上面提到的覆盖层是实验性的。
        11.10.2. back-relay配置(back-relay Configuration)
            稍后
        11.10.3. Further Information
            略

    11.11. SQL
        未看！！！

12. Overlays
    
    Overlays 是软件组件，
        可提供 类似于后端提供的 功能钩子，
        可以将其堆在后端调用的顶部，作为 后端响应顶部的回调 来更改其行为。  
    
    Overlays 
        可以静态编译到 slapd，
        或者启用模块支持后，可以动态加载它们。
    大多数 overlays仅允许在单个数据库上进行配置。

    有些也可以堆叠在前端上，以供全局使用。
        这意味着它们可以在 请求被解析和验证之后，但恰好在选择适当的数据库之前执行。
            主要目的是影响与数据库无关的操作，
            并且在某些情况下，通过 消息请求的DN 来影响数据库的选择。
    
    从本质上讲，overlays 代表了一种实现以下目的的手段：
        1.在不更改后端代码的情况下 定制现有后端行为，也不需要编写具有完整功能的新的自定义后端
        2.编写 可应用于不同后端类型的 通用功能

    如上所述，使用slapd.conf时，在任何其他数据库之前配置的 overlays 将被视为全局的。
        实际上，它们隐式堆叠在前端数据库(frontend database)的顶部。
        也可以将它们显式配置为：
        -----------------------------------    
        database frontend
        overlay <overlay name>
        -----------------------------------    
                Overlays 通常在man手册页的第 5 部分；命名约定是slapo-<overlay name>
    
    以下各节中列出并详细描述了 OpenLDAP 中所有当前的overlays

    12.1. 访问日志(Access Logging)

        12.1.1. 概览(Overview)
            
            该overlay可以记录 对另一个数据库上给定后端数据库 的访问。
            
            允许使用任意LDAP查询查看给定数据库上的所有活动，而不仅仅是将日志记录到本地纯文本文件中。
                配置选项可用于选择要记录的操作类型子集，以及自动删除日志数据库中的旧日志记录。
                日志记录与审计模式一起存储，以确保其可读性，无论是作为LDIF查看还是以raw(原始)形式查看。

            它也用于 delta-syncrepl 复制

            注意：
                Accesslog 数据库对于给定的 provider是唯一的。
                永远不要复制它。
        
        12.1.2. 配置访问日志(Access Logging Configuration)
            
            一个实现访问日志(Access Logging)的例子：
            -----------------------------------  
            database mdb         #主数据库
            suffix dc=example,dc=com
            maxsize 85899345920
            ...
            overlay accesslog    #设置主数据库上的 overlay为accesslog，来对接 accesslog的database
            logdb cn=log         # 对accesslog的database进行读写
            logops writes reads    
            logold (objectclass=person)

            database mdb        #这个mdb是 accesslog的database
            suffix cn=log       #这个database 的根
            maxsize 85899345920
            ...
            index reqStart eq
            access to *         #这个database 允许谁来获取信息
             by dn.base="cn=admin,dc=example,dc=com" read  
            -----------------------------------  

            以下是用于 delta-syncrepl复制  的示例：  
            -----------------------------------
            database mdb
            suffix cn=accesslog                     # provider的 accesslog数据库
            rootdn cn=accesslog
            maxsize 85899345920
            directory /usr/local/var/openldap-accesslog
            index default eq
            index entryCSN,objectClass,reqEnd,reqResult,reqStart,reqDN  
            -----------------------------------  

            主数据库的 Accesslog overlay定义
            ----------------------------------- 
            database mdb        
            suffix dc=example,dc=com                # provider的 主数据库
            maxsize 85899345920
            ...
            overlay accesslog                       # provider的 overlay(钩子) 钩到了 accesslog数据库
            logdb cn=accesslog
            logops writes                           #可以对accesslog database 写操作
            logsuccess TRUE
            # scan the accesslog DB every day, and purge entries older than 7 days
            logpurge 07+00:00 01+00:00              #accesslog数据库 每天扫描一次 ，并清理7天前的条目
            ----------------------------------- 

            针对 cn=accesslog 的搜索结果可能如下所示：
            -----------------------------------  
            [ghenry@suretec ghenry]# ldapsearch -x -b cn=accesslog
            # extended LDIF
            #
            # LDAPv3
            # base <cn=accesslog> with scope subtree
            # filter: (objectclass=*)
            # requesting: ALL
            #

            # accesslog
            dn: cn=accesslog
            objectClass: auditContainer
            cn: accesslog

            # 20080110163829.000004Z, accesslog
            dn: reqStart=20080110163829.000004Z,cn=accesslog
            objectClass: auditModify
            reqStart: 20080110163829.000004Z
            reqEnd: 20080110163829.000005Z
            reqType: modify
            reqSession: 196696
            reqAuthzID: cn=admin,dc=suretecsystems,dc=com
            reqDN: uid=suretec-46022f8$,ou=Users,dc=suretecsystems,dc=com
            reqResult: 0
            reqMod: sambaPwdCanChange:- ###CENSORED###
            reqMod: sambaPwdCanChange:+ ###CENSORED###
            reqMod: sambaNTPassword:- ###CENSORED###
            reqMod: sambaNTPassword:+ ###CENSORED###
            reqMod: sambaPwdLastSet:- ###CENSORED###
            reqMod: sambaPwdLastSet:+ ###CENSORED###
            reqMod: entryCSN:= 20080110163829.095157Z#000000#000#000000
            reqMod: modifiersName:= cn=admin,dc=suretecsystems,dc=com
            reqMod: modifyTimestamp:= 20080110163829Z

            # search result
            search: 2
            result: 0 Success

            # numResponses: 3
            # numEntries: 2
            -----------------------------------  
        12.1.3. Further Information
            slapo-accesslog和 delta-syncrepl 复制部分。
    

    12.2. 审计日志(Audit Logging)
        审核日志层(The Audit Logging overlay) 可用于将 给定后端数据库上的所有更改 记录到 指定的日志文件 中。

        12.2.1. 概览(Overview)
            略 
        12.2.2. 配置审计日志(Audit Logging Configuration)

            如果目录正在通过slapd.d运行，
                则可以使用以下LDIF将overlay添加到cn=config中的overlay列表中，
                并设置LDIF被记录到哪个文件
            -----------------------------------   
            dn: olcOverlay=auditlog,olcDatabase={1}mdb,cn=config
            changetype: add
            objectClass: olcOverlayConfig
            objectClass: olcAuditLogConfig
            olcOverlay: auditlog
            olcAuditlogFile: /tmp/auditlog.ldif 
            ----------------------------------- 
                在这个测试示例中，我们将更改记录到/tmp/auditlog.ldif
            slapo-auditlog创建的典型LDIF文件如下所示:   
            ----------------------------------- 
            # add 1196797576 dc=suretecsystems,dc=com cn=admin,dc=suretecsystems,dc=com
            dn: dc=suretecsystems,dc=com
            changetype: add
            objectClass: dcObject
            objectClass: organization
            dc: suretecsystems
            o: Suretec Systems Ltd.
            structuralObjectClass: organization
            entryUUID: 1606f8f8-f06e-1029-8289-f0cc9d81e81a
            creatorsName: cn=admin,dc=suretecsystems,dc=com
            modifiersName: cn=admin,dc=suretecsystems,dc=com
            createTimestamp: 20051123130912Z
            modifyTimestamp: 20051123130912Z
            entryCSN: 20051123130912.000000Z#000001#000#000000
            auditContext: cn=accesslog
            # end add 1196797576

            # add 1196797577 dc=suretecsystems,dc=com cn=admin,dc=suretecsystems,dc=com
            dn: ou=Groups,dc=suretecsystems,dc=com
            changetype: add
            objectClass: top
            objectClass: organizationalUnit
            ou: Groups
            structuralObjectClass: organizationalUnit
            entryUUID: 160aaa2a-f06e-1029-828a-f0cc9d81e81a
            creatorsName: cn=admin,dc=suretecsystems,dc=com
            modifiersName: cn=admin,dc=suretecsystems,dc=com
            createTimestamp: 20051123130912Z
            modifyTimestamp: 20051123130912Z
            entryCSN: 20051123130912.000000Z#000002#000#000000
            # end add 1196797577
            ----------------------------------- 
        
        12.2.3. Further Information
            略 


    12.3. Chaining
        12.3.1. 概述Overview

            (The chain overlay)链覆盖 为基础数据库提供了基本的链功能。

            链接是什么?它表明了 DSA代表客户端追踪referrals的能力，
                这样分布式系统就被客户端视为一个单一的虚拟DSA，
                否则客户端就无法自己“chase(追踪)”referrals。

            (The chain overlay)链覆盖 建立在ldap后端的顶部；
            默认情况下--enable-ldap 进行编译。
        
        12.3.2. Chaining Configuration
            为了演示此overlay如何工作，
                我们将讨论一个典型的场景，该场景可能是一个 provider服务器 和三个 Syncrepl(复制)副本。
                    在每个副本上，在任何数据库定义之前 将其添加到 slapd.conf文件 全局的顶部附近：
                -----------------------------------    
                overlay                    chain
                chain-uri                  "ldap://ldapprovider.example.com"
                chain-idassert-bind        bindmethod="simple"
                                           binddn="cn=Manager,dc=example,dc=com"
                                           credentials="<secret>"
                                           mode="self"
                chain-tls                  start
                chain-return-error         TRUE
                -----------------------------------    
                将此添加到您的 syncrepl 语句下面：
                -----------------------------------  
                updateref "ldap://ldapprovider.example.com/"  ？？？？？？
                -----------------------------------    
        12章 余下未看

13. 模式规范(Schema Specification)
    待看

14. 安全注意事项(Security Considerations) 
    OpenLDAP 软件旨在 在从严格控制的封闭网络 到 全球Internet的 各种计算环境中运行。
    因此，OpenLDAP支持许多不同的安全性机制。
    本章介绍了这些机制，并讨论了使用 OpenLDAP的安全注意事项。

    14.1. 网络安全(Network Security)
        14.1.1. 选择性侦听(Selective Listening)
            
            默认情况下，slapd将同时侦听 IPv4 和 IPv6 “any”地址。
            通常希望 slapd 在指定的ip/port上监听。例如，仅监听 IPv4的127.0.0.1 那么将不允许远程访问目录服务器。
            例如：
                slapd -h ldap://127.0.0.1

            要有选择地限制远程访问，建议使用 IP 防火墙来限制访问。

        14.1.2. IP防火墙(IP Firewall)
            服务器系统的 IP防火墙功能 
                可用于 基于客户端的IP地址 和/或 用于与客户端通信的网络接口来 限制访问。

            通常，slapd
                在端口 389/tcp上侦听  ldap://会话，
                在端口 636/tcp 上侦听 ldaps://会话
            slapd可以配置为侦听其他端口。

            如何配置IP防火墙的细节取决于所使用的IP防火墙的特定种类。

        14.1.3. TCP Wrappers
            slapd支持 TCP wrappers
                TCP wrappers 提供了基于规则的访问控制系统，用于控制对服务器的 TCP/IP 访问。
                例如，host_options 规则：
                -----------------------------------
                slapd: 10.0.0.0/255.0.0.0 127.0.0.1 : ALLOW
                slapd: ALL : DENY    
                -----------------------------------  
                        仅允许来自 专用网络10.0.0.0 和 本地主机127.0.0.1的 传入连接 访问目录服务。  
                注意：
                    slapd使用的IP地址，通常不配置反向查找。

                注意，TCP wrappers 要求连接被接受。
                    由于 仅仅拒绝连接 就需要进行大量处理，
                    因此通常建议使用 IP防火墙 保护而不是 TCP wrappers。
    
    
    14.2. 数据完整性和机密性保护(Data Integrity and Confidentiality Protection)

        传输层安全(Transport Layer Security, TLS)可用于提供 数据完整性和机密性保护
            OpenLDAP支持通过 StartTLS和ldaps:// 进行TLS(SSL)协商
            StartTLS 是标准的跟踪机制
        
        多种 简单身份验证和安全层(Simple Authentication and Security Layer，SASL)机制,(例如 DIGEST-MD5 和 GSSAPI)也提供了数据完整性和机密性保护。


        14.2.1. 安全强度因子(Security Strength Factors)
            
            服务器使用安全强度因子(Security Strength Factors, SSF)指示保护的相对强度。
                SSF 为0表示没有保护措施
                SSF 为1表示完整性保护已到位。
                >1 的 SSF 大致与有效加密密钥长度相关
                    例如，
                        DES为56, 
                        3DES为112， 
                        AES为128、192或256。

            许多管理控件依赖于 LDAP会话中存在的 TLS/SASL相关联的 SSF。

            如果没有适当的保护措施，安全控制措施将禁止操作。
            例如：
                security ssf=1 update_ssf=112
            
            要求对所有操作进行完整性保护，并对更新操作(例如添加，删除，修改等)要求加密保护(等效于 3DES)。
            请参见 slapd.conf(5)

            对于细粒度的控制，可以在访问控制中使用 SSF。
        

    14.3. 认证方式(Authentication Methods)
        
        14.3.1. “简单”方式("simple" method)

            LDAP的 “简单”方式 有三种操作模式：
                ● anonymous                     匿名
                ● unauthenticated               未验证身份
                ● user/password authenticated   已验证身份(用户名/密码)
            匿名访问是通过 不向“简单”绑定操作 提供名称和密码 来请求的。 anonymous
            通过 提供名称而不提供密码来 请求未经身份验证的访问。        unauthenticated
            通过 提供有效的名称和密码来 请求经过身份验证的访问。        user/password authenticated

            (anonymous)匿名 绑定 会导致匿名授权关联。
                默认情况下会 启用 匿名绑定机制，
                    但可以通过在 slapd.conf中指定“disallow bind_anon”来禁用匿名绑定机制。

            注意：
                禁用匿名绑定机制不会阻止匿名访问目录。
                要 要求身份验证来访问目录，应改为指定“require authc”。
            
            (unauthenticated)未验证身份 的绑定 也会导致匿名授权关联。
                未验证身份的绑定机制 默认情况下处于禁用状态，
                    但可以通过在 slapd.conf中指定“allow bind_anon_cred”来启用。
                由于许多LDAP程序在进行 身份验证(user/password authenticated)访问时，错误地生成了未验证身份(unauthenticated)的绑定请求
                (也就是说，它们不确保提供了密码)，
                    因此通常应保持禁用此机制。

            成功的 "用户/密码验证(user/password authenticated)"绑定 将导致用户授权身份(提供的名称)与会话关联。
                缺省/默认情况下，启用 用户/密码验证绑定。
                    但是，由于这种机制本身不提供窃听保护(例如，密码是明文设置的)，
                    所以建议只在 严格控制的系统中使用，或者 当LDAP会话被其他方式(例如: TLS,IPsec)保护的情况下使用。
                当管理员依赖TLS来保护密码时，建议禁用不受保护的身份验证(authenticated)。
                    使用simple_bind选项，
                    该选项提供了对机密保护级别的细粒度控制，要求进行简单的用户/密码身份验证。
                        例如，使用simple_bind=56将需要简单的绑定 才能使用等同于DES或更好的加密。

                "用户/密码验证(user/password authenticated)"绑定机制
                    通过设置"disallow bind_simple"来完全禁用。

            注意：绑定失败会导致会话具有匿名授权关联。


        14.3.2. SASL方式(SASL method)
            LDAP SASL 方式允许使用任何 SASL 身份验证机制。

    14.4. 密码存储(Password Storage)
        
        LDAP 密码通常存储在 userPassword 属性中。
            RFC4519 指定密码 不以加密(或散列)形式存储(即 默认存储的是明文)。
            这允许使用多种基于密码的身份验证机制，例如 DIGEST-MD5。
            这也是最可互操作的存储方案。
        
        但是，可能希望改为存储密码的哈希。slapd支持多种存储方案，供管理员选择。
        注意：
            密码属性的值，无论使用哪种存储方案，都应受到保护，就像它们是纯文本一样。
            哈希密码容易受到字典式攻击和暴力攻击。
        
        userPassword 属性允许有多个值，并且每个值都可以以不同的形式存储。
        在身份验证过程中，Slapd 将迭代这些值，直到找到与提供的密码匹配的值，或者直到用尽所有值进行检查为止。
        存储方案作为值的前缀存储，因此使用 Salted SHA1(SSHA)方案的哈希密码如下所示:
            userPassword: {SSHA}DkMTwBl+a/3DQTxCYEApdUtNXGgdUac3

        哈希(哈希即散列)密码的优点是，哈希的攻击者不能直接访问实际的密码。
            不幸的是，由于字典和暴力攻击通常很容易让攻击者成功，所以这种优势是微不足道的
            (这就是为什么所有现代Unix系统都使用影子(shadow)密码文件的原因)。

        散列存储的缺点是它们是非标准的，可能会导致互操作性问题，
        并且通常无法使用比Simple(或SASL/PLAIN)更强的基于密码的身份验证机制，如DIGEST-MD5。


        14.4.1. SSHA 密码存储方案(SSHA password storage scheme)
            SSHA 是SHA方案的加盐版本。它被认为是slapd支持的最安全的(！！！！)密码存储方案。
            这些值表示相同的密码：
                userPassword: {SSHA}DkMTwBl+a/3DQTxCYEApdUtNXGgdUac3
                userPassword: {SSHA}d0Q0626PSH9VUld7yWpR0k6BlpQmtczb
        
        14.4.2. CRYPT 密码存储方案(CRYPT password storage scheme)
            此方案使用操作系统的 crypt哈希函数。
                它通常会产生传统的Unix风格的 13个字符的哈希，
                但是在具有 glibc2 的系统上，它也可以生成更安全的 34字节MD5哈希。
                    userPassword: {CRYPT}aUihad99hmev6
                    userPassword: {CRYPT}$1$czBJdDqS$TmkzUAb836oMxg/BmIwN.1
            CRYPT 方案的优点在于，
                可以在不知道明文形式的情况下，将密码传输到现有的Unix密码文件或从现有的Unix密码文件传输。
                两种形式的 crypt 都包含 salt，因此它们对字典攻击具有一定的抵抗力。
            注意：
                由于此方案使用操作系统的 crypt哈希函数，因此它是特定于操作系统的。
        
        14.4.3. MD5密码存储方案(MD5 password storage scheme)
            此方案仅采用密码的 MD5哈希并将其以 base64编码形式存储：
                userPassword: {MD5}Xr4ilOzQ4PCOq3aQ0qbuaQ==
            尽管比明文存储更安全，但这不是一个非常安全的方案。
                MD5 算法速度很快，并且由于不添加 salt，因此该方案 容易受到字典攻击(！！！！)。

        14.4.4. SMD5 密码存储方案(SMD5 password storage scheme)
            这通过添加salt(随机数据，这意味着给定明文密码有许多可能的表示)改进了基本的MD5方案。
                例如，这两个值表示相同的密码:
                    userPassword: {SMD5}4QWGWZpj9GCmfuqEvm8HtZhZS6E=
                    userPassword: {SMD5}g2/J/7D5EO6+oPdklp5p8YtNFk4=
        
        14.4.5. SHA 密码存储方案(SHA password storage scheme)
            像MD5方案一样，这只是通过 SHA哈希过程来提供密码。 
            SHA 被认为比 MD5 更安全，但是缺少 salt 会使该方案 容易受到字典攻击(！！！！)。
                userPassword: {SHA}5en6G6MezRroT3XKqkdPOmY/BfQ=
        
        14.4.6. SASL 密码存储方案(SASL password storage scheme)
            这根本不是一个真正的密码存储方案。
                它使用userPassword属性的值将 密码验证 委托给另一个进程。
            注意:这与使用SASL对LDAP会话进行身份验证不同。


    14.5. 直通身份验证(Pass-Through authentication)
        
        slapd能够将密码验证委派给一个单独的进程。
            使用了 sasl_checkpass函数，因此它可以使用 Cyrus SASL 支持的任何后端服务来检查密码。
            选择范围非常广泛，
                其中一种选择是使用saslauthd ，它可以使用本地文件、Kerberos、一个IMAP服务器、另一个LDAP服务器或PAM机制支持的任何东西。
            必须使用 enable-spasswd配置选项 构建服务器，以启用直通身份验证。
        
        注意：这与使用 SASL 机制对 LDAP 会话进行身份验证不同。

        直通身份验证仅适用于 “simple bind”和“SASL PLAIN”身份验证机制中使用的 纯文本密码。

        直通身份验证是选择性的：
            仅影响 userPassword属性 值使用“{SASL}”方案标记的用户。
            该属性的格式为：
                userPassword: {SASL}username@realm
                    username和realm 已传递到SASL身份验证机制，用于标识要验证此账户的密码。 
                    这允许在 OpenLDAP中的条目 与 后端身份验证服务已知的帐户之间进行任意映射。
        
        最好使用访问控制来 防止用户在启用了直通身份验证的情况下 通过LDAP更改密码。


        14.5.1. 配置 slapd 身份认证提供方(Configuring slapd to use an authentication provider)
            如果条目的密码值为“{SASL}”，则 OpenLDAP 将验证条目密码的整个过程委托给 Cyrus SASL。
            因此，所有配置都在 SASL 配置文件中完成。

            第一个要考虑的文件被混淆地命名为 slapd.conf，通常在 SASL 库目录中找到，通常是/usr/lib/sasl2/slapd.conf。
                该文件控制将 LDAP与slapd通信时 SASL的使用以及 用于身份验证的SASL后端。
                有关完整详细信息，请参见 CyrusSASL 文档中的options.html。
            
            这是一个使用 saslauthd 验证密码的"服务器"的简单示例：
            -----------------------------------    
            mech_list: plain
            pwcheck_method: saslauthd
            saslauthd_path: /var/run/sasl2/mux
            -----------------------------------    
        
        14.5.2. 配置 saslauthd(Configuring saslauthd)
            saslauthd 能够使用许多不同的 身份验证服务
                通常的要求是将部分或全部身份验证委派给另一台 LDAP 服务器。
                这是一个使用 MicrosoftActive Directory(AD)的示例 saslauthd.conf：
                -----------------------------------
                ldap_servers: ldap://dc1.example.com/ ldap://dc2.example.com/

                ldap_search_base: cn=Users,DC=ad,DC=example,DC=com
                ldap_filter: (userPrincipalName=%u)

                ldap_bind_dn: cn=saslauthd,cn=Users,DC=ad,DC=example,DC=com
                ldap_password: secret    
                -----------------------------------  
                        在这个例子中，saslauthd 与 ldap 身份验证机制一起运行，
                        并且设置为将 SASL realm 与login name 结合在一起：saslauthd -a ldap -r

                    这意味着，LDAP 客户端提供的 userPassword 属性中的“username@realm”字符串
                        最终被用于在 AD 中搜索“userPrincipalName=username@realm”
                        然后，通过尝试使用 搜索找到的条目与AD绑定，来验证密码。
        
        14.5.3. 测试直通身份认证(Testing pass-through authentication)

            通常最好是 从后端身份验证 provider开始，并通过 saslauthd 和 slapd 连接到 LDAP 客户端。

            在上面的 AD 示例中，首先检查 saslauthd 连接到 AD 时将使用的 DN 和密码是否有效：
            ----------------------------------- 
            ldapsearch -x -H ldap://dc1.example.com/ \
                -D cn=saslauthd,cn=Users,DC=ad,DC=example,DC=com \
                -w secret \
                -b '' \
                -s base   
            ----------------------------------- 
            下一步检查是否可以找到示例 AD 用户：   
            -----------------------------------   
            ldapsearch -x -H ldap://dc1.example.com/ \
                -D cn=saslauthd,cn=Users,DC=ad,DC=example,DC=com \
                -w secret \
                -b cn=Users,DC=ad,DC=example,DC=com \
                "(userPrincipalName=user@ad.example.com)" 
            -----------------------------------    
            检查用户是否可以绑定到 AD：
            -----------------------------------  
            ldapsearch -x -H ldap://dc1.example.com/ \
                -D cn=user,cn=Users,DC=ad,DC=example,DC=com \
                -w userpassword \
                -b cn=user,cn=Users,DC=ad,DC=example,DC=com \
                -s base \
                    "(objectclass=*)"  
            -----------------------------------    
            如果一切正常，那么 saslauthd 应该能够做到这一点：
            ----------------------------------- 
            testsaslauthd -u user@ad.example.com -p userpassword
            testsaslauthd -u user@ad.example.com -p wrongpassword   
            -----------------------------------  
            现在，将令牌放入 OpenLDAP 中的条目中：
                userPassword: {SASL}user@ad.example.com 
            
            现在应该可以使用该条目的 DN 和 AD 用户的密码绑定到 OpenLDAP。
             


15. Using SASL

    OpenLDAP 客户端和服务器能够通过简单身份验证和安全层(SASL)框架进行身份验证

    SASL可以与几个行业标准的身份验证机制一起使用，
        包括用于Kerberos V的GSSAPI、DIGEST-MD5以及用于传输层安全(TLS)的PLAIN和EXTERNAL。

    默认情况下，
        OpenLDAP的标准客户端工具(如 ldapsearch和 ldapmodify)
        将尝试使用 SASL 对用户进行 LDAP 目录服务器的身份验证。
    LDAP管理员 可以通过几个步骤来设置 基本身份验证服务，
        从而使用户可以作为其LDAP条目 被 slapd服务器进行身份验证。
    通过一些额外的步骤，
        可以允许某些用户和服务利用 SASL 的代理授权功能，
        从而使他们能够进行身份验证，
        然后将其身份切换为其他用户或服务的身份。
    
    请注意，
        在下文中，术语“用户user”用于描述通过 LDAP 客户端(例如 ldapsearch(1))连接到 LDAP 服务器的个人或应用程序实体。
        也就是说，术语“用户”不仅适用于使用 LDAP客户端的个人，
        而且适用于在没有直接用户控制的情况下发出 LDAP 客户端操作的应用程序实体。
    

    15.1. SASL 安全注意事项(SASL Security Considerations)
        SASL 提供了许多不同的身份验证机制。本节简要概述了安全注意事项。

        某些机制(例如 PLAIN 和 LOGIN)比 LDAP简单身份验证 更不安全性。
            和 简单身份验证 一样，除非您有足够的安全保护措施，否则不应该使用 简单身份验证/PLAIN/LOGIN 这些机制。
            建议
                仅将这些机制与传输层安全性(TLS)结合使用。
                在本文档中不再讨论 PLAIN 和 LOGIN 的使用。
        
        DIGEST-MD5 机制是 LDAPv3 的强制实施身份验证机制。
        不推荐使用 CRAM-MD5 机制，而推荐使用 DIGEST-MD5。

        GSSAPI 机制利用 GSS-API Kerberos V 提供安全的身份验证服务。
            KERBEROS_V4 机制适用于使用 Kerberos IV 的用户。
            Kerberos 被视为适用于小型企业和大型企业的安全的分布式身份验证系统。

        EXTERNAL 机制利用低层网络服务提供的身份验证服务，例如“传输层安全性”(TLS)。
            与基于 TLS X.509 的公钥技术结合使用时，
            EXTERNAL 可提供强大的身份验证功能。    
        EXTERNAL 也可以与 ldapi:/// transport 一起使用，
            因为 Unix 域套接字可以报告客户端进程的 UID 和 GID。
    
    15.2. SASL 身份认证(SASL Authentication)
    
    15章余下部分 待看

---------------------------------------------------------------------------------------------------------    
补充 知识： 


数字签名和数字证书的原理解读(图文) https://blog.csdn.net/qq_26566331/article/details/88185652 
    1.数据发出者 首先生成 公钥和私钥  
        公钥分发给别人 ，私钥自己留着 
            公钥加密 私钥解密
    2.数据发出者
        对数据进行  hash函数                    -->>   生成 摘要(digest)/指纹
        使用私钥  对 摘要(digest)/指纹  进行加密  -->>   生成 数字签名(signature)
        数据和摘要 一起发送出去
    3.数据接收者
        使用公钥 对 数字签名解密 -->>  得到 摘要(digest)/指纹
        对数据 进行 hash函数  得到摘要
        比较这两个摘要，如果一致 就证明数据没有被修改

    1.CA + 数据发出者
        CA对 使用自己的私钥 对数据发出者的公钥以及一些相关信息 还有 证书的信息 ，一起加密 -->> 生成数字证书(Digital Certificate)
        这样 发送者每次发送数据时 只需要 数据+数字签名(自己的)+数字证书(CA颁发的)
        接收者 受到数据后  用CA的公钥 解开 数字证书  然后 就能证明这是来自 数据发出者 的 数字签名


https://program-think.blogspot.com/2010/02/introduce-digital-certificate-and-ca.html 
    “证书”洋文也叫“digital certificate”或“public key certificate”
    CA 是“Certificate Authority”的缩写，也叫“证书授权中心”
    CA证书: CA颁发的证书
    根证书: root certificate
    除了根证书，其它证书都要依靠上一级的证书，来证明自己。
        根证书自己证明自己是可靠滴（或者换句话说，根证书是不需要被证明滴）。
    证书可以用来验证某个网站，还可以用来验证某个文件是否被篡改。
        目前大多数知名的公司（或组织机构），其发布的可执行文件（比如软件安装包、驱动程序、安全补丁），都带有数字签名。
            你可以自己去看一下。
    　　建议大伙儿在安装软件之前，都先看看是否有数字签名？
            如果有，就按照上述步骤验证一把。
            一旦数字签名是坏的，那可千万别装。


补充 知识： 来自《LINUX/UNIX OpenLDAP实战指南-chapter08》
    8.2
    CA(Certification Author)
    certificate authority 证书中心 CA  -->> 颁发 数字证书
    CA证书 包含以下有效信息  
        证书版本号 version 
        序列号
        签名算法标志
        发行者名称
        证书有效期
        证书相关合法信息
        发行商唯一标志
        证书主体唯一标志
        扩展信息
        签名信息
    8.3.1
    对称加密算法 DES 3DES AES 
        加解密使用相同的密钥
        可以保证数据的机密性，但不能保证数据的完整性(可能被第三方篡改)
            第三方对传输的数据虽然无法破解，但是可以修改加密后的文件，破坏了数据的完整性
        对不同的用户生成不同的加密算法和密钥信息
            保证了数据的机密性，但是不便于密钥的集中管理
    8.3.2
    hash
        只能加密，不能解密
        甲方 对数据hash后 形成 摘要/指纹
        乙方 对数据进行hash 形成 摘要/指纹
        两次的指纹相同 证明数据没有被篡改
    8.3.3
    非对称加密算法
        可以保证数据的机密性 以及 身份验证
        主要用于密钥的交换，而不是用于 经常性的数据传输时 对数据进行加密
            特点是算法强度复杂，其安全性依赖于算法与密钥。
            由于其算法复杂，而使得加密解密的速度远远低于对称加密算法，因此不适用于数据量较大的情况。
        公钥 对数据进行加密 ，私钥进行解密
            用于机密数据传输(分发对称加密的密钥)
        私钥 对数据进行加密 ，公钥进行解密(身份验证)
            能成功解密 即可证实信息却是是 甲方发起的，这就是常用的 数字签名技术。
    例子：
        1.
        甲方 使用乙方的公钥 对 对称加密的密钥 进行加密，乙方使用自己的私钥解密，拿到了 对称加密的密钥
            这就是 对称加密密钥的分发 
        2.
        甲方 使用hash 得到数据的摘要/指纹，然后使用自己的私钥 对摘要/指纹 进行加密， 
        乙方 使用 甲方的公钥 进行解密，得到摘要/指纹(能解密，就验证了 发送方的身份)
        乙方，然后对数据使用相同的hash，得到 摘要/指纹(两处的摘要/指纹一致，则证明数据没有被篡改)
            发送方 对数据的 摘要/指纹 进行私钥加密 ，这就是 数字签名
        甲方 使用hash 得到数据的摘要/指纹，然后使用自己的私钥 对摘要/指纹 进行加密， 然后使用对称加密，然后发送给乙方
            如果之前没有分发对称加密的密钥，那么就使用 乙方的公钥 进行加密 然后传输
        3.
        乙方 使用 自己的私钥解密，得到 对称加密的密钥，并对数据进行解密
        然后到CA获取 甲方的公钥 ，使用甲方的公钥 解密数据，得到了指纹，如果正常解密，说明数据却是是甲方发送的
        然后对数据进行 hash，若是指纹相同，则数据没有被篡改，保证可数据的机密性
        4.
        非对称加密 结合 CA 保证了数据的机密性 完整性 以及身份验证 
    8.4.2
    OpenSSL命令
        genrsa      通过RSA算法，生成公钥和私钥
        req         申请和生成证书
        -new        生成新的证书
        -x509       互联网常用的一种标准
        -in         证书的位置(签署证书以及证书请求常常用到)
        -out        证书的存放位置
        -days       证书的有效期限
        -enc        获取加密类型 
     
    
        
        

        
    




---------------------------------------------------------------------------------------------------------    

16. Using TLS
16. 使用 TLS
    


---------------------------------------------------------------------------------------------------------    



17. 构造分布式目录服务(Constructing a Distributed Directory Service)
    
    对于许多站点而言，运行一个或多个保存整个数据子树的 slapd就足够了。
    但是通常希望对树的某个部分(可能正在运行或可能不在运行slapd)有一个 slapd 引用其他目录服务。

    17.1. 下级知识信息(Subordinate Knowledge Information)
        
        提供下级知识信息来委托子树。
            下级知识信息 作为 委托点的 特殊引用对象 在目录中维护。
            引用对象充当一个委托点，将两个服务粘合在一起。
            这种机制允许构建分层目录服务。

        引用对象具有一个结构的对象类objectClass: referral，并且与被委托的子树具有相同的DN。
            通常，引用对象还将提供辅助对象类objectClass: extensibleObject。
            这允许条目包含适当的相对DN值。

        如果服务器a.example.net持有dc=example,dc=net，
        并希望将子树ou=subtree,dc=example,dc=net委托给另一个服务器b.example.net，    ？？？？？ 何谓委托？？？？
            则会将以下命名的引用对象添加到a.example.net:
            -----------------------------------   
            dn: dc=subtree,dc=example,dc=net
            objectClass: referral
            objectClass: extensibleObject
            dc: subtree
            ref: ldap://b.example.net/dc=subtree,dc=example,dc=net 
            -----------------------------------   
    
    17.2. 上级知识信息(Superior Knowledge Information)
        
        使用referral(引用/推荐)指令指定上级知识信息
            值是引用上级目录服务的 URI 列表
        
        对于没有直接上级的服务器(例如上例中的 a.example.net)，可以将服务器配置为 使用具有全局知识的目录服务，
            例如 OpenLDAP Root Service
                referral        ldap://root.openldap.org/
        
        但是，由于 a.example.net 是 b.example.net 的直接上级，
        因此 b.example.net 的配置应如下所示：
            referral ldap://a.example.net/
    

    17.3. ManageDsaIT 控件(The ManageDsaIT Control)

        通常使用 ldapmodify或支持 ManageDsaIT控件的类似工具
            来添加，修改和删除 引用对象。
        
        ManageDsaIT 控件通知服务器您打算将引用对象作为常规条目进行管理。
            这样可以防止/阻止服务器为 查询或更新引用对象的请求 发送引用结果。

        管理常规条目时，不应指定 ManageDsaIT 控件。

        ldapmodify的-M选项启用 ManageDsaIT
            例如：
                ldapmodify -M -f referral.ldif -x -D "cn=Manager,dc=example,dc=net" -W
            或者和ldapsearch一起使用：
                ldapsearch -M -b "dc=example,dc=net" -x "(objectclass=referral)" '*' ref

        注意：
            ref 属性是可操作的，如果需要显示在搜索结果中 必须在请求显示指定。

        注意：
            使用 referral(引用/推荐) 来构建分布式目录服务非常笨拙(！！！！！)，普通客户端也不太支持。
            如果已经使用引用构建了现有安装，则使用chain overlay来隐藏引用将大大提高 Directory 系统的可用性。
            更好的方法是在从属配置中使用显式定义的本地和代理数据库，以提供分布式目录的无缝视图。
        
        注意：
            LDAP 操作，即使是子树搜索，通常也只能访问一个数据库。
            可以通过将数据库与subordinate/olcSubordinate 关键字结合在一起来更改它。



18. 复制Replication

    复制目录是交付企业弹性部署的基本需求。

    OpenLDAP2.4 引入multimaster

    OpenLDAP复制 相关术语， 
        provider/multi-provider和consumer: 
            provider可以接受外部(即客户端)写操作，并将其(更新)提供给consumer以供检索;
            consumer向provider请求复制更新。
        与严格定义的master/slave关系不同，provider/consumer角色非常灵活：
            consumer中接收的复制更新可以由该consumer进一步传播到其他服务器，因此consumer也可以同时充当provider。
            而且，consumer不必是实际的 LDAP 服务器,它可能只是一个 LDAP client客户端。
    
    以下各节将介绍复制技术并讨论可用的各种复制选项。

    总结：
        client的写操作写入到provider
        provider将更新内容 传播给consumer，使得二者内容同步
        consumer向client提供查询


    18.1. 复制技术(Replication Technology) 

        18.1.1. 同步复制(LDAP Sync Replication)
        Syncrepl （！！！！！！！！！！！！！！！！！）
            
            LDAP同步复制(简称 syncrepl)
                1.是消费者方的复制引擎，
                使消费者(consumer)服务器能够维护 DIT片段 的影子副本。
            
            DIT：DIrectory Information Tree 目录树
            
            一个syncrepl引擎 作为slapd的一个线程 驻留在consumer上。
                它建立和维护一个consumer副本，方法是：
                    1.首先，连接到一个 provider 以执行 DIT内容的初始化加载，
                    2.然后，进行 定期内容轮询/拉取 或 及时根据内容变更 来更新目录树信息。
            
            Syncrepl 使用 LDAP内容同步协议(或简称 LDAP Sync)作为consumer同步协议。 
            LDAP Sync提供一个有状态的复制，
                1.同时 支持基于拉式和基于推式的同步，并且不要求使用历史存储。  
                    1.1.在基于 拉 的复制中，consumer定期轮询/拉取provider以获取更新。
                    1.2.在基于 推 的复制中，consumer实时收听provider发送的更新信息。
                由于该协议不需要历史存储，因此 provider不需要维护已收到的任何更新日志
                (请注意，syncrepl 引擎是可扩展的，支持未来新增的复制协议。)。
            
            Syncrepl通过维护和交换 同步cookie 来跟踪 复制内容的状态。
                1.因为 syncrepl consumer和provider保持它们的内容状态，
                   1.1.所以，consumer可以通过轮询 provider的内容 (拿到: 能使得consumer和provider保持最新同步 (所需)的条目) 以执行增量同步。
                       所以消费者可以拉取 provider的内容来执行增量同步，只需要请求那些最新的 provider条目。
                2.Syncrepl 还可以通过 维护复制状态 来方便地管理consumer的复制。
                    2.1.consumer数据库/副本 可以在任何同步状态下 从一个consumer端或一个provider端的备份 构建。
                    2.2.Syncrepl可以自动将consumer数据库与最新的provider内容同步到一致状态。

            Syncrepl 同时支持 基于拉和基于推的同步。
                1.在基本的 refreshOnly 同步模式下，
                    provider使用基于"拉"的同步，
                        provider无需跟踪consumer服务器，并且不维护任何历史信息。
                        provider 需要处理 来自consumer的周期性的拉请求信息，
                            请求信息 包含在 请求本身的同步cookie中。
                    为了优化基于拉的同步，
                        syncrepl 利用了 LDAP Sync协议的 “当前阶段”及其“删除阶段”，
                        而不是依靠频繁的完全重载来进行回滚。
                    为了进一步优化基于拉的同步，
                        provider可以维护一个按范围划分的会话日志作为历史存储。
                2.在 refreshAndPersist 同步模式下，
                    provider使用基于"推"的同步。
                        provider跟踪 请求了一个持久搜索的consumer服务器，
                        并在provider复制内容被修改时向它们发送必要的更新。
            
            如果consumer服务器 对要被复制的DIT片段 有适当访问权限，
                consumer服务器 可以创建一个复制而无需修改provider的配置，也无需重启provider服务器。
                consumer服务器也可以停止复制，也是无需provider端任何变更和重启。

            Syncrepl支持 局部的，稀疏的 片段复制。
                影子DIT片段 由一个标准通用搜索来定义，
                    由 base，scope，filter 和 attribute list 组成。
                    consumer复制内容还受 syncrepl复制连接 绑定的用户的操作权限的 限制。

            总结：
                Syncrepl驻留 在consumer上；
                Syncrepl使用 LDAP Sync作为consumer同步协议；
                Syncrepl通过 同步cookie 来跟踪 复制内容的状态，以提供一个有状态的复制；
                Syncrepl同时支持 基于拉 和 基于推 进行目录树信息同步；
                (refreshOnly)拉模式下，
                    consumer定期到provider 以拉取的方式进行同步数据更新； 
                    优化：
                        当前阶段
                        删除阶段
                (refreshAndPersist)推模式下，
                    1.consumer请求了持久搜索， 那么provider会跟踪consumer
                    2.一旦provider检测到 持久搜索范围内 有内容被更新了，就会向consumer发送更新
                    3.consumer实时监听并接收provider发送的更新信息，并对本地目录树进行更新；
                Syncrepl支持多服务器之间同步数据，且实现双向数据同步；
                    2.4版本中使用Syncrepl方式进行同步，slurpd已废弃


            18.1.1.1. The LDAP Content Synchronization Protocol
            18.1.1.1. LDAP 内容同步协议

                本节仅简要介绍 LDAP Content Sync协议
                有关更多信息，请参阅 RFC4533

                LDAP Sync协议通过定义两个单独的同步操作 来支持轮询和侦听：
                    refreshOnly 和refreshAndPersist。
                轮询通过 refreshOnly 实现。
                    consumer使用附加了 LDAP Sync控件的 LDAP搜索请求 来轮询provider。
                    在轮询时 使用查询中返回的信息，consumer副本将与provider副本同步。
                    provider像处理常规搜索一样 在搜索操作结束时返回SearchResultDone 来完成搜索操作。
                监听通过 refreshAndPersist 实现。
                    顾名思义，像refreshOnly一样，它以搜索开始。
                    在返回当前匹配搜索条件的所有条目之后，不完成搜索，而是将同步搜索在provider中保持不变。
                    provider 对同步内容的 后续更新 会导致将(附加的)条目更新发送给consumer。

                refreshOnly操作和refreshAndPersist操作的刷新阶段可以在当前阶段或删除阶段执行。

                #当前阶段--当前消息
                1.在当前阶段，provider向consumer发送 自上次同步以来在 搜索范围内 更新的条目。
                    provider发送 更新后的条目的 所有请求的属性（无论是否更改）(即：只要条目中有一个属性值被更改 整个条目都会被发送)。
                2.对于 
                    在(搜索)范围内的每个未改变的条目，
                    provider发送一条
                    当前消息，
                        该消息仅由 条目名称 和 代表当前状态的同步控件 组成。
                        当前消息不包含条目的任何属性。(即：对于未更改的条目 发送条目名称和状态 但不包含任何属性)
                3.consumer收到所有更新和当前条目后，可以通过
                    添加 添加到provider的条目，
                    替换 在provider上修改的条目 以及
                    删除 consumer副本中(既没有更新 也未指定存在于provider处)的条目 (意思是: 更新的条目中不包含这个条目，同时当前消息中也不包含这个条目 肯定是被provider删除了)
                    来可靠地确定新的consumer副本。
                总结：
                    先发送范围内的更新
                    范围内未改变的每个(!!!)条目，发送一条“当前消息”
                        即：
                            根据更新 新增条目和修改条目
                            根据更新 和 当前消息(即：指出哪些条目仍然原封不动的存在) ，来确定删除哪些条目
                
                #删除阶段--删除消息
                删除阶段中 更新条目的传输与当前阶段中的相同。
                    provider将 自上次同步以来 在搜索范围内更新的条目的所有请求属性 发送给consumer。
                但是，在删除阶段，
                    provider会为 从搜索范围中删除的每个条目发送一条删除消息，而不是发送当前消息。
                    删除消息 
                        仅由 条目名称 和 代表删除状态的同步控件 组成。
                可以根据 SearchResultEntry消息附带的同步控件 通过添加，修改和删除条目 来确定新的consumer副本。
                总结：
                    先发送范围内的更新
                    范围内被删除的每个条目，发送一条“删除消息”
                        即： 
                            新增的 和 修改的 包含在更新中       ，据此进行新增条目和修改条目
                            然后每删除一个条目 发送一个删除消息  ，据此进行删除条目

                #当前阶段 和 删除阶段 怎么选择
                如果LDAP Sync provider维护历史存储 并可以确定自上次同步以来哪些条目不在consumer副本范围内，
                    则provider可以使用“删除阶段“。
                    (意思是：如果可以精确的确定哪些条目被provider删除了，
                    那么只需要发送这些被删除的信息即可，
                    也就是使用“删除阶段”)
                如果provider不维护任何历史存储，不能从历史存储中确定作用域外的条目，或者历史存储不涵盖consumer的过时同步状态，
                    则provider应使用“当前阶段”。
                    (意思是：无法确定哪些条目被删除了，
                    那么把 目前还存活的条目名称 发给consumer ，
                    让consumer自己判断 删除哪些条目，
                    也就是使用“当前阶段”)
                就同步业务而言，当前阶段的使用比完整内容重新加载的效率要高得多。
                为了进一步减少同步流量，LDAP Sync 协议还提供了一些优化措施，
                    例如在单个syncIdSet消息中传输标准化的 entryUUID 和传输多个 entryUUID。
                    (粗略理解：应该是在 “当前消息”中一次发送多个 未更改的/或者是被删除的 条目的ID)
                
                在 refreshOnly 同步结束时，
                    provider在同步完成后将同步cookie发送给consumer，
                    作为consumer副本的(同步)状态指示符。(即：这个cookie唯一标识了这个consumer同步到了哪儿)
                    consumer在向provider请求下一次增量同步时将携带此cookie。
                
                #refreshAndPersist
                当使用 refreshAndPersist 同步时，
                    provider会在刷新阶段结束时通过发送带有refreshDone=TRUE 的同步信息消息来发送同步 cookie。
                    provider还通过将 同步cookie附加到 在同步搜索的"持久阶段"生成的“SearchResultEntry消息” 中 来发送同步cookie。
                在持久阶段，
                    provider还可以在 provider想要更新consumer一方状态指示符的任何时间 发送包含同步cookie的SyncInfo消息。

                在 LDAP Sync 协议中，条目由 entryUUID 属性值唯一标识。
                    它可以用作条目的可靠标识符。
                    另一方面，条目的 DN 可以随时间更改，因此不能视为可靠的标识符。
                    作为同步控件的一部分，entryUUID 附加到每个 SearchResultEntry 或 SearchResultReference。
                
            18.1.1.2. Syncrepl Details
            18.1.1.2. Syncrepl 细节

                syncrepl 引擎同时使用 LDAP Sync 协议的 refreshOnly 和 refreshAndPersist 操作。
                如果数据库定义中包含 syncrepl 规范，
                    则 slapd启动一个syncrepl引擎作为slapd的一个线程，并安排其执行。
                如果指定了 refreshOnly 操作，
                    则同步操作完成后的间隔时间将重新安排syncrepl引擎。
                    （因为周期性的去拉取，所以要设置其周期）
                如果指定了 refreshAndPersist 操作，
                    则引擎将保持活跃状态并处理来自provider的持久同步消息。
                    （因为是 接收provider推过来的消息，所以保持监听）

                syncrepl引擎 同时使用 刷新同步的 当前阶段和删除阶段。
                1.可以在provider中配置会话日志，该会话日志存储 从数据库中删除的有限数量条目的 entryUUID。
                    多个consumer共享相同的会话日志。
                2.如果会话日志是当前的(足够新)，并且consumer服务器的状态足够新，以至于在client的最后一次同步之后没有会话日志条目被截断时，
                    那么syncreplpl引擎将使用删除阶段。
                3.如果没有为复制内容配置任何会话日志，或者consumer方太过时而无法被会话日志覆盖，
                    则syncrepl引擎将使用当前阶段。
                会话日志存储的当前设计是基于内存的，
                    因此会话日志中包含的信息不能在多个provider程序调用上保持不变。
                    当前不支持使用 LDAP 操作访问会话日志存储。
                    当前也不支持对会话日志施加访问控制。
                
                作为进一步的优化，
                    即使在同步搜索未与任何会话日志关联的情况下，
                    当复制上下文中没有更新时，也不会将任何条目传输到consumer服务器。
                
                1. consumer端的复制引擎：syncrepl引擎 可以与任何后端一起使用。
                2. 可以将 LDAP Sync provider配置为任何后端上的overlay，
                    但是最适合与 back-bdb，back-hdb 或 back-mdb 后端一起使用。
                    如下：
                        overlay syncprov
                
                LDAP Sync provider
                    为每个数据库维护一个 contextCSN    
                    作为provider内容的 当前同步状态指示符。
                contextCSN是provider上下文中最大的 entryCSN，
                    因此对于 entryCSN 值较小的条目，没有任何事务。
                能将contextCSN 设置为最大的已发行entryCSN，
                    因为 entryCSN 是在事务开始之前获得的，
                    并且未按发行顺序提交。
            总结：
                contextCSN是不是cookie ？？？
                答：不是，cookie 是<csn><rid> 
                    <csn>是contextCSN用于标识复制状态, 
                    <rid>是consumer的id+
            总结：
                根据consumer发来的cookie中的contextCSN 
                来确定 复制的起始位置 和 结束位置
                （startCSN < e.CSN < endCSN时发送更新条目）
                
                provider将上下文的 contextCSN 存储在上下文后缀条目(context suffix entry)的 contextCSN 属性中。
                    但是，该属性不会在每次更新操作后写入数据库。相反，它主要在内存中维护。
                    在数据库启动时，provider将最后保存的 contextCSN 读取到内存中，然后以独占方式使用内存中副本。
                    默认情况下，由于数据库更新而导致对 contextCSN 的更改不会被完全写入数据库，直到服务器完全关闭为止。
                如果需要的话，存在一个检查点工具可以使 contextCSN 被更频繁地写出。

                请注意，在启动时，
                    如果provider无法从后缀条目中读取 contextCSN，
                    它将扫描整个数据库以确定该值，
                    并且在大型数据库上进行此扫描可能需要很长时间。
                读取 contextCSN 值后，
                    仍将扫描数据库以查找大于该值的任何 entryCSN 值，
                    以确保 contextCSN 值确实反映了数据库中最大的已提交 entryCSN。
                在支持不等式索引的数据库上，
                    在 entryCSN 属性上设置 eq索引
                    并配置 contextCSN 检查点将大大加快此扫描步骤。
                
                如果无法通过读取和扫描数据库确定 contextCSN，则将生成一个新值。
                另外，如果扫描数据库产生的 entryCSN 比后缀条目的 contextCSN 属性中先前记录的要大，则将立即用新值写入检查点。

                consumer还将其复制状态存储在后缀条目的 contextCSN 属性中，   
                    这是作为同步cookie接收的provider的contextCSN。
                当consumer服务器与provider服务器执行后续增量同步时，
                    由consumer服务器维护的复制状态将用作同步状态指示符。
                当它用作级联复制配置中的辅助provider服务器时，
                    它还用作provider端同步状态指示符。
                由于consumer和provider状态信息都保存在各自数据库中的同一位置，
                    因此无需任何特殊操作即可将任何consumer提升为provider（反之亦然）。
                
            总结：
                每次更新完成后，provider都会给consumer发送一个cookie
                (cookie中封装了一个contxtCSN，告诉consumer 你小子下次再来找我要数据时 记得带上cookie)
                这样每次请求消息时，provider就知道每个具体的consumer都复制到那里了，
                这样就知道了复制的 起始位置和结束位置
                
                因为可以在syncrepl规范中使用 通用搜索过滤器，
                    所以可以从同步内容中省略上下文中的某些条目。 ？？？？？？？？？？为什么？？？？？？？？？？？？？？？？？？？
                如果consumer内容的任何部分是从属的，
                    则 syncrepl引擎会创建一个粘合条目以填充consumer上下文。
                    除非提供了 ManageDsaIT 控件，否则粘合条目不会在搜索结果中返回。
                
                同样，由于 syncrepl 规范中使用了搜索过滤器，
                    即使未在provider上删除条目，
                    也可能进行修改以将条目从复制范围中删除。  ？？？？？
                从逻辑上讲，必须在consumer上删除该条目，
                    但是在provider不使用会话日志的情况下，
                    provider在 refreshOnly 模式下无法检测和传播此更改。
    
    
    18.2. Deployment Alternatives
    18.2. 部署替代方案

        18.2.1. Delta-syncrepl replication
        18.2.1. Delta-syncrepl 复制
        Delta-syncrep （！！！！！！！！！！！！！！！！！）

        LDAP Sync 复制的缺点：
            LDAP Sync 复制是基于对象的复制机制。
                在 provider上更改复制对象中的任何属性值时，每个consumer都将获取并处理完整的更改对象，包括复制期间更改后的属性值和未更改的属性值。
                这种方法的一个优点是，当单个对象发生多个更改时，无需保留这些更改的确切顺序；只有条目的最终状态很重要。(优点：单个对象发生多个更改时)
                但是，当使用模式涉及对多个对象的单个更改时，此方法可能会有缺点。(缺点：多个对象的单个更改时)（！！！！！！！！！！！！）
            例如，假设您有一个数据库，
                其中包含102,400个对象，每个对象 1KB。
                    此外，假设您例行运行批处理作业 
                    对于在provider上的102,400个对象，
                    更改每一个对象的一个属性的值，这个属性值占2个字节。
                不计算 LDAP 和 TCP/IP 协议的开销，
                    每次运行此作业时，每个consumer将传输并处理100MB的数据以处理 200KB 的更改！
            在这种情况下传输和处理的数据的 99.98％将是多余的，因为它表示不变的值。
                这浪费了宝贵的传输和处理带宽，并且可能导致无法接受的复制积压。
                尽管这种情况很极端，但它展示了 LDAP实际部署中 可能会遇到的问题。
        Delta-syncrepl 出现的位置：
            Delta-syncrepl是syncrepl的 基于更改/变更日志(changelog-based) 的变体，旨在解决上述情况。
            Delta-syncrepl
                通过在provider上的单独数据库中 
                维护可选深度的变更日志(changelog) 来工作。
            复制consuner在changelog中检查其所需的变更，
                并且只要changelog包含所需的变更，
                consumer就可以从changelog中获取变更并将其应用于其数据库。
            但是，如果consumer方太快超出同步速度（或完全耗尽），
                则使用常规 syncrepl 使它保持最新状态，
                然后进行复制，
                然后切换回 delta-syncrepl 模式。
        注意：
            由于数据库状态既存储在provider上的 changelog数据库中，又存储在主数据库中，
                因此在还原数据库或将其复制到另一台计算机上时，
                使用 slapcat/slapadd 备份/还原 changelog数据库和主数据库非常重要。   
        
        总结： （！！！！！！！！！！！！！！！！！）
            Delta-syncrepl是对syncrepl的改进，使得可以增量同步
            provider把更改/更新 维护在changelog中 
            consumer可以从changelog中获取自己所需的变更
        总结：
            实际配置Delta-syncrepl provider时 是配置的accesslog 
            accesslog 是 changelog的变体
            所以实际的配置文件中见到的是accesslog 而不是changelog


        18.2.2. N-Way Multi-Provider Replication
        18.2.2. N 路多provider复制 

        多provider复制是一种使用 Syncrepl 将数据复制到多个provider（“Provider”）目录服务器的复制技术。
            
            18.2.2.1. Valid Arguments for Multi-Provider replication
            18.2.2.1. Multi-Provider复制的有效参数
                ● 如果任何provider失败，其他provider将继续接受更新
                ● 避免单点故障
                ● provider可以位于多个物理站点中，即分布在整个网络/地球上。
                ● 适用于自动故障转移/高可用性
                总结：
                    Multi-Provider的优点是 避免单点故障/冗余备份

            18.2.2.2. Invalid Arguments for Multi-Provider replication
            18.2.2.2. Multi-Provider复制的无效参数
                （这些通常被称为Multi-Provider复制的优点，但这些说法是错误的）：
                ● 与负载均衡无关
                ● Providers必须向所有其他服务器进行写操作，这意味着网络流量和写负载在所有服务器上的分布都与single-provider相同。
                ● Multi-Provider和single-provider复制的服务器利用率和性能最多相同；
                    在最坏的情况下，single-provider会更胜一筹，
                    因为可以对索引进行不同的调整以优化provider和consumer之间的不同使用模式。
            
            18.2.2.3. Arguments against Multi-Provider replication
            18.2.2.3. 反对Multi-Provider复制的争论
                ● 打破 目录模型的数据一致性 保证
                ● 如果由于网络分区而导致与provider的连接丢失，则“自动故障转移”可能会使问题更加复杂
                ● 通常，一台特定的计算机 无法区分 由于对等方崩溃 或 与网络链接失败 而导致与对等方失去联系
                ● 如果网络已分区并且多个clients开始向每个“providers”进行写入，
                    那么对帐将很麻烦；
                    最好是简单地拒绝：从单个provider分区的client进行写操作

        18.2.3. MirrorMode replication
        18.2.3. MirrorMode 复制
            
            MirrorMode 是一种混合配置，
                它提供了single-provider复制的所有一致性保证，
                同时还提供了multi-provider的高可用性。
            在 MirrorMode 中，将两个provider设置为可以相互复制（作为multi-provider配置），
                但是使用外部前端将所有写入仅定向到两个服务器之一。 
                仅当第一个provider崩溃时，第二个provider才用于写操作，
                此时前端将切换为将所有写操作定向到第二个provider。
                当崩溃的provider被修复并重新启动后，
                它将自动赶上正在运行的provider上的所有更改并重新同步。
        
            18.2.3.1. Arguments for MirrorMode
            18.2.3.1. MirrorMode 的讨论
                ● 为目录写入（副本句柄读取）提供高可用性（HA）解决方案
                ● 只要一个provider可以操作，就可以安全地接受写操作
                ● Provider nodes提供程序节点 相互复制，因此它们始终是最新的，可以随时接管（热备用）
                ● Syncrepl 还允许provider节点在发生任何停机后重新同步
            
            18.2.3.2. Arguments against MirrorMode
            18.2.3.2. 反对 MirrorMode 的讨论
                ● MirrorMode 不是所谓的Multi-Provider解决方案。这是因为一次只能将写入操作 写到 镜像节点之一
                ● MirrorMode 可以称为 Active-Active Hot-Standby，因此需要外部服务器（slapd以代理模式）
                    或设备（硬件负载平衡器）来管理当前处于活动状态的provider
                ● 备份管理略有不同
                    ■ 如果备份 Berkeley数据库本身 并定期备份 事务日志文件，则需要使用镜像对的相   ？？？？？？
                        同成员来收集日志文件，直到进行下一次数据库备份为止      
        
        18.2.4. Syncrepl Proxy Mode
        18.2.4. Syncrepl 代理模式

            尽管 LDAP Sync 协议同时支持基于拉和推的复制，
                但是在provider可以开始推更改之前，
                仍必须从consumer启动推模式（refreshAndPersist）。
            在某些网络配置中，尤其是在防火墙限制了建立连接的方向的情况下，
                可能需要provider发起的推送模式。

            可以借助LDAP后端（后端和slapd-ldap）配置此模式。
                不是在实际consumer上运行syncrepl引擎，
                而是在指向consumer的provider附近设置了slapd-ldap代理，
                并且 syncrepl 引擎在代理上运行。
            
            总结：
                Syncrepl Proxy同步模式 属于代理同步，它将主服务器隐藏起来，
                proxy/代理服务器 通过syncrepl从主服务器上 以拉的方式 同步目录信息树，
                当 proxy/代理服务器 数据发生改变时，proxy/代理服务器 又以推的方式将数据更新到 下属的从LDAP服务器上，
                且 从LDAP服务器只有对 proxy/代理服务器 有读权限。
            
            18.2.4.1. Replacing Slurpd
            18.2.4.1. 更换 Slurpd
                旧的 Slurpd 机制仅在 提供商发起的(provider-initiated)推送模式下运行。
                    不推荐使用 Slurpd 复制，而推荐使用Syncrepl 复制，并且已经从 OpenLDAP 2.4 中完全删除了它。
                
                简而言之，它被替换的原因有很多：
                ● 不可靠
                    ■ 它对 replog 中的记录顺序非常敏感
                    ■ 它很容易不同步，这时需要手动干预才能将副本数据库与provider目录重新同步
                    ■ 它对不能使用的服务器的容忍度不是很高。如果副本长时间宕机，则重复日志(replog)的大小可能太大而无法处理
                ● 仅在推送模式下有效
                ● 需要停止并重新启动provider以添加新副本
                ● 仅支持single-provider复制
                
                Syncrepl 没有这些弱点：
                ● Syncrepl 是自同步的；
                    您可以从任何状态（从完全空到完全同步）的consumer数据库开始，
                    它将自动执行正确的操作以实现并保持同步
                    ■ 它对变化的发生顺序完全不敏感
                    ■ 它确保了consumer和provider内容之间的融合，而无需人工干预
                    ■ 它可以重新同步，无论consumer与provider无联系的时间有多长
                ● Syncrepl 可以双向操作
                ● 可以随时添加consumer，而不触及provider上的任何东西
                ● 支持Multi-provider复制
    

    18.3. Configuring the different replication types
    18.3. 配置不同的复制类型
        18.3.1. Syncrepl
            18.3.1.1. Syncrepl configuration
            18.3.1.1. Syncrepl 配置

                由于 syncrepl 是consumer方的复制引擎，
                    因此syncrepl规范是在consumer服务器的slapd.conf中定义的，
                    而不是在provider服务器的配置文件中定义的。
                consumer内容的初始加载
                    可以通过 启动没有同步cookie的syncrepl引擎 来执行，
                    也可以通过 加载在provider中作为备份转储的LDIF文件 来填充consumer。
                
                从备份加载时，不需要从provider内容的最新备份执行初始加载。
                    syncrepl引擎将自动将初始consumer与当前provider内容同步。
                        因此，不需要停止provider服务器，
                        以避免在内容备份和加载过程中由于对provider内容进行更新而导致的复制不一致。
                
                当复制大型目录时，尤其是在带宽受限的环境中，
                    建议从备份加载consumer，
                    而不是使用syncrepl执行完整的初始加载。
                
                总结：    （！！！！！！！！！！！！！！！！！）
                    1. syncrepl 存在于consumer的slapd.conf文件中；
                    2. 建议 加载 provider备份转储的LDIF文件 来初始化consumer的内容
                        然后 syncrepl引擎，自动将consumer内容和provider内容同步
            

            18.3.1.2. Set up the provider slapd
            18.3.1.2. 设置provider的slapd

                provider被实现为一个覆盖(overlay)，因此overlay自身必须先在slapd.conf中配置才能使用。
                当使用 delta-syncrepl 时， provider有两个主配置指令和两个辅助指令。
                由于 LDAP Sync搜索 受访问权限控制，因此应为复制的内容设置适当的访问控制特权。

                要配置的两个主要选项是: 检查点(checkpoint)和会话日志行为(sessionlog behaviors)。

                contextCSN checkpoint
                    syncprov-checkpoint <ops> <minutes>
                        仅在成功执行写操作后才对checkpoint进行测试。
                        如果自上一个checkpoint以来已经过<ops>次操作或超过<minutes>分钟的时间，
                        则会执行一个新的检查点。
                        默认情况下，检查点是禁用的。
                session log
                    syncprov-sessionlog <ops>
                        其中<ops>是session log可以记录的最大session log条目数。
                        所有写操作（“添加”除外）都记录在log中。
                    注意： 
                        使用session log需要搜索entryUUID 属性。
                        在此属性上设置 eq 索引将极大地改善provider上的session log的性能。
                
                reloadhit
                    syncprov-reloadhint <TRUE|FALSE>
                        在使用accesslog overlay 用于基于增量的(delta-based)syncrepl复制支持时，
                            必须将其设置为TRUE。
                        默认值为 FALSE。

                仅当将overlay设置在日志(log)数据库的顶部时，才应配置 nonpresent 选项。
                    （例如与 delta-syncrepl 一起使用时）
                nonpresent
                    syncprov-nopresent <TRUE|FALSE>
                        仅对于在log数据库上的syncprov实例，
                            应将此值设置为 TRUE。
                            （例如，由 accesslog overlay管理的数据库）
                        默认值为 FALSE。
                
                slapd.conf内容的更完整示例是：
                -----------------------------------    
                database mdb
                maxsize 85899345920
                suffix dc=example,dc=com
                rootdn dc=example,dc=com
                directory /var/ldap/db
                index objectclass,entryCSN,entryUUID eq    

                overlay syncprov
                syncprov-checkpoint 100 10
                syncprov-sessionlog 100
                -----------------------------------    

            总结：    （！！！！！！！！！！！！！！！！！）
                设置provider slapd
                    overlay syncprov                    ！必须把provider实现为一个overlay
                    syncprov-checkpoint <ops> <minutes> ！必须设置检查点
                        检查点负责把缓存中的数据刷到磁盘中，这样provider数据库就会被更新了
                    syncprov-sessionlog <ops>           ！必须设置会话允许的最大条目数
                        设置entryCSN entryUUID的索引位eq将会 极大地改善provider上的session log的性能
                            如： 
                                index objectclass,entryCSN,entryUUID eq 
                    syncprov-reloadhint <TRUE|FALSE>    使用增量同步复制Delta-syncrepl时必须设置为TRUE
                        用于支持accesslog overlay
                    syncprov-nopresent <TRUE|FALSE>     使用增量同步复制Delta-syncrepl时必须设置为TRUE 
                        仅：当将overlay置于log database顶端时 才设置为TRUE，比如 增量同步复制Delta-syncrepl
            总结： 概述
                必须设置
                    index 
                    overlay
                    syncprov-checkpoint
                    syncprov-sessionlog
                增量复制时还要设置
                    syncprov-reloadhint TRUE
                    syncprov-nopresent TRUE
                还必须在provider里 设置 consumer的binddn的访问权限
                    否则consumer没有权限，拿不到provider更新的内容

            

            18.3.1.3. Set up the consumer slapd
            18.3.1.3 设置consumer的 slapd

                syncrepl指令 是在slapd.conf的数据库部分为consumer上下文指定的。(即： 在consumer的database中定义syncrepl)
                syncrepl引擎 是独立于后端的，并且可以使用任何数据库类型定义指令。

                在consumer的database中定义syncrepl
                -----------------------------------  
                database mdb
                maxsize 85899345920
                suffix dc=example,dc=com
                rootdn dc=example,dc=com
                directory /var/ldap/db
                index objectclass,entryCSN,entryUUID eq

                syncrepl rid=123
                        provider=ldap://provider.example.com:389
                        type=refreshOnly
                        interval=01:00:00:00
                        searchbase="dc=example,dc=com"
                        filter="(objectClass=organizationalPerson)"  
                        scope=sub
                        attrs="cn,sn,ou,telephoneNumber,title,l"  
                        schemachecking=off
                        bindmethod=simple
                        binddn="cn=syncuser,dc=example,dc=com"
                        credentials=secret  
                -----------------------------------  
                在此示例中：   
                    consumer将会连接到provider slapd的389端口 (provider=ldap://provider.example.com:389)
                        去 每天执行一次轮询(refreshOnly)模式。 
                    绑定的DN是  cn=syncuser,dc=example,dc=com ，并使用密码 secret 进行简单身份验证。
                    注意：
                        应该在provider中适当设置 cn=syncuser,dc=example,dc=com的访问权限，
                            使得它能 检索到所需的复制内容。
                        同样，provider的搜索限制必须足够高，以允许syncuser(同步用户)能检索到 所请求内容的完整副本。
                        consumer使用rootdn写入自己的数据库，所以它始终有写入所有内容的完整权限。
                    上例中的同步搜索，
                        将在 以dc=example,dc=com为根的整个子树中
                        搜索 objectClass=organizationalPerson 的条目。 
                        请求的属性是 cn,sn,ou,telephoneNumber,title,l 。
                    关闭schema检查，所以consumer在处理来自provider slapd的更新时 将不会执行体条目的schema检查。
                
            总结：  （！！！！！！！！！！！！！！！！！）
                设置consumer slapd
                必须设置
                    index           设置索引
                    rid             consumer的唯一标识id
                    provider        provider ldap-server
                    searchbase      从provider的哪棵树下 获取更新
                    filter          过滤出 哪些条目
                    scope           更新的范围  一般设置为 sub
                    attrs           拿到条目中的哪些属性值
                    schemachecking  写入前是否开启schema检查
                    bindmethod      simple是明文；sasl
                        binddn          consumer以什么身份/DN 去provider上获取更新
                        credentials     此DN的密码
                    type=refreshOnly模式下
                        interval        以此为周期去provider上拉取更新
                    type=refreshAndPersist模式下    





            18.3.1.4. Start the provider and the consumer slapd
            18.3.1.4. 启动provider和consumer的slapd        

                provider的slapd不需要重新启动。
                    contextCSN 是根据需要自动生成的：
                        它可能最初包含在 LDIF 文件中，由slapadd生成，
                        或者 在上下文更改时生成，
                        或者 在第一个 LDAP Sync搜索到达provider时生成。
                    如果正在加载的 LDIF 文件以前不包含 contextCSN，则-w 选项应与 slapadd一起使用以使其生成。
                        这将使服务器在首次运行时能更快地启动。

                consumer的slapd
                启动consumer的slapd时，
                    可以加上 -c cookie 命令行选项 以提供同步cookie，以便从特定状态开始同步。
                    cookie 是用逗号分隔的 “name=value”对 的列表。
                    当前支持的 syncrepl cookie字段为 csn=<csn>和 rid=<rid>。 （！！！！！！！！！！！！）
                        <csn>代表consumer的当前同步状态。
                        <rid>在consunmer服务器内本地标识一个consumer。
                            它用于将 cookie 与 slapd.conf中具有<rid>的syncrepl定义相关联。
                            <rid>不能超过 3 个十进制数字。
                        命令行 cookie 会覆盖存储在consumer数据库中的同步cookie。
           
           
           
            总结：    （！！！！！！！！！！！！！！！！！）
                provider 
                consumer 启动时 附上参数 -c cookie，会导致从特定的 复制状态 开始同步
                    其中cookie是 csn=<csn> rid=<rid>
                    其中 entryCSN是provider为每一个consumer维护的复制同步状态




        18.3.2. Delta-syncrepl
            18.3.2.1. Delta-syncrepl Provider configuration
            18.3.2.1. 配置Delta-syncrepol Provider

                设置 delta-syncrepl 要求在provider和副本服务器上都进行配置更改：
                -----------------------------------  
                # Give the replicator DN unlimited read access.  This ACL needs to be
                # merged with other ACL statements, and/or moved within the scope
                # of a database.  The "by * break" portion causes evaluation of
                # subsequent rules.  See slapd.access(5) for details.
                access to *
                    by dn.base="cn=replicator,dc=example,dc=com" read
                    by * break
                #即：给予 cn=replicator,dc=example,dc=com 无限制的读权限
                #此ACL需要与其他ACL语句合并，并在数据库范围内移动
                # by * break 导致对后续规则求值
                # 即： 设置了谁能来拿我(provider)更新的内容

                # Set the module path location  #设置module路径位置
                modulepath /usr/lib/openldap
                
                # Load the mdb backend          #加载mdb后端
                moduleload back_mdb.la
                
                # Load the accesslog overlay    # 加载accesslog overlay
                moduleload accesslog.la
                # 必须要加载这个module
                # 因为增量同步Delta-syncrepl 时 provider需要支持accesslog overlay
                # 即：要支持 accesslog database  
                #    同时还要把accesslog设置为overlay
                
                #Load the syncprov overlay      #加载syncprov overlay
                moduleload syncprov.la
                # 加载这个module 时为了 把provider设置为overlay
                
                # Accesslog database definitions  #Accesslog数据库定义
                database mdb
                suffix cn=accesslog
                rootdn cn=accesslog
                directory /var/lib/db/accesslog
                maxsize 85899345920
                index default eq
                index entryCSN,objectClass,reqEnd,reqResult,reqStart,reqDN
                # 定义了accesslog database 
                # 并设置了ccesslog database的索引

                overlay syncprov
                syncprov-nopresent TRUE
                syncprov-reloadhint TRUE
                # 把provider设置为overlay
                # 同时增量同步Delta-syncrepl 时 这两个参数必须设置为true 详见 18.3.1.2. 的总结：

                # 让这个 cn=replicator,dc=example,dc=com 的搜索不受任何限制
                limits dn.exact="cn=replicator,dc=example,dc=com" time.soft=unlimited time.hard=unlimited size.soft=unlimited size.hard=unlimited

                # Primary database definitions  #主数据库定义
                database mdb
                suffix "dc=example,dc=com"
                rootdn "cn=manager,dc=example,dc=com"
                maxsize 85899345920
                # 设置主数据库 mdb

                ## Whatever other configuration options are desired     #其他配置选项

                # syncprov specific indexing                    #指定索引
                index entryCSN eq
                index entryUUID eq
                # 主数据库的索引 是为了加速 session log

                # syncrepl Provider for primary db              #syncrepl Provider的主数据库
                overlay syncprov
                syncprov-checkpoint 1000 60
                # 设置检查点 

                # accesslog overlay definitions for primary db  #
                overlay accesslog
                logdb cn=accesslog
                logops writes
                logsuccess TRUE
                # scan the accesslog DB every day, and purge entries older than 7 days  #每天扫描accesslog DB，清除超过7天的条目
                logpurge 07+00:00 01+00:00
                # 把accesslog设置为overlay
                # 设置了 每天扫描accesslog DB，清除超过7天的条目

                # Let the replicator DN have limitless searches     # 让这个 cn=replicator,dc=example,dc=com 的搜索不受任何限制
                limits dn.exact="cn=replicator,dc=example,dc=com" time.soft=unlimited time.hard=unlimited size.soft=unlimited size.hard=unlimited  
                -----------------------------------    
                有关更多信息，请查阅相关的手册页（slapo-accesslog和 slapd.conf）
            
            问题：
                前面描述Delta-syncrepl的时候说的是changelog为什么此处配置的是acesslog？
            总结：
                实际配置Delta-syncrepl provider时 是配置的accesslog 
                accesslog 是 changelog的变体




            18.3.2.2. Delta-syncrepl Consumer configuration


                -----------------------------------
                # Replica database configuration
                database mdb
                suffix "dc=example,dc=com"
                rootdn "cn=manager,dc=example,dc=com"
                maxsize 85899345920

                ## Whatever other configuration bits for the replica, like indexing
                ## that you want

                # syncrepl specific indices
                index entryUUID eq

                # syncrepl directives
                syncrepl  rid=0
                        provider=ldap://ldapprovider.example.com:389
                        bindmethod=simple
                        binddn="cn=replicator,dc=example,dc=com"
                        credentials=secret
                        searchbase="dc=example,dc=com"
                        logbase="cn=accesslog"          #去provider的 accesslog database 上查找是否有更新
                        logfilter="(&(objectClass=auditWriteObject)(reqResult=0))"
                        schemachecking=on
                        type=refreshAndPersist          #推模式 
                        retry="60 +"
                        syncdata=accesslog             #syncdata和logbase保持一致

                # Refer updates to the provider
                updateref               ldap://ldapprovider.example.com    #？？？？？？
                -----------------------------------   
                上面的配置假定您在数据库中定义了一个复制者身份，可用于绑定到provider。
                    此外，如果使用 bdb 或 hdb 后端，
                    则所有数据库（主数据库，副本数据库和 Accesslog 存储数据库）也应正确调整满足您需求的 DB_CONFIG 文件。
                注意：
                    Accesslog 数据库对于给定的provider是唯一的。
                    永远不要复制它。



        18.3.3. N-Way Multi-Provider
        18.3.3. N 路多提供者

            对于以下示例，我们将使用 3 个 Provider 节点。
            与 OpenLDAP 测试套件的 test050-syncrepl-multiprovider 保持一致，
            我们将通过 cn=config 配置 slapd
            
            这里设置 config database：
                -----------------------------------    
                dn: cn=config
                objectClass: olcGlobal
                cn: config
                olcServerID: 1

                dn: olcDatabase={0}config,cn=config
                objectClass: olcDatabaseConfig
                olcDatabase: {0}config
                olcRootPW: secret
                -----------------------------------    
            第二和第三台服务器将具有不同的 olcServerID：
                -----------------------------------    
                dn: cn=config
                objectClass: olcGlobal
                cn: config
                olcServerID: 2

                dn: olcDatabase={0}config,cn=config
                objectClass: olcDatabaseConfig
                olcDatabase: {0}config
                olcRootPW: secret
                -----------------------------------             
                -----------------------------------    
                dn: cn=config
                objectClass: olcGlobal
                cn: config
                olcServerID: 3

                dn: olcDatabase={0}config,cn=config
                objectClass: olcDatabaseConfig
                olcDatabase: {0}config
                olcRootPW: secret
                ----------------------------------- 
            将syncrepl设置为provider（因为这些都是provider）：
                ----------------------------------- 
                dn: cn=module,cn=config
                objectClass: olcModuleList
                cn: module
                olcModulePath: /usr/local/libexec/openldap
                olcModuleLoad: syncprov.la
                ----------------------------------- 
            现在，我们设置第一个provider节点（将$URI1，$URI2 和$URI3 等替换为您的实际 ldapurl）：
                ----------------------------------- 
                dn: cn=config
                changetype: modify
                replace: olcServerID
                olcServerID: 1 $URI1
                olcServerID: 2 $URI2
                olcServerID: 3 $URI3

                dn: olcOverlay=syncprov,olcDatabase={0}config,cn=config
                changetype: add
                objectClass: olcOverlayConfig
                objectClass: olcSyncProvConfig
                olcOverlay: syncprov

                dn: olcDatabase={0}config,cn=config
                changetype: modify
                add: olcSyncRepl
                olcSyncRepl: rid=001 
                            provider=$URI1 
                            binddn="cn=config" 
                            bindmethod=simple
                            credentials=secret 
                            searchbase="cn=config" 
                            type=refreshAndPersist
                            retry="5 5 300 5" 
                            timeout=1
                olcSyncRepl: rid=002 
                            provider=$URI2 
                            binddn="cn=config" 
                            bindmethod=simple
                            credentials=secret 
                            searchbase="cn=config" 
                            type=refreshAndPersist
                            retry="5 5 300 5" 
                            timeout=1
                olcSyncRepl: rid=003 
                            provider=$URI3 
                            binddn="cn=config" 
                            bindmethod=simple
                            credentials=secret 
                            searchbase="cn=config" 
                            type=refreshAndPersist
                            retry="5 5 300 5" 
                            timeout=1
                -
                add: olcMirrorMode
                olcMirrorMode: TRUE
                ----------------------------------- 
            现在启动provider和一个或多个consumer，还将上述 LDIF 添加到第一个consumer，第二个consumer等。
                然后它将复制 cn=config。
                现在，您在config database上具有 N-WayMulti-Provider。

            我们仍然必须复制实际数据，而不仅仅是配置，
                因此将其添加到provider中（所有活跃的和配置的consumers/providers都将下拉此配置，因为它们都在同步）。
                同样，将所有${}变量替换为适用于您的设置的变量：
            ----------------------------------- 
            dn: olcDatabase={1}$BACKEND,cn=config
            objectClass: olcDatabaseConfig
            objectClass: olc${BACKEND}Config
            olcDatabase: {1}$BACKEND
            olcSuffix: $BASEDN
            olcDbDirectory: ./db
            olcRootDN: $MANAGERDN
            olcRootPW: $PASSWD
            olcLimits: dn.exact="$MANAGERDN" time.soft=unlimited time.hard=unlimited size.soft=unlimited size.hard=unlimited
            olcSyncRepl: rid=004 
                        provider=$URI1 
                        binddn="$MANAGERDN" 
                        bindmethod=simple
                        credentials=$PASSWD 
                        searchbase="$BASEDN" 
                        type=refreshOnly
                        interval=00:00:00:10 
                        retry="5 5 300 5" 
                        timeout=1
            olcSyncRepl: rid=005 
                        provider=$URI2 
                        binddn="$MANAGERDN" 
                        bindmethod=simple
                        credentials=$PASSWD 
                        searchbase="$BASEDN" 
                        type=refreshOnly
                        interval=00:00:00:10 
                        retry="5 5 300 5" 
                        timeout=1
            olcSyncRepl: rid=006 
                        provider=$URI3 
                        binddn="$MANAGERDN" 
                        bindmethod=simple
                        credentials=$PASSWD 
                        searchbase="$BASEDN" 
                        type=refreshOnly
                        interval=00:00:00:10 
                        retry="5 5 300 5" 
                        timeout=1
            olcMirrorMode: TRUE

            dn: olcOverlay=syncprov,olcDatabase={1}${BACKEND},cn=config
            changetype: add
            objectClass: olcOverlayConfig
            objectClass: olcSyncProvConfig
            olcOverlay: syncprov
            ----------------------------------- 
            注意：
                您所有服务器的时钟必须紧密同步，
                比如 NTPhttp://www.ntp.org/，原子钟或其他一些可靠的时间参考。
            注意：
                如 slapd-config中所述，olcSyncRepl 指令中指定的 URL 是要从其复制的服务器的 URL。
                这些必须与在（命令行选项中的-h）上监听的 URL 完全匹配。否则，slapd 可能会尝试从自身复制，从而导致循环。
        

        问题： ？？？？？？？？？？？？？没看懂！！！
            上下两个配置文件。到底哪个放在provider中，哪个放在comsumer中？？？？？？

        18.3.4. MirrorMode
        
            MirrorMode 配置实际上非常简单。
                如果您曾经设置过普通的 slapd syncrepl provider，
                则唯一的更改是以下两个指令：
                    mirrormode on
                    serverID 1
            
            注意：您需要确保每个镜像节点的 serverID 不同，并将其添加为全局配置选项。

            18.3.4.1. Mirror Node Configuration
            18.3.4.1. 镜像节点配置

                第一步是与设置provider slapd 部分中相同的方式配置 syncrepl provider。 ？？？？

                这是在 refreshAndPersist 模式下使用 LDAP 同步复制的特定缩减示例：
                    ----------------------------------- 
                    #MirrorMode node 1:

                    # Global section
                    serverID    1
                    # database section

                    # syncrepl directive
                    syncrepl      rid=001
                                    provider=ldap://ldap-sid2.example.com
                                    bindmethod=simple
                                    binddn="cn=mirrormode,dc=example,dc=com"
                                    credentials=mirrormode
                                    searchbase="dc=example,dc=com"
                                    schemachecking=on
                                    type=refreshAndPersist
                                    retry="60 +"

                    mirrormode on
                    ----------------------------------- 
                        注意： 60 和 + 之间有空格间隔
                    ----------------------------------- 
                    #MirrorMode node 2:

                    # Global section
                    serverID    2
                    # database section

                    # syncrepl directive
                    syncrepl      rid=001
                                    provider=ldap://ldap-sid1.example.com
                                    bindmethod=simple
                                    binddn="cn=mirrormode,dc=example,dc=com"
                                    credentials=mirrormode
                                    searchbase="dc=example,dc=com"
                                    schemachecking=on
                                    type=refreshAndPersist
                                    retry="60 +"

                    mirrormode on
                    ----------------------------------- 
                    真的很简单；
                    每个 MirrorMode 节点的设置都完全相同，
                        只是 serverID 是唯一的，
                        并且每个consumer都指向另一个服务器。
            
            
                18.3.4.1.1. Failover Configuration
                18.3.4.1.1. 故障转移配置

                    通常有两种选择。
                        1.硬件代理/负载平衡或专用代理软件，
                        2.使用 Back-LDAP 代理作为syncrepl 提供程序
                    
                    一个典型的企业示例可能是：
                    Figure X.Y: MirrorMode in a Dual Data Center Configuration
                    图 X.Y：双数据中心配置中的 MirrorMode
                
                18.3.4.1.2. Normal Consumer Configuration
                18.3.4.1.2. 普通消费者配置

                    这与设置consumer slapd 部分完全相同。
                        它可以设置为普通的 syncrepl 复制模式，
                        也可以设置为 delta-syncrepl 复制模式。


            18.3.4.2. MirrorMode Summary
            18.3.4.2. MirrorMode 总结

                现在，您将拥有一个目录体系结构，
                    该体系结构可以提供单提供者复制的所有一致性保证，
                    同时还可以提供多提供者复制的高可用性。

            


        18.3.5. Syncrepl Proxy
        18.3.5. Syncrepl 代理

            以下示例适用于自包含的基于推送的复制解决方案：
            ----------------------------------- 
            #######################################################################
            # Standard OpenLDAP Provider
            #######################################################################

            include     /usr/local/etc/openldap/schema/core.schema
            include     /usr/local/etc/openldap/schema/cosine.schema
            include     /usr/local/etc/openldap/schema/nis.schema
            include     /usr/local/etc/openldap/schema/inetorgperson.schema

            include     /usr/local/etc/openldap/slapd.acl

            modulepath  /usr/local/libexec/openldap
            moduleload  back_mdb.la
            moduleload  syncprov.la
            moduleload  back_monitor.la
            moduleload  back_ldap.la

            pidfile     /usr/local/var/slapd.pid  #我的是/run/openldap/slapd.pid
            argsfile    /usr/local/var/slapd.args #我的是/run/openldap/slapd.args

            loglevel    sync stats

            database    mdb
            suffix      "dc=suretecsystems,dc=com"
            directory   /usr/local/var/openldap-data

            maxsize     85899345920
            checkpoint      1024 5

            index       objectClass eq
            # rest of indexes
            index       default     sub

            rootdn          "cn=admin,dc=suretecsystems,dc=com"
            rootpw          testing

            # syncprov specific indexing
            index entryCSN eq
            index entryUUID eq

            # syncrepl Provider for primary db
            overlay syncprov
            syncprov-checkpoint 1000 60

            # Let the replicator DN have limitless searches
            limits dn.exact="cn=replicator,dc=suretecsystems,dc=com" time.soft=unlimited time.hard=unlimited size.soft=unlimited size.hard=unlimited

            database    monitor

            database    config
            rootpw          testing

            ##############################################################################
            # Consumer Proxy that pulls in data via Syncrepl and pushes out via slapd-ldap
            ##############################################################################

            database        ldap
            # ignore conflicts with other databases, as we need to push out to same suffix
            hidden              on
            suffix          "dc=suretecsystems,dc=com"
            rootdn          "cn=slapd-ldap"
            uri             ldap://localhost:9012/

            lastmod         on

            # We don't need any access to this DSA
            restrict        all

            acl-bind        bindmethod=simple
                            binddn="cn=replicator,dc=suretecsystems,dc=com"
                            credentials=testing

            syncrepl        rid=001
                            provider=ldap://localhost:9011/
                            binddn="cn=replicator,dc=suretecsystems,dc=com"
                            bindmethod=simple
                            credentials=testing
                            searchbase="dc=suretecsystems,dc=com"
                            type=refreshAndPersist
                            retry="5 5 300 5"

            overlay         syncprov
            ----------------------------------- 

            这种设置类型的副本配置可以是：
            -----------------------------------  
            #######################################################################
            # Standard OpenLDAP Replica without Syncrepl
            #######################################################################

            include     /usr/local/etc/openldap/schema/core.schema
            include     /usr/local/etc/openldap/schema/cosine.schema
            include     /usr/local/etc/openldap/schema/nis.schema
            include     /usr/local/etc/openldap/schema/inetorgperson.schema

            include     /usr/local/etc/openldap/slapd.acl

            modulepath  /usr/local/libexec/openldap
            moduleload  back_mdb.la
            moduleload  syncprov.la
            moduleload  back_monitor.la
            moduleload  back_ldap.la

            pidfile     /usr/local/var/slapd.pid
            argsfile    /usr/local/var/slapd.args

            loglevel    sync stats

            database    mdb
            suffix      "dc=suretecsystems,dc=com"
            directory   /usr/local/var/openldap-consumer/data
            maxsize         85899345920
            checkpoint      1024 5
            index       objectClass eq
            # rest of indexes
            index       default     sub
            rootdn          "cn=admin,dc=suretecsystems,dc=com"
            rootpw          testing

            # Let the replicator DN have limitless searches
            limits dn.exact="cn=replicator,dc=suretecsystems,dc=com" time.soft=unlimited time.hard=unlimited size.soft=unlimited size.hard=unlimited

            updatedn "cn=replicator,dc=suretecsystems,dc=com"  ？？？？？？

            # Refer updates to the provider
            updateref   ldap://localhost:9011

            database    monitor

            database    config
            rootpw          testing
            -----------------------------------    
        您可以看到我们在这里使用了 updatedn 指令，

        示例 ACL（usr/local/etc/openldap/slapd.acl）是：
            -----------------------------------    
            # Give the replicator DN unlimited read access.  This ACL may need to be
            # merged with other ACL statements.

            access to *
                by dn.base="cn=replicator,dc=suretecsystems,dc=com" write
                by * break

            access to dn.base=""  ？？？？？
                    by * read

            access to dn.base="cn=Subschema"
                    by * read

            access to dn.subtree="cn=Monitor"
                by dn.exact="uid=admin,dc=suretecsystems,dc=com" write
                by users read
                by * none

            access to *
                    by self write
                    by * read  
            -----------------------------------   
            为了支持更多的副本，只需添加更多的数据库 ldap 部分并相应地增加 syncrepl rid 的数量即可。

            注意：您必须使用相同的数据填充 Provider 和 Replica 目录，这与使用常规 Syncrepl 时不同
                Figure X.Y: Replacing slurpd with a standalone version
                图 X.Y：用独立版本替换
            如果您无权修改provider目录配置，则可以配置独立的 ldap 代理，如下所示： 
            以下配置是独立 LDAP 代理的示例：
            -----------------------------------    
            include     /usr/local/etc/openldap/schema/core.schema
            include     /usr/local/etc/openldap/schema/cosine.schema
            include     /usr/local/etc/openldap/schema/nis.schema
            include     /usr/local/etc/openldap/schema/inetorgperson.schema

            include     /usr/local/etc/openldap/slapd.acl

            modulepath  /usr/local/libexec/openldap
            moduleload  syncprov.la
            moduleload  back_ldap.la

            ##############################################################################
            # Consumer Proxy that pulls in data via Syncrepl and pushes out via slapd-ldap
            ##############################################################################

            database        ldap
            # ignore conflicts with other databases, as we need to push out to same suffix
            hidden              on
            suffix          "dc=suretecsystems,dc=com"
            rootdn          "cn=slapd-ldap"
            uri             ldap://localhost:9012/

            lastmod         on

            # We don't need any access to this DSA
            restrict        all

            acl-bind        bindmethod=simple
                            binddn="cn=replicator,dc=suretecsystems,dc=com"
                            credentials=testing

            syncrepl        rid=001
                            provider=ldap://localhost:9011/
                            binddn="cn=replicator,dc=suretecsystems,dc=com"
                            bindmethod=simple
                            credentials=testing
                            searchbase="dc=suretecsystems,dc=com"
                            type=refreshAndPersist
                            retry="5 5 300 5"

            overlay         syncprov
            ----------------------------------- 
            如您所见，您可以使用 Syncrepl 和 slapd-ldap来定制您的复制以适合您的特定网络拓扑，你可以尽情发挥你的想象力。   
            -----------------------------------    
            -----------------------------------    
            -----------------------------------    
                -----------------------------------    



            ----------------------------------- 
            ----------------------------------- 

        -----------------------------------    
            -----------------------------------    
            -----------------------------------    
            -----------------------------------    

                    

19. （数据库备份）维护Maintenance

    19.1. Directory Backups
    19.1. 目录备份

        备份策略在很大程度上取决于
            数据库中的更改量，
            以及管理员在灾难性故障中可能愿意损失的更改量。
        可以使用两种基本方法：

        1. 备份 Berkeley数据库本身，并定期备份事务日志文件：
        (Berkeley database itself)(transaction log files)

            Berkeley DB 生成事务日志(transaction log)，可用于重建给定时间点的更改。
                例如，如果管理员只愿意丢失一小时的更改价值，
                则他们可以在半夜关闭服务器，将 Berkeley 数据库文件复制到异地，然后使服务器重新上线。
                然后，他们每小时可以强制执行一个数据库检查点，捕获过去一个小时内生成的日志文件，然后将其复制到异地。
                累积的日志文件与先前的数据库备份进行结合 然后与 db_recover 一起使用，以重建数据库(恢复到 ：最后一次将日志文件集合复制到异地为止)。
                此方法提供了良好的保护，同时具有最小的空间开销。
            
            总结：
                备份BDB和transaction log
                    BDB生成transaction log
                    先复制数据库文件到异地
                    每个一段时间执行一次检查点并收集日志文件
                    使用日志文件 对 异地数据库进行同步
        
        2. 定期运行 slapcat 并备份 LDIF 文件：

            可以在 slapd 处于活动状态时运行 slapcat。
                2.1.但是，这会带来数据库不一致的风险
                    不仅是从 slapd 的角度来看，
                    而且从使用 LDAP 的应用程序的角度来看。
                例如，如果预配应用程序执行的任务由多个 LDAP 操作组成，并且 slapcat 与这些操作同时发生，
                则从该预配应用程序和依赖于该自定义应用程序的应用程序的角度来看，LDAP 数据库中可能存在不一致之处。
                因此，必须确信不会发生类似的事情。
                    一种方法是在执行 slapcat 时将数据库置于只读模式。
                2.2.这种方法的另一个缺点是生成的 LDIF 文件可能很大，并且一天备份的累积可能会占用大量空间。

        您可以使用 slapcat为您的每个 slapd back-bdb 或 back-hdb 数据库生成 LDIF 文件。
            slapcat -f slapd.conf -b "dc=example,dc=com"
                对于 back-bdb 和 back-hdb，此命令可能在 slapd运行时运行。
        
        有关实际的 Berkeley DB 备份的更多信息，稍后将介绍 db_recover 等。

    19.2. Berkeley DB Logs
    19.2. Berkeley DB 日志

        Berkeley DB 日志文件会增长，管理员必须对其进行处理。该过程称为日志文件归档或日志文件轮换。
        注意：实际的日志文件轮换由 Berkeley DB 引擎处理。

        当前事务的日志需要存储到文件中，以便在应用程序崩溃时可以恢复数据库。
            管理员可以通过设置数据库环境来
                更改单个日志文件的大小限制（默认为 10MB），
                并自动删除旧的日志文件（请参阅下文）。
            Berkeley DB 默认情况下从不删除任何日志文件的原因是，
                管理员可能希望在删除日志文件之前对其进行备份，
                以便在灾难性的故障（例如文件系统损坏）之后也可以进行数据库恢复。
        
        总结：
            transaction log用于灾难性事故发生时 恢复数据库

        日志文件名为 log.XXXXXXXXXX（X 是一个数字）。
            默认情况下，日志文件位于 BDB 后端目录中。
        db_archive工具 知道当前事务中使用哪些日志文件，哪些不使用。
            管理员可以将未使用的日志文件移至备份介质，然后将其删除。
            要自动删除它们，请将 set_flags DB_LOG_AUTOREMOVE 指令放置在 DB_CONFIG 中。
        
        注意：如果自动删除日志文件，则灾难性故障后可能无法恢复。

        名称为__db.001，__db.002 等的文件只是共享内存区域（或其他）。
        这些不是“日志”，必须将它们单独放置。
        不要害怕它们，它们不会像原木一样生长。

        要了解 db_archive 接口，读者应参考 Berkeley DB 指南的第 9 章。特别是，建议以下章节：
            ● 数据库和日志文件归档
                - http://www.oracle.com/technology/documentation/berkeley-db/db/ref/transapp/archival.html 
            ● 日志文件删除
                - http://www.oracle.com/technology/documentation/berkeley-db/db/ref/transapp/logfile.html 
            ● 恢复程序
                - http://www.oracle.com/technology/documentation/berkeley-db/db/ref/transapp/recovery.html 
            ● 热故障转移
                - http://www.oracle.com/technology/documentation/berkeley-db/db/ref/transapp/hotfail.html 
            ● 完整的 Berkeley DB 标志列表
                - http://www.oracle.com/technology/documentation/berkeley-db/db/api_c/env_set_flags.html 
        
        高级安装可以使用特殊的环境设置来微调一些 Berkeley DB 选项（更改日志文件限制等）。
            这可以通过使用 DB_CONFIG 文件来完成。
        可以在由 slapd.conf（5）设置的 BDB 后端目录中创建此魔术文件。
        有关此文件的更多信息，请参见“文件命名”一章。
        可以在 C 接口中找到特定的指令，查找 DB_ENV->set_XXXX 调用。

        注意：
            DB_CONFIG 文件中设置的选项会覆盖 OpenLDAP 设置的选项。
            使用它们时要格外小心。除非您知道自己在做什么，否则不要使用它们。

        使用 DB_CONFIG 的优点如下：
            ● 将数据文件和日志文件保存在不同的介质（例如磁盘）上，以提高性能和/或可靠性；
            ● 微调一些特定的选项（例如共享内存区域的大小）；
            ● 设置日志文件限制（在执行此操作之前，请先阅读日志文件限制）。
        
        为了找出最佳实践的 BDB 备份方案，
            强烈建议读者阅读整个第 9 章：Berkeley DB 事务性数据存储应用程序。
            本章是一组小页面，其中包含 C 语言示例。非编程人员可以跳过这些示例。

        总结：
            在DB_CONFIG文件中 设置了对 BDB的限制 
                如 设置BDB的transaction log的一些限制

    19.3. Checkpointing
    19.3. 检查点

        如果在 slapd.conf 中放入“checkpoint 1024 5”（checkpoint在1024kb或5分钟 后），
        则不会像您想的那样每 5 分钟检查一次。霍华德的解释是：

        “在 OpenLDAP 2.1 和 2.2 中，检查点指令的行为如下-
            *当有写操作时*，并且自上一个检查点以来已超过<check>分钟，请执行检查点。
            如果在写操作后经过<check>分钟以上而未发生任何其他写操作，则不会执行任何检查点，因此有可能会丢失上一次发生的写操作。”
                换句话说，在最后一个检查点之后少于“check”分钟发生的写操作将不会被检查，
                直到从检查点经过“check”分钟之后才进行下一次写操作。
        
        在 2.3 中已对其进行了修改，
            实际上确实经常进行检查点检查。
            同时，一种解决方法是每隔5 分钟（例如 5 分钟）从 cron 脚本中调用“db_checkpoint”。
    

    19.4. Migration
    19.4. 迁移

        根据您的部署类型，在版本之间或升级之间迁移的最简单步骤是：
            ● 方便时停止当前服务器
            ● slapcat 导出当前数据
            ● 清除当前数据目录（/usr/local/var/openldap-data/），将 DB_CONFIG 保留在原位
            ● 进行软件升级
            ● 将导出的数据重新添加到目录中
            ● 启动服务器
        显然，这不能满足诸如 MirrorMode 或 N-Way Multi-Provider 之类的任何复杂部署的要求，
        但是遵循上述内容并使用商业支持或社区支持应该会有所帮助。还要检查“疑难解答”部分。



20. 监视器(Monitoring)

    slapd支持可选的LDAP监视接口，您可以使用该接口来获取有关slapd实例当前状态的信息。
        例如，该界面允许您确定当前有多少客户端连接到服务器。
        监视信息由专门的后端（监视后端）提供。
        手册页 slapd-monitor（5）可用。
    
    总结：
        有专门的 monitor backends 用来支持 monitor
    
    启用监视界面后，可以使用 LDAP 客户端访问由监视后端提供的信息，但要受访问和其他控制的约束。

    启用后，监控器后端会动态生成并返回对象，以响应 cn=Monitor 子树中的搜索请求。
        每个对象都包含有关服务器特定方面的信息。
        该信息保存在用户应用程序和操作属性的组合中。
    可以使用 ldapsearch，任何通用 LDAP 浏览器或专用监视工具来访问此信息。
        访问监视信息部分(Accessing Monitoring Information) : 提供了有关如何使用 ldapsearch访问监视信息的简短教程，
        监视信息部分(Monitor information)                 : 详细介绍了监视信息库及其组织。
    
    总结：
        cn=Monitor 子树 负责发出 搜索请求
        monitor backends负责收集信息，并将信息返回给 cn=Monitor 子树 
 
    虽然对监视器后端的支持已包含在 slapd的默认内部版本中，但此支持需要一些配置才能生效。
    这可以使用 cn=config 或 slapd.conf（5）完成。
        前者将在本章的  通过cn=config配置监视     中进行讨论。
        后者在本章的    通过slapd.conf配置监视器  配置中讨论。
    这些部分假定监视器后端内置在 slapd 中（例如--enable-monitor=yes，是默认值）。
        如果监视器后端是作为模块构建的（例如--enable-monitor=mod，则必须加载此模块。
        配置slapd 和  slapd配置文件  章节中讨论了模块的加载。
    
    总结：
        使用cn=config 或 slapd.conf 来配置 monitor backends

    20.1. Monitor configuration via cn=config(5)
    20.1. 通过cn=config配置监视

        这部分还没有写(手册里没写)。

    20.2. Monitor configuration via slapd.conf(5)
    20.2.通过slapd.conf配置监视器

        首先，请确保您的 slapd.conf文件中包含 core.schema 模式配置文件。监控后端需要它。

        其次，通过在现有数据库部分下方添加数据库监视器指令来实例化监视器后端。例
            database monitor
        
        最后，根据需要添加其他全局或数据库指令。

        像大多数其他数据库后端一样，监视器后端也确实支持 slapd访问其他管理控件。
            由于某些监视器信息可能很敏感，
                因此通常建议将 cn=monitor 的访问权限限制为目录管理员及其监视代理。
            在数据库监控器指令的正下方添加访问指令是一种控制访问的清晰有效的方法。
                例如，在数据库监视器指令的正下方添加以下访问指令将访问特定目录管理器的监视信息的访问限制为。
                    access to *
                    by dn.exact="cn=Manager,dc=example,dc=com"
                    by * none
        
        slapd的访问控制的更多信息，请参阅 控制指令部分的 slapd配置文件章节和slapd.access。

        在重新启动slapd之后，
            您就可以开始研究cn=config中提供的监视信息了，
            正如本章中访问监视信息一节所讨论的那样。
        
        通过尝试读取cn=monitor对象，可以验证slapd是否被正确配置为提供监控信息。
        例如，如果下面的ldapsearch命令返回cn=monitor对象(按照请求，没有属性)，那么它就工作了。
            ldapsearch -x -D 'cn=Manager,dc=example,dc=com' -W -b 'cn=Monitor' -s base 1.1
        
        请注意，与通用的后端数据库不同，该数据库后缀是固定的。
            它总是为 cn=Minitor。
            因此，应提供无后缀的指令。
        还要注意的是通用的后端数据库，监控后端不能被实例化多次。
            也就是说，只能有数据库监控的一个（或零）出现在服务器的配置。
        
    总结：
        在slapd.conf中配置monitor backends
            必须包含core.schema
            必须要在 需要监视的数据库下 添加 database monitor，来实例化一个monitor backends
            必须要设置访问控制
            cn=config提供监控信息 
            监控数据库的后缀 一定是 cn=Monitor 
    
    总结：
        实例化monitor后
        monitor backends把监控信息 提供给 cn=Monitor数据库
        我们通过ldapsearch去 cn=Monitor 上读取 监控信息即可




        
    20.3. 获取监控信息(Accessing Monitoring Information)

        如前所述，当启用时，监视器后端会动态生成并返回对象，以响应cn=Monitor子树中的搜索请求。
            每个对象都包含关于服务器特定方面的信息。
            信息保存在用户应用程序和操作属性的组合中。
        可以使用ldapsearch、任何通用LDAP浏览器或专门的监控工具访问这些信息。

        要检查任何特定的监视对象，请使用 一个baseObject范围 和 一个（objectClass=*）过滤器 对该对象执行搜索操作。
            由于监视信息包含在用户应用程序和操作属性的组合中，
            因此应请求返回 所有用户应用程序属性（例如“*”）和 所有操作属性（例如“+”）。
            例如，要读取 cn=Monitor对象本身，可以使用 ldapsearch命令（修改以适合您的配置）：
                ldapsearch -x -D 'cn=Manager,dc=example,dc=com' -W \
                    -b 'cn=Monitor' -s base '(objectClass=*)' '*' '+'
            在服务器上运行时，这将产生类似于以下内容的输出：
                dn: cn=Monitor
                objectClass: monitorServer
                structuralObjectClass: monitorServer
                cn: Monitor
                creatorsName:
                modifiersName:
                createTimestamp: 20061208223558Z
                modifyTimestamp: 20061208223558Z
                description: This subtree contains monitoring/managing objects.
                description: This object contains information about this server.
                description: Most of the information is held in operational attributes, which
                must be explicitly requested.
                monitoredInfo: OpenLDAP: slapd 2.4 (Dec  7 2006 17:30:29)
                entryDN: cn=Monitor
                subschemaSubentry: cn=Subschema
                hasSubordinates: TRUE
        
        为了减少返回的无用属性的数量，在请求返回哪些属性时可以有更多选择。
            例如，可以请求返回 monitorServer对象类 所允许的所有属性（例如@objectClass），而不是所有用户和所有操作属性：
                ldapsearch -x -D 'cn=Manager,dc=example,dc=com' -W \ 
                    -b 'cn=Monitor' -s base '(objectClass=*)' '@monitorServer'
            这里限制了输出，如下所示：
                dn: cn=Monitor
                objectClass: monitorServer
                cn: Monitor
                description: This subtree contains monitoring/managing objects.
                description: This object contains information about this server.
                description: Most of the information is held in operational attributes, which
                must be explicitly requested.
                monitoredInfo: OpenLDAP: slapd 2.X (Dec  7 2006 17:30:29)
            这是必须明确要求的。
                monitoredInfo: OpenLDAP: slapd 2.X (Dec 7 2006 17:30:29)
        
        要返回所有监视对象的名称，
            请执行带有子树范围和（objectClass=*）过滤器的 cn=Monitor的搜索，
            并且不请求返回任何属性（例如 1.1）。
        
        ldapsearch -x -D 'cn=Manager,dc=example,dc=com' -W -b 'cn=Monitor' -s sub 1.1
        
        如果运行此命令，将会发现 cn=Monitor 子树中有许多对象。
        
        以下部分描述了一些常用的监视对象。

    20.4. Monitor Information
    20.4. 监控信息

        监视后端提供了大量信息，可用于监视一组监视对象中包含的 slapd。 
            每个对象都包含有关服务器特定方面的信息，
            例如后端，连接或线程。
        一些对象充当其他对象的容器，并用于构造对象的层次结构。

        在此层次结构中，最高级的对象是{cn=Monitor}。
        尽管此对象主要充当其他对象的容器，其中大多数是容器，但该对象提供有关此服务器的信息。
        特别是，它提供了 slapd版本字符串。例子：
            dn: cn=Monitor
            monitoredInfo: OpenLDAP: slapd 2.X (Dec 7 2006 17:30:29)
        
        注意：本节（及其子节）中的示例已被剪裁为仅显示关键信息。
    

        20.4.1. Backends

            cn=Backends,cn=Monitor 对象本身提供了可用后端的列表。
            可用后端的列表包括所有内置后端以及模块加载的后端。例如：
                dn: cn=Backends,cn=Monitor
                monitoredInfo: config
                monitoredInfo: ldif
                monitoredInfo: monitor
                monitoredInfo: bdb
                monitoredInfo: hdb
            这表示 config，ldif，monitor，bdb 和 hdb 后端可用。


            cn=Backends,cn=Monitor 对象也是可用后端对象的容器。
            每个可用的后端对象都包含有关特定后端的信息。
            例如：
                dn: cn=Backend 0,cn=Backends,cn=Monitor
                monitoredInfo: config
                monitorRuntimeConfig: TRUE
                supportedControl: 2.16.840.1.113730.3.4.2
                seeAlso: cn=Database 0,cn=Databases,cn=Monitor
                dn: cn=Backend 1,cn=Backends,cn=Monitor
                monitoredInfo: ldif
                monitorRuntimeConfig: TRUE
                supportedControl: 2.16.840.1.113730.3.4.2
                dn: cn=Backend 2,cn=Backends,cn=Monitor
                monitoredInfo: monitor
                monitorRuntimeConfig: TRUE
                supportedControl: 2.16.840.1.113730.3.4.2
                seeAlso: cn=Database 2,cn=Databases,cn=Monitor
                dn: cn=Backend 3,cn=Backends,cn=Monitor
                monitoredInfo: bdb
                monitorRuntimeConfig: TRUE
                supportedControl: 1.3.6.1.1.12
                supportedControl: 2.16.840.1.113730.3.4.2
                supportedControl: 1.3.6.1.4.1.4203.666.5.2
                supportedControl: 1.2.840.113556.1.4.319
                supportedControl: 1.3.6.1.1.13.1
                supportedControl: 1.3.6.1.1.13.2
                supportedControl: 1.3.6.1.4.1.4203.1.10.1
                supportedControl: 1.2.840.113556.1.4.1413
                supportedControl: 1.3.6.1.4.1.4203.666.11.7.2
                seeAlso: cn=Database 1,cn=Databases,cn=Monitor
                dn: cn=Backend 4,cn=Backends,cn=Monitor
                monitoredInfo: hdb
                monitorRuntimeConfig: TRUE
                supportedControl: 1.3.6.1.1.12
                supportedControl: 2.16.840.1.113730.3.4.2
                supportedControl: 1.3.6.1.4.1.4203.666.5.2
                supportedControl: 1.2.840.113556.1.4.319
                supportedControl: 1.3.6.1.1.13.1
                supportedControl: 1.3.6.1.1.13.2
                supportedControl: 1.3.6.1.4.1.4203.1.10.1
                supportedControl: 1.2.840.113556.1.4.1413
                supportedControl: 1.3.6.1.4.1.4203.666.11.7.2
            对于这些对象中的每一个，
                monitorInfo 指示该对象中的信息是关于哪个后端的。
                例如，cn=Backend 3,cn=Backends,cn=Monitor 对象包含（在示例中）有关 bdb 后端的信息。

              Attribute           Description
            monitoredInfo       Name of backend
            supportedControl    supported LDAP control extensions
            seeAlso             Database objects of instances of this backend

        总结：
            cn=Backends,cn=Monitor用于指定 特定的监控器后端

        20.4.2. Connections

            主条目为空；它应该包含一些有关连接数量的统计信息。

            将为每个打开的连接创建动态子条目，并提供该连接上活动的统计信息（该格式将在后面详细介绍）。
            有两个特殊的子项，分别显示了总连接数和当前连接数。
            例如：
            总连接数：
                dn: cn=Total,cn=Connections,cn=Monitor
                structuralObjectClass: monitorCounterObject
                monitorCounter: 4
                entryDN: cn=Total,cn=Connections,cn=Monitor
                subschemaSubentry: cn=Subschema
                hasSubordinates: FALSE
                Current Connections:
            当前连接：
                dn: cn=Current,cn=Connections,cn=Monitor
                structuralObjectClass: monitorCounterObject
                monitorCounter: 2
                entryDN: cn=Current,cn=Connections,cn=Monitor
                subschemaSubentry: cn=Subschema
                hasSubordinates: FALSE
            
            总结：
                cn=Connections,cn=Monitor 负责统计 连接相关的信息
        
        20.4.3. Databases

            主条目包含每个已配置数据库的命名上下文；
            对于每个数据库，子条目都包含类型和命名上下文。
            例如：
                dn: cn=Database 2,cn=Databases,cn=Monitor
                structuralObjectClass: monitoredObject
                monitoredInfo: monitor
                monitorIsShadow: FALSE
                monitorContext: cn=Monitor
                readOnly: FALSE
                entryDN: cn=Database 2,cn=Databases,cn=Monitor
                subschemaSubentry: cn=Subschema
                hasSubordinates: FALSE
        
        20.4.4. Listener

            它包含服务器当前正在侦听的设备的描述：
                dn: cn=Listener 0,cn=Listeners,cn=Monitor
                structuralObjectClass: monitoredObject
                monitorConnectionLocalAddress: IP=0.0.0.0:389
                entryDN: cn=Listener 0,cn=Listeners,cn=Monitor
                subschemaSubentry: cn=Subschema
                hasSubordinates: FALSE
        
        20.4.5. Log

            它包含当前活动的日志项。
            日志子系统允许用户修改描述属性上的操作，该属性的值必须在可允许的日志开关列表中：
                Trace
                Packets
                Args
                Conns
                BER
                Filter
                Config
                ACL
                Stats
                Stats2
                Shell
                Parse
                Sync
            这些值可以添加，替换或删除。
            它们会影响将哪些消息发送到 syslog 设备。
            可以通过自定义模块添加自定义值。

        20.4.6. Operations

            它显示了有关服务器执行的操作的一些统计信息：
                Initiated
                Completed
            并针对每种操作类型，即：
                Bind
                Unbind
                Add
                Delete
                Modrdn
                Modify
                Compare
                Search
                Abandon
                Extended
            类型太多，无法在此处列出示例，因此请使用 Monitor search example 自行尝试
        
        20.4.7. Overlays

            主条目包含运行时可用的叠加层(overlays)类型。
            对于每个覆盖，子条目均包含覆盖(overlay)的类型。
            
            如果启用了动态叠加(overlays)，它还应该包含已加载的模块：
                # Overlays, Monitor
                dn: cn=Overlays,cn=Monitor
                structuralObjectClass: monitorContainer
                monitoredInfo: syncprov
                monitoredInfo: accesslog
                monitoredInfo: glue
                entryDN: cn=Overlays,cn=Monitor
                subschemaSubentry: cn=Subschema
                hasSubordinates: TRUE
        

        20.4.8. SASL
            目前是空的。

        20.4.9. Statistics

            它显示了有关服务器发送的数据的一些统计信息：
                Bytes
                PDU
                Entries
                Referrals
            例如
                # Entries, Statistics, Monitor
                dn: cn=Entries,cn=Statistics,cn=Monitor
                structuralObjectClass: monitorCounterObject
                monitorCounter: 612248
                entryDN: cn=Entries,cn=Statistics,cn=Monitor
                subschemaSubentry: cn=Subschema
                hasSubordinates: FALSE
        
        20.4.10. Threads

            它包含启动时启用的最大线程数和当前的反向负载。
            e.g.
                # Max, Threads, Monitor
                dn: cn=Max,cn=Threads,cn=Monitor
                structuralObjectClass: monitoredObject
                monitoredInfo: 16
                entryDN: cn=Max,cn=Threads,cn=Monitor
                subschemaSubentry: cn=Subschema
                hasSubordinates: FALSE

        20.4.11. Time

            它包含两个子条目，分别包含服务器的开始时间和当前时间。

            e.g.
            Start time:
                dn: cn=Start,cn=Time,cn=Monitor
                structuralObjectClass: monitoredObject
                monitorTimestamp: 20061205124040Z
                entryDN: cn=Start,cn=Time,cn=Monitor
                subschemaSubentry: cn=Subschema
                hasSubordinates: FALSE
            Current time:
                dn: cn=Current,cn=Time,cn=Monitor
                structuralObjectClass: monitoredObject
                monitorTimestamp: 20061207120624Z
                entryDN: cn=Current,cn=Time,cn=Monitor
                subschemaSubentry: cn=Subschema
                hasSubordinates: FALSE
        
        20.4.12. TLS
            
            目前是空的。
        
        20.4.13. Waiters

            它包含当前 读等待者 的数量。
            
            e.g.
            Read waiters:
            读等待：
                dn: cn=Read,cn=Waiters,cn=Monitor
                structuralObjectClass: monitorCounterObject
                monitorCounter: 7
                entryDN: cn=Read,cn=Waiters,cn=Monitor
                subschemaSubentry: cn=Subschema
                hasSubordinates: FALSE
            Write waiters:
            写等待：
                dn: cn=Write,cn=Waiters,cn=Monitor
                structuralObjectClass: monitorCounterObject
                monitorCounter: 0
                entryDN: cn=Write,cn=Waiters,cn=Monitor
                subschemaSubentry: cn=Subschema
                hasSubordinates: FALSE

            在此处添加新的监视对象并进行讨论，参考手册页和当前示例




            -----------------------------------    
            -----------------------------------    
            
                -----------------------------------
                -----------------------------------

            -----------------------------------
        -----------------------------------
        -----------------------------------
        -----------------------------------
        -----------------------------------

    ----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
-----------------------------------
-----------------------------------
-----------------------------------
-----------------------------------
